
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>
/**
 * Model Endereco
 * 
 */
export type Endereco = $Result.DefaultSelection<Prisma.$EnderecoPayload>
/**
 * Model Cartao
 * 
 */
export type Cartao = $Result.DefaultSelection<Prisma.$CartaoPayload>
/**
 * Model Cliente
 * 
 */
export type Cliente = $Result.DefaultSelection<Prisma.$ClientePayload>
/**
 * Model Fornecedor
 * 
 */
export type Fornecedor = $Result.DefaultSelection<Prisma.$FornecedorPayload>
/**
 * Model DadosBancarios
 * 
 */
export type DadosBancarios = $Result.DefaultSelection<Prisma.$DadosBancariosPayload>
/**
 * Model Cupom
 * 
 */
export type Cupom = $Result.DefaultSelection<Prisma.$CupomPayload>
/**
 * Model CarrinhoCompras
 * 
 */
export type CarrinhoCompras = $Result.DefaultSelection<Prisma.$CarrinhoComprasPayload>
/**
 * Model Item
 * 
 */
export type Item = $Result.DefaultSelection<Prisma.$ItemPayload>
/**
 * Model Produto
 * 
 */
export type Produto = $Result.DefaultSelection<Prisma.$ProdutoPayload>
/**
 * Model Servico
 * 
 */
export type Servico = $Result.DefaultSelection<Prisma.$ServicoPayload>
/**
 * Model Avaliacao
 * 
 */
export type Avaliacao = $Result.DefaultSelection<Prisma.$AvaliacaoPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const TipoPagamento: {
  CartaoCredito: 'CartaoCredito',
  CartaoDebito: 'CartaoDebito',
  Dinheiro: 'Dinheiro',
  Pix: 'Pix'
};

export type TipoPagamento = (typeof TipoPagamento)[keyof typeof TipoPagamento]


export const TipoCartao: {
  DEBITO: 'DEBITO',
  CREDITO: 'CREDITO'
};

export type TipoCartao = (typeof TipoCartao)[keyof typeof TipoCartao]

}

export type TipoPagamento = $Enums.TipoPagamento

export const TipoPagamento: typeof $Enums.TipoPagamento

export type TipoCartao = $Enums.TipoCartao

export const TipoCartao: typeof $Enums.TipoCartao

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Usuarios
 * const usuarios = await prisma.usuario.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Usuarios
   * const usuarios = await prisma.usuario.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.endereco`: Exposes CRUD operations for the **Endereco** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Enderecos
    * const enderecos = await prisma.endereco.findMany()
    * ```
    */
  get endereco(): Prisma.EnderecoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cartao`: Exposes CRUD operations for the **Cartao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cartaos
    * const cartaos = await prisma.cartao.findMany()
    * ```
    */
  get cartao(): Prisma.CartaoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cliente`: Exposes CRUD operations for the **Cliente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clientes
    * const clientes = await prisma.cliente.findMany()
    * ```
    */
  get cliente(): Prisma.ClienteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fornecedor`: Exposes CRUD operations for the **Fornecedor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fornecedors
    * const fornecedors = await prisma.fornecedor.findMany()
    * ```
    */
  get fornecedor(): Prisma.FornecedorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dadosBancarios`: Exposes CRUD operations for the **DadosBancarios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DadosBancarios
    * const dadosBancarios = await prisma.dadosBancarios.findMany()
    * ```
    */
  get dadosBancarios(): Prisma.DadosBancariosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cupom`: Exposes CRUD operations for the **Cupom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cupoms
    * const cupoms = await prisma.cupom.findMany()
    * ```
    */
  get cupom(): Prisma.CupomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.carrinhoCompras`: Exposes CRUD operations for the **CarrinhoCompras** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CarrinhoCompras
    * const carrinhoCompras = await prisma.carrinhoCompras.findMany()
    * ```
    */
  get carrinhoCompras(): Prisma.CarrinhoComprasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.item`: Exposes CRUD operations for the **Item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.item.findMany()
    * ```
    */
  get item(): Prisma.ItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.produto`: Exposes CRUD operations for the **Produto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Produtos
    * const produtos = await prisma.produto.findMany()
    * ```
    */
  get produto(): Prisma.ProdutoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.servico`: Exposes CRUD operations for the **Servico** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servicos
    * const servicos = await prisma.servico.findMany()
    * ```
    */
  get servico(): Prisma.ServicoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.avaliacao`: Exposes CRUD operations for the **Avaliacao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Avaliacaos
    * const avaliacaos = await prisma.avaliacao.findMany()
    * ```
    */
  get avaliacao(): Prisma.AvaliacaoDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.0
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Usuario: 'Usuario',
    Endereco: 'Endereco',
    Cartao: 'Cartao',
    Cliente: 'Cliente',
    Fornecedor: 'Fornecedor',
    DadosBancarios: 'DadosBancarios',
    Cupom: 'Cupom',
    CarrinhoCompras: 'CarrinhoCompras',
    Item: 'Item',
    Produto: 'Produto',
    Servico: 'Servico',
    Avaliacao: 'Avaliacao'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "usuario" | "endereco" | "cartao" | "cliente" | "fornecedor" | "dadosBancarios" | "cupom" | "carrinhoCompras" | "item" | "produto" | "servico" | "avaliacao"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsuarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsuarioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      Endereco: {
        payload: Prisma.$EnderecoPayload<ExtArgs>
        fields: Prisma.EnderecoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnderecoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnderecoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload>
          }
          findFirst: {
            args: Prisma.EnderecoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnderecoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload>
          }
          findMany: {
            args: Prisma.EnderecoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload>[]
          }
          create: {
            args: Prisma.EnderecoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload>
          }
          createMany: {
            args: Prisma.EnderecoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EnderecoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload>[]
          }
          delete: {
            args: Prisma.EnderecoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload>
          }
          update: {
            args: Prisma.EnderecoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload>
          }
          deleteMany: {
            args: Prisma.EnderecoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnderecoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EnderecoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload>[]
          }
          upsert: {
            args: Prisma.EnderecoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload>
          }
          aggregate: {
            args: Prisma.EnderecoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEndereco>
          }
          groupBy: {
            args: Prisma.EnderecoGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnderecoGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnderecoCountArgs<ExtArgs>
            result: $Utils.Optional<EnderecoCountAggregateOutputType> | number
          }
        }
      }
      Cartao: {
        payload: Prisma.$CartaoPayload<ExtArgs>
        fields: Prisma.CartaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CartaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CartaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartaoPayload>
          }
          findFirst: {
            args: Prisma.CartaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CartaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartaoPayload>
          }
          findMany: {
            args: Prisma.CartaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartaoPayload>[]
          }
          create: {
            args: Prisma.CartaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartaoPayload>
          }
          createMany: {
            args: Prisma.CartaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CartaoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartaoPayload>[]
          }
          delete: {
            args: Prisma.CartaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartaoPayload>
          }
          update: {
            args: Prisma.CartaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartaoPayload>
          }
          deleteMany: {
            args: Prisma.CartaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CartaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CartaoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartaoPayload>[]
          }
          upsert: {
            args: Prisma.CartaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartaoPayload>
          }
          aggregate: {
            args: Prisma.CartaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCartao>
          }
          groupBy: {
            args: Prisma.CartaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<CartaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.CartaoCountArgs<ExtArgs>
            result: $Utils.Optional<CartaoCountAggregateOutputType> | number
          }
        }
      }
      Cliente: {
        payload: Prisma.$ClientePayload<ExtArgs>
        fields: Prisma.ClienteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClienteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClienteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          findFirst: {
            args: Prisma.ClienteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClienteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          findMany: {
            args: Prisma.ClienteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>[]
          }
          create: {
            args: Prisma.ClienteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          createMany: {
            args: Prisma.ClienteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClienteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>[]
          }
          delete: {
            args: Prisma.ClienteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          update: {
            args: Prisma.ClienteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          deleteMany: {
            args: Prisma.ClienteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClienteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClienteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>[]
          }
          upsert: {
            args: Prisma.ClienteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          aggregate: {
            args: Prisma.ClienteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCliente>
          }
          groupBy: {
            args: Prisma.ClienteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClienteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClienteCountArgs<ExtArgs>
            result: $Utils.Optional<ClienteCountAggregateOutputType> | number
          }
        }
      }
      Fornecedor: {
        payload: Prisma.$FornecedorPayload<ExtArgs>
        fields: Prisma.FornecedorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FornecedorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FornecedorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FornecedorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FornecedorPayload>
          }
          findFirst: {
            args: Prisma.FornecedorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FornecedorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FornecedorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FornecedorPayload>
          }
          findMany: {
            args: Prisma.FornecedorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FornecedorPayload>[]
          }
          create: {
            args: Prisma.FornecedorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FornecedorPayload>
          }
          createMany: {
            args: Prisma.FornecedorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FornecedorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FornecedorPayload>[]
          }
          delete: {
            args: Prisma.FornecedorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FornecedorPayload>
          }
          update: {
            args: Prisma.FornecedorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FornecedorPayload>
          }
          deleteMany: {
            args: Prisma.FornecedorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FornecedorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FornecedorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FornecedorPayload>[]
          }
          upsert: {
            args: Prisma.FornecedorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FornecedorPayload>
          }
          aggregate: {
            args: Prisma.FornecedorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFornecedor>
          }
          groupBy: {
            args: Prisma.FornecedorGroupByArgs<ExtArgs>
            result: $Utils.Optional<FornecedorGroupByOutputType>[]
          }
          count: {
            args: Prisma.FornecedorCountArgs<ExtArgs>
            result: $Utils.Optional<FornecedorCountAggregateOutputType> | number
          }
        }
      }
      DadosBancarios: {
        payload: Prisma.$DadosBancariosPayload<ExtArgs>
        fields: Prisma.DadosBancariosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DadosBancariosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DadosBancariosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DadosBancariosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DadosBancariosPayload>
          }
          findFirst: {
            args: Prisma.DadosBancariosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DadosBancariosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DadosBancariosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DadosBancariosPayload>
          }
          findMany: {
            args: Prisma.DadosBancariosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DadosBancariosPayload>[]
          }
          create: {
            args: Prisma.DadosBancariosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DadosBancariosPayload>
          }
          createMany: {
            args: Prisma.DadosBancariosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DadosBancariosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DadosBancariosPayload>[]
          }
          delete: {
            args: Prisma.DadosBancariosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DadosBancariosPayload>
          }
          update: {
            args: Prisma.DadosBancariosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DadosBancariosPayload>
          }
          deleteMany: {
            args: Prisma.DadosBancariosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DadosBancariosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DadosBancariosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DadosBancariosPayload>[]
          }
          upsert: {
            args: Prisma.DadosBancariosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DadosBancariosPayload>
          }
          aggregate: {
            args: Prisma.DadosBancariosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDadosBancarios>
          }
          groupBy: {
            args: Prisma.DadosBancariosGroupByArgs<ExtArgs>
            result: $Utils.Optional<DadosBancariosGroupByOutputType>[]
          }
          count: {
            args: Prisma.DadosBancariosCountArgs<ExtArgs>
            result: $Utils.Optional<DadosBancariosCountAggregateOutputType> | number
          }
        }
      }
      Cupom: {
        payload: Prisma.$CupomPayload<ExtArgs>
        fields: Prisma.CupomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CupomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CupomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CupomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CupomPayload>
          }
          findFirst: {
            args: Prisma.CupomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CupomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CupomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CupomPayload>
          }
          findMany: {
            args: Prisma.CupomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CupomPayload>[]
          }
          create: {
            args: Prisma.CupomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CupomPayload>
          }
          createMany: {
            args: Prisma.CupomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CupomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CupomPayload>[]
          }
          delete: {
            args: Prisma.CupomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CupomPayload>
          }
          update: {
            args: Prisma.CupomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CupomPayload>
          }
          deleteMany: {
            args: Prisma.CupomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CupomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CupomUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CupomPayload>[]
          }
          upsert: {
            args: Prisma.CupomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CupomPayload>
          }
          aggregate: {
            args: Prisma.CupomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCupom>
          }
          groupBy: {
            args: Prisma.CupomGroupByArgs<ExtArgs>
            result: $Utils.Optional<CupomGroupByOutputType>[]
          }
          count: {
            args: Prisma.CupomCountArgs<ExtArgs>
            result: $Utils.Optional<CupomCountAggregateOutputType> | number
          }
        }
      }
      CarrinhoCompras: {
        payload: Prisma.$CarrinhoComprasPayload<ExtArgs>
        fields: Prisma.CarrinhoComprasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CarrinhoComprasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarrinhoComprasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CarrinhoComprasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarrinhoComprasPayload>
          }
          findFirst: {
            args: Prisma.CarrinhoComprasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarrinhoComprasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CarrinhoComprasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarrinhoComprasPayload>
          }
          findMany: {
            args: Prisma.CarrinhoComprasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarrinhoComprasPayload>[]
          }
          create: {
            args: Prisma.CarrinhoComprasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarrinhoComprasPayload>
          }
          createMany: {
            args: Prisma.CarrinhoComprasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CarrinhoComprasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarrinhoComprasPayload>[]
          }
          delete: {
            args: Prisma.CarrinhoComprasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarrinhoComprasPayload>
          }
          update: {
            args: Prisma.CarrinhoComprasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarrinhoComprasPayload>
          }
          deleteMany: {
            args: Prisma.CarrinhoComprasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CarrinhoComprasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CarrinhoComprasUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarrinhoComprasPayload>[]
          }
          upsert: {
            args: Prisma.CarrinhoComprasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarrinhoComprasPayload>
          }
          aggregate: {
            args: Prisma.CarrinhoComprasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCarrinhoCompras>
          }
          groupBy: {
            args: Prisma.CarrinhoComprasGroupByArgs<ExtArgs>
            result: $Utils.Optional<CarrinhoComprasGroupByOutputType>[]
          }
          count: {
            args: Prisma.CarrinhoComprasCountArgs<ExtArgs>
            result: $Utils.Optional<CarrinhoComprasCountAggregateOutputType> | number
          }
        }
      }
      Item: {
        payload: Prisma.$ItemPayload<ExtArgs>
        fields: Prisma.ItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findFirst: {
            args: Prisma.ItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findMany: {
            args: Prisma.ItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          create: {
            args: Prisma.ItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          createMany: {
            args: Prisma.ItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          delete: {
            args: Prisma.ItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          update: {
            args: Prisma.ItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          deleteMany: {
            args: Prisma.ItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          upsert: {
            args: Prisma.ItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          aggregate: {
            args: Prisma.ItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItem>
          }
          groupBy: {
            args: Prisma.ItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemCountArgs<ExtArgs>
            result: $Utils.Optional<ItemCountAggregateOutputType> | number
          }
        }
      }
      Produto: {
        payload: Prisma.$ProdutoPayload<ExtArgs>
        fields: Prisma.ProdutoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProdutoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProdutoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload>
          }
          findFirst: {
            args: Prisma.ProdutoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProdutoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload>
          }
          findMany: {
            args: Prisma.ProdutoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload>[]
          }
          create: {
            args: Prisma.ProdutoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload>
          }
          createMany: {
            args: Prisma.ProdutoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProdutoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload>[]
          }
          delete: {
            args: Prisma.ProdutoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload>
          }
          update: {
            args: Prisma.ProdutoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload>
          }
          deleteMany: {
            args: Prisma.ProdutoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProdutoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProdutoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload>[]
          }
          upsert: {
            args: Prisma.ProdutoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdutoPayload>
          }
          aggregate: {
            args: Prisma.ProdutoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduto>
          }
          groupBy: {
            args: Prisma.ProdutoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProdutoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProdutoCountArgs<ExtArgs>
            result: $Utils.Optional<ProdutoCountAggregateOutputType> | number
          }
        }
      }
      Servico: {
        payload: Prisma.$ServicoPayload<ExtArgs>
        fields: Prisma.ServicoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServicoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServicoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicoPayload>
          }
          findFirst: {
            args: Prisma.ServicoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServicoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicoPayload>
          }
          findMany: {
            args: Prisma.ServicoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicoPayload>[]
          }
          create: {
            args: Prisma.ServicoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicoPayload>
          }
          createMany: {
            args: Prisma.ServicoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServicoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicoPayload>[]
          }
          delete: {
            args: Prisma.ServicoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicoPayload>
          }
          update: {
            args: Prisma.ServicoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicoPayload>
          }
          deleteMany: {
            args: Prisma.ServicoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServicoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServicoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicoPayload>[]
          }
          upsert: {
            args: Prisma.ServicoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicoPayload>
          }
          aggregate: {
            args: Prisma.ServicoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServico>
          }
          groupBy: {
            args: Prisma.ServicoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServicoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServicoCountArgs<ExtArgs>
            result: $Utils.Optional<ServicoCountAggregateOutputType> | number
          }
        }
      }
      Avaliacao: {
        payload: Prisma.$AvaliacaoPayload<ExtArgs>
        fields: Prisma.AvaliacaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AvaliacaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AvaliacaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload>
          }
          findFirst: {
            args: Prisma.AvaliacaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AvaliacaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload>
          }
          findMany: {
            args: Prisma.AvaliacaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload>[]
          }
          create: {
            args: Prisma.AvaliacaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload>
          }
          createMany: {
            args: Prisma.AvaliacaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AvaliacaoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload>[]
          }
          delete: {
            args: Prisma.AvaliacaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload>
          }
          update: {
            args: Prisma.AvaliacaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload>
          }
          deleteMany: {
            args: Prisma.AvaliacaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AvaliacaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AvaliacaoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload>[]
          }
          upsert: {
            args: Prisma.AvaliacaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload>
          }
          aggregate: {
            args: Prisma.AvaliacaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAvaliacao>
          }
          groupBy: {
            args: Prisma.AvaliacaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<AvaliacaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.AvaliacaoCountArgs<ExtArgs>
            result: $Utils.Optional<AvaliacaoCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    usuario?: UsuarioOmit
    endereco?: EnderecoOmit
    cartao?: CartaoOmit
    cliente?: ClienteOmit
    fornecedor?: FornecedorOmit
    dadosBancarios?: DadosBancariosOmit
    cupom?: CupomOmit
    carrinhoCompras?: CarrinhoComprasOmit
    item?: ItemOmit
    produto?: ProdutoOmit
    servico?: ServicoOmit
    avaliacao?: AvaliacaoOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    cartoes: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cartoes?: boolean | UsuarioCountOutputTypeCountCartoesArgs
  }

  // Custom InputTypes
  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountCartoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartaoWhereInput
  }


  /**
   * Count Type ClienteCountOutputType
   */

  export type ClienteCountOutputType = {
    cupons: number
  }

  export type ClienteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cupons?: boolean | ClienteCountOutputTypeCountCuponsArgs
  }

  // Custom InputTypes
  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteCountOutputType
     */
    select?: ClienteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeCountCuponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CupomWhereInput
  }


  /**
   * Count Type FornecedorCountOutputType
   */

  export type FornecedorCountOutputType = {
    avaliacoes: number
    produtos: number
    servicos: number
  }

  export type FornecedorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avaliacoes?: boolean | FornecedorCountOutputTypeCountAvaliacoesArgs
    produtos?: boolean | FornecedorCountOutputTypeCountProdutosArgs
    servicos?: boolean | FornecedorCountOutputTypeCountServicosArgs
  }

  // Custom InputTypes
  /**
   * FornecedorCountOutputType without action
   */
  export type FornecedorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FornecedorCountOutputType
     */
    select?: FornecedorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FornecedorCountOutputType without action
   */
  export type FornecedorCountOutputTypeCountAvaliacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvaliacaoWhereInput
  }

  /**
   * FornecedorCountOutputType without action
   */
  export type FornecedorCountOutputTypeCountProdutosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProdutoWhereInput
  }

  /**
   * FornecedorCountOutputType without action
   */
  export type FornecedorCountOutputTypeCountServicosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicoWhereInput
  }


  /**
   * Count Type CarrinhoComprasCountOutputType
   */

  export type CarrinhoComprasCountOutputType = {
    items: number
  }

  export type CarrinhoComprasCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | CarrinhoComprasCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * CarrinhoComprasCountOutputType without action
   */
  export type CarrinhoComprasCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarrinhoComprasCountOutputType
     */
    select?: CarrinhoComprasCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CarrinhoComprasCountOutputType without action
   */
  export type CarrinhoComprasCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    id: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    id: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: number | null
    nome: string | null
    email: string | null
    senha: string | null
    imagemPerfil: string | null
    tipo: string | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    email: string | null
    senha: string | null
    imagemPerfil: string | null
    tipo: string | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    nome: number
    email: number
    senha: number
    imagemPerfil: number
    tipo: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    id?: true
  }

  export type UsuarioSumAggregateInputType = {
    id?: true
  }

  export type UsuarioMinAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    senha?: true
    imagemPerfil?: true
    tipo?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    senha?: true
    imagemPerfil?: true
    tipo?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    senha?: true
    imagemPerfil?: true
    tipo?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id: number
    nome: string
    email: string
    senha: string
    imagemPerfil: string | null
    tipo: string
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    email?: boolean
    senha?: boolean
    imagemPerfil?: boolean
    tipo?: boolean
    endereco?: boolean | Usuario$enderecoArgs<ExtArgs>
    cartoes?: boolean | Usuario$cartoesArgs<ExtArgs>
    cliente?: boolean | Usuario$clienteArgs<ExtArgs>
    fornecedor?: boolean | Usuario$fornecedorArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    email?: boolean
    senha?: boolean
    imagemPerfil?: boolean
    tipo?: boolean
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    email?: boolean
    senha?: boolean
    imagemPerfil?: boolean
    tipo?: boolean
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectScalar = {
    id?: boolean
    nome?: boolean
    email?: boolean
    senha?: boolean
    imagemPerfil?: boolean
    tipo?: boolean
  }

  export type UsuarioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "email" | "senha" | "imagemPerfil" | "tipo", ExtArgs["result"]["usuario"]>
  export type UsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    endereco?: boolean | Usuario$enderecoArgs<ExtArgs>
    cartoes?: boolean | Usuario$cartoesArgs<ExtArgs>
    cliente?: boolean | Usuario$clienteArgs<ExtArgs>
    fornecedor?: boolean | Usuario$fornecedorArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsuarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UsuarioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {
      endereco: Prisma.$EnderecoPayload<ExtArgs> | null
      cartoes: Prisma.$CartaoPayload<ExtArgs>[]
      cliente: Prisma.$ClientePayload<ExtArgs> | null
      fornecedor: Prisma.$FornecedorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      email: string
      senha: string
      imagemPerfil: string | null
      tipo: string
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioFindUniqueArgs>(args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioFindFirstArgs>(args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsuarioFindManyArgs>(args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends UsuarioCreateArgs>(args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Usuarios.
     * @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioCreateManyArgs>(args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Usuarios and returns the data saved in the database.
     * @param {UsuarioCreateManyAndReturnArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Usuarios and only return the `id`
     * const usuarioWithIdOnly = await prisma.usuario.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsuarioCreateManyAndReturnArgs>(args?: SelectSubset<T, UsuarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends UsuarioDeleteArgs>(args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioUpdateArgs>(args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioDeleteManyArgs>(args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioUpdateManyArgs>(args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios and returns the data updated in the database.
     * @param {UsuarioUpdateManyAndReturnArgs} args - Arguments to update many Usuarios.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Usuarios and only return the `id`
     * const usuarioWithIdOnly = await prisma.usuario.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsuarioUpdateManyAndReturnArgs>(args: SelectSubset<T, UsuarioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioUpsertArgs>(args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    endereco<T extends Usuario$enderecoArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$enderecoArgs<ExtArgs>>): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    cartoes<T extends Usuario$cartoesArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$cartoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cliente<T extends Usuario$clienteArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$clienteArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    fornecedor<T extends Usuario$fornecedorArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$fornecedorArgs<ExtArgs>>): Prisma__FornecedorClient<$Result.GetResult<Prisma.$FornecedorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usuario model
   */
  interface UsuarioFieldRefs {
    readonly id: FieldRef<"Usuario", 'Int'>
    readonly nome: FieldRef<"Usuario", 'String'>
    readonly email: FieldRef<"Usuario", 'String'>
    readonly senha: FieldRef<"Usuario", 'String'>
    readonly imagemPerfil: FieldRef<"Usuario", 'String'>
    readonly tipo: FieldRef<"Usuario", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }

  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario createManyAndReturn
   */
  export type UsuarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
    /**
     * Limit how many Usuarios to update.
     */
    limit?: number
  }

  /**
   * Usuario updateManyAndReturn
   */
  export type UsuarioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
    /**
     * Limit how many Usuarios to update.
     */
    limit?: number
  }

  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }

  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
    /**
     * Limit how many Usuarios to delete.
     */
    limit?: number
  }

  /**
   * Usuario.endereco
   */
  export type Usuario$enderecoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoInclude<ExtArgs> | null
    where?: EnderecoWhereInput
  }

  /**
   * Usuario.cartoes
   */
  export type Usuario$cartoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cartao
     */
    select?: CartaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cartao
     */
    omit?: CartaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartaoInclude<ExtArgs> | null
    where?: CartaoWhereInput
    orderBy?: CartaoOrderByWithRelationInput | CartaoOrderByWithRelationInput[]
    cursor?: CartaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartaoScalarFieldEnum | CartaoScalarFieldEnum[]
  }

  /**
   * Usuario.cliente
   */
  export type Usuario$clienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    where?: ClienteWhereInput
  }

  /**
   * Usuario.fornecedor
   */
  export type Usuario$fornecedorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fornecedor
     */
    select?: FornecedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fornecedor
     */
    omit?: FornecedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FornecedorInclude<ExtArgs> | null
    where?: FornecedorWhereInput
  }

  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
  }


  /**
   * Model Endereco
   */

  export type AggregateEndereco = {
    _count: EnderecoCountAggregateOutputType | null
    _avg: EnderecoAvgAggregateOutputType | null
    _sum: EnderecoSumAggregateOutputType | null
    _min: EnderecoMinAggregateOutputType | null
    _max: EnderecoMaxAggregateOutputType | null
  }

  export type EnderecoAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type EnderecoSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type EnderecoMinAggregateOutputType = {
    id: number | null
    rua: string | null
    bairro: string | null
    cep: string | null
    numero: string | null
    complemento: string | null
    usuarioId: number | null
  }

  export type EnderecoMaxAggregateOutputType = {
    id: number | null
    rua: string | null
    bairro: string | null
    cep: string | null
    numero: string | null
    complemento: string | null
    usuarioId: number | null
  }

  export type EnderecoCountAggregateOutputType = {
    id: number
    rua: number
    bairro: number
    cep: number
    numero: number
    complemento: number
    usuarioId: number
    _all: number
  }


  export type EnderecoAvgAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type EnderecoSumAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type EnderecoMinAggregateInputType = {
    id?: true
    rua?: true
    bairro?: true
    cep?: true
    numero?: true
    complemento?: true
    usuarioId?: true
  }

  export type EnderecoMaxAggregateInputType = {
    id?: true
    rua?: true
    bairro?: true
    cep?: true
    numero?: true
    complemento?: true
    usuarioId?: true
  }

  export type EnderecoCountAggregateInputType = {
    id?: true
    rua?: true
    bairro?: true
    cep?: true
    numero?: true
    complemento?: true
    usuarioId?: true
    _all?: true
  }

  export type EnderecoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Endereco to aggregate.
     */
    where?: EnderecoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enderecos to fetch.
     */
    orderBy?: EnderecoOrderByWithRelationInput | EnderecoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnderecoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enderecos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enderecos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Enderecos
    **/
    _count?: true | EnderecoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnderecoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnderecoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnderecoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnderecoMaxAggregateInputType
  }

  export type GetEnderecoAggregateType<T extends EnderecoAggregateArgs> = {
        [P in keyof T & keyof AggregateEndereco]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEndereco[P]>
      : GetScalarType<T[P], AggregateEndereco[P]>
  }




  export type EnderecoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnderecoWhereInput
    orderBy?: EnderecoOrderByWithAggregationInput | EnderecoOrderByWithAggregationInput[]
    by: EnderecoScalarFieldEnum[] | EnderecoScalarFieldEnum
    having?: EnderecoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnderecoCountAggregateInputType | true
    _avg?: EnderecoAvgAggregateInputType
    _sum?: EnderecoSumAggregateInputType
    _min?: EnderecoMinAggregateInputType
    _max?: EnderecoMaxAggregateInputType
  }

  export type EnderecoGroupByOutputType = {
    id: number
    rua: string
    bairro: string
    cep: string
    numero: string
    complemento: string
    usuarioId: number
    _count: EnderecoCountAggregateOutputType | null
    _avg: EnderecoAvgAggregateOutputType | null
    _sum: EnderecoSumAggregateOutputType | null
    _min: EnderecoMinAggregateOutputType | null
    _max: EnderecoMaxAggregateOutputType | null
  }

  type GetEnderecoGroupByPayload<T extends EnderecoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnderecoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnderecoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnderecoGroupByOutputType[P]>
            : GetScalarType<T[P], EnderecoGroupByOutputType[P]>
        }
      >
    >


  export type EnderecoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rua?: boolean
    bairro?: boolean
    cep?: boolean
    numero?: boolean
    complemento?: boolean
    usuarioId?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["endereco"]>

  export type EnderecoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rua?: boolean
    bairro?: boolean
    cep?: boolean
    numero?: boolean
    complemento?: boolean
    usuarioId?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["endereco"]>

  export type EnderecoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rua?: boolean
    bairro?: boolean
    cep?: boolean
    numero?: boolean
    complemento?: boolean
    usuarioId?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["endereco"]>

  export type EnderecoSelectScalar = {
    id?: boolean
    rua?: boolean
    bairro?: boolean
    cep?: boolean
    numero?: boolean
    complemento?: boolean
    usuarioId?: boolean
  }

  export type EnderecoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rua" | "bairro" | "cep" | "numero" | "complemento" | "usuarioId", ExtArgs["result"]["endereco"]>
  export type EnderecoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type EnderecoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type EnderecoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $EnderecoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Endereco"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rua: string
      bairro: string
      cep: string
      numero: string
      complemento: string
      usuarioId: number
    }, ExtArgs["result"]["endereco"]>
    composites: {}
  }

  type EnderecoGetPayload<S extends boolean | null | undefined | EnderecoDefaultArgs> = $Result.GetResult<Prisma.$EnderecoPayload, S>

  type EnderecoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EnderecoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EnderecoCountAggregateInputType | true
    }

  export interface EnderecoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Endereco'], meta: { name: 'Endereco' } }
    /**
     * Find zero or one Endereco that matches the filter.
     * @param {EnderecoFindUniqueArgs} args - Arguments to find a Endereco
     * @example
     * // Get one Endereco
     * const endereco = await prisma.endereco.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnderecoFindUniqueArgs>(args: SelectSubset<T, EnderecoFindUniqueArgs<ExtArgs>>): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Endereco that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EnderecoFindUniqueOrThrowArgs} args - Arguments to find a Endereco
     * @example
     * // Get one Endereco
     * const endereco = await prisma.endereco.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnderecoFindUniqueOrThrowArgs>(args: SelectSubset<T, EnderecoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Endereco that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoFindFirstArgs} args - Arguments to find a Endereco
     * @example
     * // Get one Endereco
     * const endereco = await prisma.endereco.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnderecoFindFirstArgs>(args?: SelectSubset<T, EnderecoFindFirstArgs<ExtArgs>>): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Endereco that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoFindFirstOrThrowArgs} args - Arguments to find a Endereco
     * @example
     * // Get one Endereco
     * const endereco = await prisma.endereco.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnderecoFindFirstOrThrowArgs>(args?: SelectSubset<T, EnderecoFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Enderecos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enderecos
     * const enderecos = await prisma.endereco.findMany()
     * 
     * // Get first 10 Enderecos
     * const enderecos = await prisma.endereco.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enderecoWithIdOnly = await prisma.endereco.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EnderecoFindManyArgs>(args?: SelectSubset<T, EnderecoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Endereco.
     * @param {EnderecoCreateArgs} args - Arguments to create a Endereco.
     * @example
     * // Create one Endereco
     * const Endereco = await prisma.endereco.create({
     *   data: {
     *     // ... data to create a Endereco
     *   }
     * })
     * 
     */
    create<T extends EnderecoCreateArgs>(args: SelectSubset<T, EnderecoCreateArgs<ExtArgs>>): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Enderecos.
     * @param {EnderecoCreateManyArgs} args - Arguments to create many Enderecos.
     * @example
     * // Create many Enderecos
     * const endereco = await prisma.endereco.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnderecoCreateManyArgs>(args?: SelectSubset<T, EnderecoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Enderecos and returns the data saved in the database.
     * @param {EnderecoCreateManyAndReturnArgs} args - Arguments to create many Enderecos.
     * @example
     * // Create many Enderecos
     * const endereco = await prisma.endereco.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Enderecos and only return the `id`
     * const enderecoWithIdOnly = await prisma.endereco.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EnderecoCreateManyAndReturnArgs>(args?: SelectSubset<T, EnderecoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Endereco.
     * @param {EnderecoDeleteArgs} args - Arguments to delete one Endereco.
     * @example
     * // Delete one Endereco
     * const Endereco = await prisma.endereco.delete({
     *   where: {
     *     // ... filter to delete one Endereco
     *   }
     * })
     * 
     */
    delete<T extends EnderecoDeleteArgs>(args: SelectSubset<T, EnderecoDeleteArgs<ExtArgs>>): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Endereco.
     * @param {EnderecoUpdateArgs} args - Arguments to update one Endereco.
     * @example
     * // Update one Endereco
     * const endereco = await prisma.endereco.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnderecoUpdateArgs>(args: SelectSubset<T, EnderecoUpdateArgs<ExtArgs>>): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Enderecos.
     * @param {EnderecoDeleteManyArgs} args - Arguments to filter Enderecos to delete.
     * @example
     * // Delete a few Enderecos
     * const { count } = await prisma.endereco.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnderecoDeleteManyArgs>(args?: SelectSubset<T, EnderecoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enderecos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enderecos
     * const endereco = await prisma.endereco.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnderecoUpdateManyArgs>(args: SelectSubset<T, EnderecoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enderecos and returns the data updated in the database.
     * @param {EnderecoUpdateManyAndReturnArgs} args - Arguments to update many Enderecos.
     * @example
     * // Update many Enderecos
     * const endereco = await prisma.endereco.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Enderecos and only return the `id`
     * const enderecoWithIdOnly = await prisma.endereco.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EnderecoUpdateManyAndReturnArgs>(args: SelectSubset<T, EnderecoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Endereco.
     * @param {EnderecoUpsertArgs} args - Arguments to update or create a Endereco.
     * @example
     * // Update or create a Endereco
     * const endereco = await prisma.endereco.upsert({
     *   create: {
     *     // ... data to create a Endereco
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Endereco we want to update
     *   }
     * })
     */
    upsert<T extends EnderecoUpsertArgs>(args: SelectSubset<T, EnderecoUpsertArgs<ExtArgs>>): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Enderecos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoCountArgs} args - Arguments to filter Enderecos to count.
     * @example
     * // Count the number of Enderecos
     * const count = await prisma.endereco.count({
     *   where: {
     *     // ... the filter for the Enderecos we want to count
     *   }
     * })
    **/
    count<T extends EnderecoCountArgs>(
      args?: Subset<T, EnderecoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnderecoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Endereco.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnderecoAggregateArgs>(args: Subset<T, EnderecoAggregateArgs>): Prisma.PrismaPromise<GetEnderecoAggregateType<T>>

    /**
     * Group by Endereco.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnderecoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnderecoGroupByArgs['orderBy'] }
        : { orderBy?: EnderecoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnderecoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnderecoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Endereco model
   */
  readonly fields: EnderecoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Endereco.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnderecoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Endereco model
   */
  interface EnderecoFieldRefs {
    readonly id: FieldRef<"Endereco", 'Int'>
    readonly rua: FieldRef<"Endereco", 'String'>
    readonly bairro: FieldRef<"Endereco", 'String'>
    readonly cep: FieldRef<"Endereco", 'String'>
    readonly numero: FieldRef<"Endereco", 'String'>
    readonly complemento: FieldRef<"Endereco", 'String'>
    readonly usuarioId: FieldRef<"Endereco", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Endereco findUnique
   */
  export type EnderecoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoInclude<ExtArgs> | null
    /**
     * Filter, which Endereco to fetch.
     */
    where: EnderecoWhereUniqueInput
  }

  /**
   * Endereco findUniqueOrThrow
   */
  export type EnderecoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoInclude<ExtArgs> | null
    /**
     * Filter, which Endereco to fetch.
     */
    where: EnderecoWhereUniqueInput
  }

  /**
   * Endereco findFirst
   */
  export type EnderecoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoInclude<ExtArgs> | null
    /**
     * Filter, which Endereco to fetch.
     */
    where?: EnderecoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enderecos to fetch.
     */
    orderBy?: EnderecoOrderByWithRelationInput | EnderecoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enderecos.
     */
    cursor?: EnderecoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enderecos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enderecos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enderecos.
     */
    distinct?: EnderecoScalarFieldEnum | EnderecoScalarFieldEnum[]
  }

  /**
   * Endereco findFirstOrThrow
   */
  export type EnderecoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoInclude<ExtArgs> | null
    /**
     * Filter, which Endereco to fetch.
     */
    where?: EnderecoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enderecos to fetch.
     */
    orderBy?: EnderecoOrderByWithRelationInput | EnderecoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enderecos.
     */
    cursor?: EnderecoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enderecos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enderecos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enderecos.
     */
    distinct?: EnderecoScalarFieldEnum | EnderecoScalarFieldEnum[]
  }

  /**
   * Endereco findMany
   */
  export type EnderecoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoInclude<ExtArgs> | null
    /**
     * Filter, which Enderecos to fetch.
     */
    where?: EnderecoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enderecos to fetch.
     */
    orderBy?: EnderecoOrderByWithRelationInput | EnderecoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Enderecos.
     */
    cursor?: EnderecoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enderecos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enderecos.
     */
    skip?: number
    distinct?: EnderecoScalarFieldEnum | EnderecoScalarFieldEnum[]
  }

  /**
   * Endereco create
   */
  export type EnderecoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoInclude<ExtArgs> | null
    /**
     * The data needed to create a Endereco.
     */
    data: XOR<EnderecoCreateInput, EnderecoUncheckedCreateInput>
  }

  /**
   * Endereco createMany
   */
  export type EnderecoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Enderecos.
     */
    data: EnderecoCreateManyInput | EnderecoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Endereco createManyAndReturn
   */
  export type EnderecoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * The data used to create many Enderecos.
     */
    data: EnderecoCreateManyInput | EnderecoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Endereco update
   */
  export type EnderecoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoInclude<ExtArgs> | null
    /**
     * The data needed to update a Endereco.
     */
    data: XOR<EnderecoUpdateInput, EnderecoUncheckedUpdateInput>
    /**
     * Choose, which Endereco to update.
     */
    where: EnderecoWhereUniqueInput
  }

  /**
   * Endereco updateMany
   */
  export type EnderecoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Enderecos.
     */
    data: XOR<EnderecoUpdateManyMutationInput, EnderecoUncheckedUpdateManyInput>
    /**
     * Filter which Enderecos to update
     */
    where?: EnderecoWhereInput
    /**
     * Limit how many Enderecos to update.
     */
    limit?: number
  }

  /**
   * Endereco updateManyAndReturn
   */
  export type EnderecoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * The data used to update Enderecos.
     */
    data: XOR<EnderecoUpdateManyMutationInput, EnderecoUncheckedUpdateManyInput>
    /**
     * Filter which Enderecos to update
     */
    where?: EnderecoWhereInput
    /**
     * Limit how many Enderecos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Endereco upsert
   */
  export type EnderecoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoInclude<ExtArgs> | null
    /**
     * The filter to search for the Endereco to update in case it exists.
     */
    where: EnderecoWhereUniqueInput
    /**
     * In case the Endereco found by the `where` argument doesn't exist, create a new Endereco with this data.
     */
    create: XOR<EnderecoCreateInput, EnderecoUncheckedCreateInput>
    /**
     * In case the Endereco was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnderecoUpdateInput, EnderecoUncheckedUpdateInput>
  }

  /**
   * Endereco delete
   */
  export type EnderecoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoInclude<ExtArgs> | null
    /**
     * Filter which Endereco to delete.
     */
    where: EnderecoWhereUniqueInput
  }

  /**
   * Endereco deleteMany
   */
  export type EnderecoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enderecos to delete
     */
    where?: EnderecoWhereInput
    /**
     * Limit how many Enderecos to delete.
     */
    limit?: number
  }

  /**
   * Endereco without action
   */
  export type EnderecoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoInclude<ExtArgs> | null
  }


  /**
   * Model Cartao
   */

  export type AggregateCartao = {
    _count: CartaoCountAggregateOutputType | null
    _avg: CartaoAvgAggregateOutputType | null
    _sum: CartaoSumAggregateOutputType | null
    _min: CartaoMinAggregateOutputType | null
    _max: CartaoMaxAggregateOutputType | null
  }

  export type CartaoAvgAggregateOutputType = {
    id: number | null
    cvc: number | null
    usuarioId: number | null
  }

  export type CartaoSumAggregateOutputType = {
    id: number | null
    cvc: number | null
    usuarioId: number | null
  }

  export type CartaoMinAggregateOutputType = {
    id: number | null
    tipoCartao: $Enums.TipoCartao | null
    numeroCartao: string | null
    cvc: number | null
    nomeCartao: string | null
    dataValidade: Date | null
    usuarioId: number | null
  }

  export type CartaoMaxAggregateOutputType = {
    id: number | null
    tipoCartao: $Enums.TipoCartao | null
    numeroCartao: string | null
    cvc: number | null
    nomeCartao: string | null
    dataValidade: Date | null
    usuarioId: number | null
  }

  export type CartaoCountAggregateOutputType = {
    id: number
    tipoCartao: number
    numeroCartao: number
    cvc: number
    nomeCartao: number
    dataValidade: number
    usuarioId: number
    _all: number
  }


  export type CartaoAvgAggregateInputType = {
    id?: true
    cvc?: true
    usuarioId?: true
  }

  export type CartaoSumAggregateInputType = {
    id?: true
    cvc?: true
    usuarioId?: true
  }

  export type CartaoMinAggregateInputType = {
    id?: true
    tipoCartao?: true
    numeroCartao?: true
    cvc?: true
    nomeCartao?: true
    dataValidade?: true
    usuarioId?: true
  }

  export type CartaoMaxAggregateInputType = {
    id?: true
    tipoCartao?: true
    numeroCartao?: true
    cvc?: true
    nomeCartao?: true
    dataValidade?: true
    usuarioId?: true
  }

  export type CartaoCountAggregateInputType = {
    id?: true
    tipoCartao?: true
    numeroCartao?: true
    cvc?: true
    nomeCartao?: true
    dataValidade?: true
    usuarioId?: true
    _all?: true
  }

  export type CartaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cartao to aggregate.
     */
    where?: CartaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cartaos to fetch.
     */
    orderBy?: CartaoOrderByWithRelationInput | CartaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CartaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cartaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cartaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cartaos
    **/
    _count?: true | CartaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CartaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CartaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartaoMaxAggregateInputType
  }

  export type GetCartaoAggregateType<T extends CartaoAggregateArgs> = {
        [P in keyof T & keyof AggregateCartao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCartao[P]>
      : GetScalarType<T[P], AggregateCartao[P]>
  }




  export type CartaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartaoWhereInput
    orderBy?: CartaoOrderByWithAggregationInput | CartaoOrderByWithAggregationInput[]
    by: CartaoScalarFieldEnum[] | CartaoScalarFieldEnum
    having?: CartaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartaoCountAggregateInputType | true
    _avg?: CartaoAvgAggregateInputType
    _sum?: CartaoSumAggregateInputType
    _min?: CartaoMinAggregateInputType
    _max?: CartaoMaxAggregateInputType
  }

  export type CartaoGroupByOutputType = {
    id: number
    tipoCartao: $Enums.TipoCartao
    numeroCartao: string
    cvc: number
    nomeCartao: string
    dataValidade: Date
    usuarioId: number
    _count: CartaoCountAggregateOutputType | null
    _avg: CartaoAvgAggregateOutputType | null
    _sum: CartaoSumAggregateOutputType | null
    _min: CartaoMinAggregateOutputType | null
    _max: CartaoMaxAggregateOutputType | null
  }

  type GetCartaoGroupByPayload<T extends CartaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartaoGroupByOutputType[P]>
            : GetScalarType<T[P], CartaoGroupByOutputType[P]>
        }
      >
    >


  export type CartaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipoCartao?: boolean
    numeroCartao?: boolean
    cvc?: boolean
    nomeCartao?: boolean
    dataValidade?: boolean
    usuarioId?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cartao"]>

  export type CartaoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipoCartao?: boolean
    numeroCartao?: boolean
    cvc?: boolean
    nomeCartao?: boolean
    dataValidade?: boolean
    usuarioId?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cartao"]>

  export type CartaoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipoCartao?: boolean
    numeroCartao?: boolean
    cvc?: boolean
    nomeCartao?: boolean
    dataValidade?: boolean
    usuarioId?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cartao"]>

  export type CartaoSelectScalar = {
    id?: boolean
    tipoCartao?: boolean
    numeroCartao?: boolean
    cvc?: boolean
    nomeCartao?: boolean
    dataValidade?: boolean
    usuarioId?: boolean
  }

  export type CartaoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tipoCartao" | "numeroCartao" | "cvc" | "nomeCartao" | "dataValidade" | "usuarioId", ExtArgs["result"]["cartao"]>
  export type CartaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type CartaoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type CartaoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $CartaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cartao"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tipoCartao: $Enums.TipoCartao
      numeroCartao: string
      cvc: number
      nomeCartao: string
      dataValidade: Date
      usuarioId: number
    }, ExtArgs["result"]["cartao"]>
    composites: {}
  }

  type CartaoGetPayload<S extends boolean | null | undefined | CartaoDefaultArgs> = $Result.GetResult<Prisma.$CartaoPayload, S>

  type CartaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CartaoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CartaoCountAggregateInputType | true
    }

  export interface CartaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cartao'], meta: { name: 'Cartao' } }
    /**
     * Find zero or one Cartao that matches the filter.
     * @param {CartaoFindUniqueArgs} args - Arguments to find a Cartao
     * @example
     * // Get one Cartao
     * const cartao = await prisma.cartao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CartaoFindUniqueArgs>(args: SelectSubset<T, CartaoFindUniqueArgs<ExtArgs>>): Prisma__CartaoClient<$Result.GetResult<Prisma.$CartaoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cartao that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CartaoFindUniqueOrThrowArgs} args - Arguments to find a Cartao
     * @example
     * // Get one Cartao
     * const cartao = await prisma.cartao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CartaoFindUniqueOrThrowArgs>(args: SelectSubset<T, CartaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CartaoClient<$Result.GetResult<Prisma.$CartaoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cartao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartaoFindFirstArgs} args - Arguments to find a Cartao
     * @example
     * // Get one Cartao
     * const cartao = await prisma.cartao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CartaoFindFirstArgs>(args?: SelectSubset<T, CartaoFindFirstArgs<ExtArgs>>): Prisma__CartaoClient<$Result.GetResult<Prisma.$CartaoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cartao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartaoFindFirstOrThrowArgs} args - Arguments to find a Cartao
     * @example
     * // Get one Cartao
     * const cartao = await prisma.cartao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CartaoFindFirstOrThrowArgs>(args?: SelectSubset<T, CartaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__CartaoClient<$Result.GetResult<Prisma.$CartaoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cartaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cartaos
     * const cartaos = await prisma.cartao.findMany()
     * 
     * // Get first 10 Cartaos
     * const cartaos = await prisma.cartao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cartaoWithIdOnly = await prisma.cartao.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CartaoFindManyArgs>(args?: SelectSubset<T, CartaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cartao.
     * @param {CartaoCreateArgs} args - Arguments to create a Cartao.
     * @example
     * // Create one Cartao
     * const Cartao = await prisma.cartao.create({
     *   data: {
     *     // ... data to create a Cartao
     *   }
     * })
     * 
     */
    create<T extends CartaoCreateArgs>(args: SelectSubset<T, CartaoCreateArgs<ExtArgs>>): Prisma__CartaoClient<$Result.GetResult<Prisma.$CartaoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cartaos.
     * @param {CartaoCreateManyArgs} args - Arguments to create many Cartaos.
     * @example
     * // Create many Cartaos
     * const cartao = await prisma.cartao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CartaoCreateManyArgs>(args?: SelectSubset<T, CartaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cartaos and returns the data saved in the database.
     * @param {CartaoCreateManyAndReturnArgs} args - Arguments to create many Cartaos.
     * @example
     * // Create many Cartaos
     * const cartao = await prisma.cartao.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cartaos and only return the `id`
     * const cartaoWithIdOnly = await prisma.cartao.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CartaoCreateManyAndReturnArgs>(args?: SelectSubset<T, CartaoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartaoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cartao.
     * @param {CartaoDeleteArgs} args - Arguments to delete one Cartao.
     * @example
     * // Delete one Cartao
     * const Cartao = await prisma.cartao.delete({
     *   where: {
     *     // ... filter to delete one Cartao
     *   }
     * })
     * 
     */
    delete<T extends CartaoDeleteArgs>(args: SelectSubset<T, CartaoDeleteArgs<ExtArgs>>): Prisma__CartaoClient<$Result.GetResult<Prisma.$CartaoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cartao.
     * @param {CartaoUpdateArgs} args - Arguments to update one Cartao.
     * @example
     * // Update one Cartao
     * const cartao = await prisma.cartao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CartaoUpdateArgs>(args: SelectSubset<T, CartaoUpdateArgs<ExtArgs>>): Prisma__CartaoClient<$Result.GetResult<Prisma.$CartaoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cartaos.
     * @param {CartaoDeleteManyArgs} args - Arguments to filter Cartaos to delete.
     * @example
     * // Delete a few Cartaos
     * const { count } = await prisma.cartao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CartaoDeleteManyArgs>(args?: SelectSubset<T, CartaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cartaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cartaos
     * const cartao = await prisma.cartao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CartaoUpdateManyArgs>(args: SelectSubset<T, CartaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cartaos and returns the data updated in the database.
     * @param {CartaoUpdateManyAndReturnArgs} args - Arguments to update many Cartaos.
     * @example
     * // Update many Cartaos
     * const cartao = await prisma.cartao.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cartaos and only return the `id`
     * const cartaoWithIdOnly = await prisma.cartao.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CartaoUpdateManyAndReturnArgs>(args: SelectSubset<T, CartaoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartaoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cartao.
     * @param {CartaoUpsertArgs} args - Arguments to update or create a Cartao.
     * @example
     * // Update or create a Cartao
     * const cartao = await prisma.cartao.upsert({
     *   create: {
     *     // ... data to create a Cartao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cartao we want to update
     *   }
     * })
     */
    upsert<T extends CartaoUpsertArgs>(args: SelectSubset<T, CartaoUpsertArgs<ExtArgs>>): Prisma__CartaoClient<$Result.GetResult<Prisma.$CartaoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cartaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartaoCountArgs} args - Arguments to filter Cartaos to count.
     * @example
     * // Count the number of Cartaos
     * const count = await prisma.cartao.count({
     *   where: {
     *     // ... the filter for the Cartaos we want to count
     *   }
     * })
    **/
    count<T extends CartaoCountArgs>(
      args?: Subset<T, CartaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cartao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartaoAggregateArgs>(args: Subset<T, CartaoAggregateArgs>): Prisma.PrismaPromise<GetCartaoAggregateType<T>>

    /**
     * Group by Cartao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CartaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartaoGroupByArgs['orderBy'] }
        : { orderBy?: CartaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CartaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cartao model
   */
  readonly fields: CartaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cartao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CartaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cartao model
   */
  interface CartaoFieldRefs {
    readonly id: FieldRef<"Cartao", 'Int'>
    readonly tipoCartao: FieldRef<"Cartao", 'TipoCartao'>
    readonly numeroCartao: FieldRef<"Cartao", 'String'>
    readonly cvc: FieldRef<"Cartao", 'Int'>
    readonly nomeCartao: FieldRef<"Cartao", 'String'>
    readonly dataValidade: FieldRef<"Cartao", 'DateTime'>
    readonly usuarioId: FieldRef<"Cartao", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Cartao findUnique
   */
  export type CartaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cartao
     */
    select?: CartaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cartao
     */
    omit?: CartaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartaoInclude<ExtArgs> | null
    /**
     * Filter, which Cartao to fetch.
     */
    where: CartaoWhereUniqueInput
  }

  /**
   * Cartao findUniqueOrThrow
   */
  export type CartaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cartao
     */
    select?: CartaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cartao
     */
    omit?: CartaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartaoInclude<ExtArgs> | null
    /**
     * Filter, which Cartao to fetch.
     */
    where: CartaoWhereUniqueInput
  }

  /**
   * Cartao findFirst
   */
  export type CartaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cartao
     */
    select?: CartaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cartao
     */
    omit?: CartaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartaoInclude<ExtArgs> | null
    /**
     * Filter, which Cartao to fetch.
     */
    where?: CartaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cartaos to fetch.
     */
    orderBy?: CartaoOrderByWithRelationInput | CartaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cartaos.
     */
    cursor?: CartaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cartaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cartaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cartaos.
     */
    distinct?: CartaoScalarFieldEnum | CartaoScalarFieldEnum[]
  }

  /**
   * Cartao findFirstOrThrow
   */
  export type CartaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cartao
     */
    select?: CartaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cartao
     */
    omit?: CartaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartaoInclude<ExtArgs> | null
    /**
     * Filter, which Cartao to fetch.
     */
    where?: CartaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cartaos to fetch.
     */
    orderBy?: CartaoOrderByWithRelationInput | CartaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cartaos.
     */
    cursor?: CartaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cartaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cartaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cartaos.
     */
    distinct?: CartaoScalarFieldEnum | CartaoScalarFieldEnum[]
  }

  /**
   * Cartao findMany
   */
  export type CartaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cartao
     */
    select?: CartaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cartao
     */
    omit?: CartaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartaoInclude<ExtArgs> | null
    /**
     * Filter, which Cartaos to fetch.
     */
    where?: CartaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cartaos to fetch.
     */
    orderBy?: CartaoOrderByWithRelationInput | CartaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cartaos.
     */
    cursor?: CartaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cartaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cartaos.
     */
    skip?: number
    distinct?: CartaoScalarFieldEnum | CartaoScalarFieldEnum[]
  }

  /**
   * Cartao create
   */
  export type CartaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cartao
     */
    select?: CartaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cartao
     */
    omit?: CartaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartaoInclude<ExtArgs> | null
    /**
     * The data needed to create a Cartao.
     */
    data: XOR<CartaoCreateInput, CartaoUncheckedCreateInput>
  }

  /**
   * Cartao createMany
   */
  export type CartaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cartaos.
     */
    data: CartaoCreateManyInput | CartaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cartao createManyAndReturn
   */
  export type CartaoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cartao
     */
    select?: CartaoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cartao
     */
    omit?: CartaoOmit<ExtArgs> | null
    /**
     * The data used to create many Cartaos.
     */
    data: CartaoCreateManyInput | CartaoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartaoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cartao update
   */
  export type CartaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cartao
     */
    select?: CartaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cartao
     */
    omit?: CartaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartaoInclude<ExtArgs> | null
    /**
     * The data needed to update a Cartao.
     */
    data: XOR<CartaoUpdateInput, CartaoUncheckedUpdateInput>
    /**
     * Choose, which Cartao to update.
     */
    where: CartaoWhereUniqueInput
  }

  /**
   * Cartao updateMany
   */
  export type CartaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cartaos.
     */
    data: XOR<CartaoUpdateManyMutationInput, CartaoUncheckedUpdateManyInput>
    /**
     * Filter which Cartaos to update
     */
    where?: CartaoWhereInput
    /**
     * Limit how many Cartaos to update.
     */
    limit?: number
  }

  /**
   * Cartao updateManyAndReturn
   */
  export type CartaoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cartao
     */
    select?: CartaoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cartao
     */
    omit?: CartaoOmit<ExtArgs> | null
    /**
     * The data used to update Cartaos.
     */
    data: XOR<CartaoUpdateManyMutationInput, CartaoUncheckedUpdateManyInput>
    /**
     * Filter which Cartaos to update
     */
    where?: CartaoWhereInput
    /**
     * Limit how many Cartaos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartaoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cartao upsert
   */
  export type CartaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cartao
     */
    select?: CartaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cartao
     */
    omit?: CartaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartaoInclude<ExtArgs> | null
    /**
     * The filter to search for the Cartao to update in case it exists.
     */
    where: CartaoWhereUniqueInput
    /**
     * In case the Cartao found by the `where` argument doesn't exist, create a new Cartao with this data.
     */
    create: XOR<CartaoCreateInput, CartaoUncheckedCreateInput>
    /**
     * In case the Cartao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartaoUpdateInput, CartaoUncheckedUpdateInput>
  }

  /**
   * Cartao delete
   */
  export type CartaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cartao
     */
    select?: CartaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cartao
     */
    omit?: CartaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartaoInclude<ExtArgs> | null
    /**
     * Filter which Cartao to delete.
     */
    where: CartaoWhereUniqueInput
  }

  /**
   * Cartao deleteMany
   */
  export type CartaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cartaos to delete
     */
    where?: CartaoWhereInput
    /**
     * Limit how many Cartaos to delete.
     */
    limit?: number
  }

  /**
   * Cartao without action
   */
  export type CartaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cartao
     */
    select?: CartaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cartao
     */
    omit?: CartaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartaoInclude<ExtArgs> | null
  }


  /**
   * Model Cliente
   */

  export type AggregateCliente = {
    _count: ClienteCountAggregateOutputType | null
    _avg: ClienteAvgAggregateOutputType | null
    _sum: ClienteSumAggregateOutputType | null
    _min: ClienteMinAggregateOutputType | null
    _max: ClienteMaxAggregateOutputType | null
  }

  export type ClienteAvgAggregateOutputType = {
    id: number | null
  }

  export type ClienteSumAggregateOutputType = {
    id: number | null
  }

  export type ClienteMinAggregateOutputType = {
    id: number | null
  }

  export type ClienteMaxAggregateOutputType = {
    id: number | null
  }

  export type ClienteCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type ClienteAvgAggregateInputType = {
    id?: true
  }

  export type ClienteSumAggregateInputType = {
    id?: true
  }

  export type ClienteMinAggregateInputType = {
    id?: true
  }

  export type ClienteMaxAggregateInputType = {
    id?: true
  }

  export type ClienteCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type ClienteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cliente to aggregate.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clientes
    **/
    _count?: true | ClienteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClienteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClienteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClienteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClienteMaxAggregateInputType
  }

  export type GetClienteAggregateType<T extends ClienteAggregateArgs> = {
        [P in keyof T & keyof AggregateCliente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCliente[P]>
      : GetScalarType<T[P], AggregateCliente[P]>
  }




  export type ClienteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClienteWhereInput
    orderBy?: ClienteOrderByWithAggregationInput | ClienteOrderByWithAggregationInput[]
    by: ClienteScalarFieldEnum[] | ClienteScalarFieldEnum
    having?: ClienteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClienteCountAggregateInputType | true
    _avg?: ClienteAvgAggregateInputType
    _sum?: ClienteSumAggregateInputType
    _min?: ClienteMinAggregateInputType
    _max?: ClienteMaxAggregateInputType
  }

  export type ClienteGroupByOutputType = {
    id: number
    _count: ClienteCountAggregateOutputType | null
    _avg: ClienteAvgAggregateOutputType | null
    _sum: ClienteSumAggregateOutputType | null
    _min: ClienteMinAggregateOutputType | null
    _max: ClienteMaxAggregateOutputType | null
  }

  type GetClienteGroupByPayload<T extends ClienteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClienteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClienteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClienteGroupByOutputType[P]>
            : GetScalarType<T[P], ClienteGroupByOutputType[P]>
        }
      >
    >


  export type ClienteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    cupons?: boolean | Cliente$cuponsArgs<ExtArgs>
    carrinho?: boolean | Cliente$carrinhoArgs<ExtArgs>
    _count?: boolean | ClienteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cliente"]>

  export type ClienteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cliente"]>

  export type ClienteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cliente"]>

  export type ClienteSelectScalar = {
    id?: boolean
  }

  export type ClienteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["cliente"]>
  export type ClienteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    cupons?: boolean | Cliente$cuponsArgs<ExtArgs>
    carrinho?: boolean | Cliente$carrinhoArgs<ExtArgs>
    _count?: boolean | ClienteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClienteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type ClienteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $ClientePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cliente"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
      cupons: Prisma.$CupomPayload<ExtArgs>[]
      carrinho: Prisma.$CarrinhoComprasPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
    }, ExtArgs["result"]["cliente"]>
    composites: {}
  }

  type ClienteGetPayload<S extends boolean | null | undefined | ClienteDefaultArgs> = $Result.GetResult<Prisma.$ClientePayload, S>

  type ClienteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClienteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClienteCountAggregateInputType | true
    }

  export interface ClienteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cliente'], meta: { name: 'Cliente' } }
    /**
     * Find zero or one Cliente that matches the filter.
     * @param {ClienteFindUniqueArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClienteFindUniqueArgs>(args: SelectSubset<T, ClienteFindUniqueArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cliente that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClienteFindUniqueOrThrowArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClienteFindUniqueOrThrowArgs>(args: SelectSubset<T, ClienteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cliente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindFirstArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClienteFindFirstArgs>(args?: SelectSubset<T, ClienteFindFirstArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cliente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindFirstOrThrowArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClienteFindFirstOrThrowArgs>(args?: SelectSubset<T, ClienteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clientes
     * const clientes = await prisma.cliente.findMany()
     * 
     * // Get first 10 Clientes
     * const clientes = await prisma.cliente.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clienteWithIdOnly = await prisma.cliente.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClienteFindManyArgs>(args?: SelectSubset<T, ClienteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cliente.
     * @param {ClienteCreateArgs} args - Arguments to create a Cliente.
     * @example
     * // Create one Cliente
     * const Cliente = await prisma.cliente.create({
     *   data: {
     *     // ... data to create a Cliente
     *   }
     * })
     * 
     */
    create<T extends ClienteCreateArgs>(args: SelectSubset<T, ClienteCreateArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clientes.
     * @param {ClienteCreateManyArgs} args - Arguments to create many Clientes.
     * @example
     * // Create many Clientes
     * const cliente = await prisma.cliente.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClienteCreateManyArgs>(args?: SelectSubset<T, ClienteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clientes and returns the data saved in the database.
     * @param {ClienteCreateManyAndReturnArgs} args - Arguments to create many Clientes.
     * @example
     * // Create many Clientes
     * const cliente = await prisma.cliente.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clientes and only return the `id`
     * const clienteWithIdOnly = await prisma.cliente.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClienteCreateManyAndReturnArgs>(args?: SelectSubset<T, ClienteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cliente.
     * @param {ClienteDeleteArgs} args - Arguments to delete one Cliente.
     * @example
     * // Delete one Cliente
     * const Cliente = await prisma.cliente.delete({
     *   where: {
     *     // ... filter to delete one Cliente
     *   }
     * })
     * 
     */
    delete<T extends ClienteDeleteArgs>(args: SelectSubset<T, ClienteDeleteArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cliente.
     * @param {ClienteUpdateArgs} args - Arguments to update one Cliente.
     * @example
     * // Update one Cliente
     * const cliente = await prisma.cliente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClienteUpdateArgs>(args: SelectSubset<T, ClienteUpdateArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clientes.
     * @param {ClienteDeleteManyArgs} args - Arguments to filter Clientes to delete.
     * @example
     * // Delete a few Clientes
     * const { count } = await prisma.cliente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClienteDeleteManyArgs>(args?: SelectSubset<T, ClienteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clientes
     * const cliente = await prisma.cliente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClienteUpdateManyArgs>(args: SelectSubset<T, ClienteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clientes and returns the data updated in the database.
     * @param {ClienteUpdateManyAndReturnArgs} args - Arguments to update many Clientes.
     * @example
     * // Update many Clientes
     * const cliente = await prisma.cliente.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clientes and only return the `id`
     * const clienteWithIdOnly = await prisma.cliente.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClienteUpdateManyAndReturnArgs>(args: SelectSubset<T, ClienteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cliente.
     * @param {ClienteUpsertArgs} args - Arguments to update or create a Cliente.
     * @example
     * // Update or create a Cliente
     * const cliente = await prisma.cliente.upsert({
     *   create: {
     *     // ... data to create a Cliente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cliente we want to update
     *   }
     * })
     */
    upsert<T extends ClienteUpsertArgs>(args: SelectSubset<T, ClienteUpsertArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteCountArgs} args - Arguments to filter Clientes to count.
     * @example
     * // Count the number of Clientes
     * const count = await prisma.cliente.count({
     *   where: {
     *     // ... the filter for the Clientes we want to count
     *   }
     * })
    **/
    count<T extends ClienteCountArgs>(
      args?: Subset<T, ClienteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClienteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClienteAggregateArgs>(args: Subset<T, ClienteAggregateArgs>): Prisma.PrismaPromise<GetClienteAggregateType<T>>

    /**
     * Group by Cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClienteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClienteGroupByArgs['orderBy'] }
        : { orderBy?: ClienteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClienteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClienteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cliente model
   */
  readonly fields: ClienteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cliente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClienteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cupons<T extends Cliente$cuponsArgs<ExtArgs> = {}>(args?: Subset<T, Cliente$cuponsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CupomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    carrinho<T extends Cliente$carrinhoArgs<ExtArgs> = {}>(args?: Subset<T, Cliente$carrinhoArgs<ExtArgs>>): Prisma__CarrinhoComprasClient<$Result.GetResult<Prisma.$CarrinhoComprasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cliente model
   */
  interface ClienteFieldRefs {
    readonly id: FieldRef<"Cliente", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Cliente findUnique
   */
  export type ClienteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente findUniqueOrThrow
   */
  export type ClienteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente findFirst
   */
  export type ClienteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clientes.
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clientes.
     */
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * Cliente findFirstOrThrow
   */
  export type ClienteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clientes.
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clientes.
     */
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * Cliente findMany
   */
  export type ClienteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Clientes to fetch.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clientes.
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * Cliente create
   */
  export type ClienteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * The data needed to create a Cliente.
     */
    data: XOR<ClienteCreateInput, ClienteUncheckedCreateInput>
  }

  /**
   * Cliente createMany
   */
  export type ClienteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clientes.
     */
    data: ClienteCreateManyInput | ClienteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cliente createManyAndReturn
   */
  export type ClienteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * The data used to create many Clientes.
     */
    data: ClienteCreateManyInput | ClienteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cliente update
   */
  export type ClienteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * The data needed to update a Cliente.
     */
    data: XOR<ClienteUpdateInput, ClienteUncheckedUpdateInput>
    /**
     * Choose, which Cliente to update.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente updateMany
   */
  export type ClienteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clientes.
     */
    data: XOR<ClienteUpdateManyMutationInput, ClienteUncheckedUpdateManyInput>
    /**
     * Filter which Clientes to update
     */
    where?: ClienteWhereInput
    /**
     * Limit how many Clientes to update.
     */
    limit?: number
  }

  /**
   * Cliente updateManyAndReturn
   */
  export type ClienteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * The data used to update Clientes.
     */
    data: XOR<ClienteUpdateManyMutationInput, ClienteUncheckedUpdateManyInput>
    /**
     * Filter which Clientes to update
     */
    where?: ClienteWhereInput
    /**
     * Limit how many Clientes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cliente upsert
   */
  export type ClienteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * The filter to search for the Cliente to update in case it exists.
     */
    where: ClienteWhereUniqueInput
    /**
     * In case the Cliente found by the `where` argument doesn't exist, create a new Cliente with this data.
     */
    create: XOR<ClienteCreateInput, ClienteUncheckedCreateInput>
    /**
     * In case the Cliente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClienteUpdateInput, ClienteUncheckedUpdateInput>
  }

  /**
   * Cliente delete
   */
  export type ClienteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter which Cliente to delete.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente deleteMany
   */
  export type ClienteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clientes to delete
     */
    where?: ClienteWhereInput
    /**
     * Limit how many Clientes to delete.
     */
    limit?: number
  }

  /**
   * Cliente.cupons
   */
  export type Cliente$cuponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cupom
     */
    select?: CupomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cupom
     */
    omit?: CupomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CupomInclude<ExtArgs> | null
    where?: CupomWhereInput
    orderBy?: CupomOrderByWithRelationInput | CupomOrderByWithRelationInput[]
    cursor?: CupomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CupomScalarFieldEnum | CupomScalarFieldEnum[]
  }

  /**
   * Cliente.carrinho
   */
  export type Cliente$carrinhoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarrinhoCompras
     */
    select?: CarrinhoComprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarrinhoCompras
     */
    omit?: CarrinhoComprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrinhoComprasInclude<ExtArgs> | null
    where?: CarrinhoComprasWhereInput
  }

  /**
   * Cliente without action
   */
  export type ClienteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
  }


  /**
   * Model Fornecedor
   */

  export type AggregateFornecedor = {
    _count: FornecedorCountAggregateOutputType | null
    _avg: FornecedorAvgAggregateOutputType | null
    _sum: FornecedorSumAggregateOutputType | null
    _min: FornecedorMinAggregateOutputType | null
    _max: FornecedorMaxAggregateOutputType | null
  }

  export type FornecedorAvgAggregateOutputType = {
    id: number | null
    avaliacaoTotal: number | null
  }

  export type FornecedorSumAggregateOutputType = {
    id: number | null
    avaliacaoTotal: number | null
  }

  export type FornecedorMinAggregateOutputType = {
    id: number | null
    avaliacaoTotal: number | null
  }

  export type FornecedorMaxAggregateOutputType = {
    id: number | null
    avaliacaoTotal: number | null
  }

  export type FornecedorCountAggregateOutputType = {
    id: number
    avaliacaoTotal: number
    _all: number
  }


  export type FornecedorAvgAggregateInputType = {
    id?: true
    avaliacaoTotal?: true
  }

  export type FornecedorSumAggregateInputType = {
    id?: true
    avaliacaoTotal?: true
  }

  export type FornecedorMinAggregateInputType = {
    id?: true
    avaliacaoTotal?: true
  }

  export type FornecedorMaxAggregateInputType = {
    id?: true
    avaliacaoTotal?: true
  }

  export type FornecedorCountAggregateInputType = {
    id?: true
    avaliacaoTotal?: true
    _all?: true
  }

  export type FornecedorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fornecedor to aggregate.
     */
    where?: FornecedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fornecedors to fetch.
     */
    orderBy?: FornecedorOrderByWithRelationInput | FornecedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FornecedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fornecedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fornecedors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fornecedors
    **/
    _count?: true | FornecedorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FornecedorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FornecedorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FornecedorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FornecedorMaxAggregateInputType
  }

  export type GetFornecedorAggregateType<T extends FornecedorAggregateArgs> = {
        [P in keyof T & keyof AggregateFornecedor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFornecedor[P]>
      : GetScalarType<T[P], AggregateFornecedor[P]>
  }




  export type FornecedorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FornecedorWhereInput
    orderBy?: FornecedorOrderByWithAggregationInput | FornecedorOrderByWithAggregationInput[]
    by: FornecedorScalarFieldEnum[] | FornecedorScalarFieldEnum
    having?: FornecedorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FornecedorCountAggregateInputType | true
    _avg?: FornecedorAvgAggregateInputType
    _sum?: FornecedorSumAggregateInputType
    _min?: FornecedorMinAggregateInputType
    _max?: FornecedorMaxAggregateInputType
  }

  export type FornecedorGroupByOutputType = {
    id: number
    avaliacaoTotal: number
    _count: FornecedorCountAggregateOutputType | null
    _avg: FornecedorAvgAggregateOutputType | null
    _sum: FornecedorSumAggregateOutputType | null
    _min: FornecedorMinAggregateOutputType | null
    _max: FornecedorMaxAggregateOutputType | null
  }

  type GetFornecedorGroupByPayload<T extends FornecedorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FornecedorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FornecedorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FornecedorGroupByOutputType[P]>
            : GetScalarType<T[P], FornecedorGroupByOutputType[P]>
        }
      >
    >


  export type FornecedorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    avaliacaoTotal?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    avaliacoes?: boolean | Fornecedor$avaliacoesArgs<ExtArgs>
    dadosBancarios?: boolean | Fornecedor$dadosBancariosArgs<ExtArgs>
    produtos?: boolean | Fornecedor$produtosArgs<ExtArgs>
    servicos?: boolean | Fornecedor$servicosArgs<ExtArgs>
    _count?: boolean | FornecedorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fornecedor"]>

  export type FornecedorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    avaliacaoTotal?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fornecedor"]>

  export type FornecedorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    avaliacaoTotal?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fornecedor"]>

  export type FornecedorSelectScalar = {
    id?: boolean
    avaliacaoTotal?: boolean
  }

  export type FornecedorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "avaliacaoTotal", ExtArgs["result"]["fornecedor"]>
  export type FornecedorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    avaliacoes?: boolean | Fornecedor$avaliacoesArgs<ExtArgs>
    dadosBancarios?: boolean | Fornecedor$dadosBancariosArgs<ExtArgs>
    produtos?: boolean | Fornecedor$produtosArgs<ExtArgs>
    servicos?: boolean | Fornecedor$servicosArgs<ExtArgs>
    _count?: boolean | FornecedorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FornecedorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type FornecedorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $FornecedorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Fornecedor"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
      avaliacoes: Prisma.$AvaliacaoPayload<ExtArgs>[]
      dadosBancarios: Prisma.$DadosBancariosPayload<ExtArgs> | null
      produtos: Prisma.$ProdutoPayload<ExtArgs>[]
      servicos: Prisma.$ServicoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      avaliacaoTotal: number
    }, ExtArgs["result"]["fornecedor"]>
    composites: {}
  }

  type FornecedorGetPayload<S extends boolean | null | undefined | FornecedorDefaultArgs> = $Result.GetResult<Prisma.$FornecedorPayload, S>

  type FornecedorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FornecedorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FornecedorCountAggregateInputType | true
    }

  export interface FornecedorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Fornecedor'], meta: { name: 'Fornecedor' } }
    /**
     * Find zero or one Fornecedor that matches the filter.
     * @param {FornecedorFindUniqueArgs} args - Arguments to find a Fornecedor
     * @example
     * // Get one Fornecedor
     * const fornecedor = await prisma.fornecedor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FornecedorFindUniqueArgs>(args: SelectSubset<T, FornecedorFindUniqueArgs<ExtArgs>>): Prisma__FornecedorClient<$Result.GetResult<Prisma.$FornecedorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Fornecedor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FornecedorFindUniqueOrThrowArgs} args - Arguments to find a Fornecedor
     * @example
     * // Get one Fornecedor
     * const fornecedor = await prisma.fornecedor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FornecedorFindUniqueOrThrowArgs>(args: SelectSubset<T, FornecedorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FornecedorClient<$Result.GetResult<Prisma.$FornecedorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fornecedor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FornecedorFindFirstArgs} args - Arguments to find a Fornecedor
     * @example
     * // Get one Fornecedor
     * const fornecedor = await prisma.fornecedor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FornecedorFindFirstArgs>(args?: SelectSubset<T, FornecedorFindFirstArgs<ExtArgs>>): Prisma__FornecedorClient<$Result.GetResult<Prisma.$FornecedorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fornecedor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FornecedorFindFirstOrThrowArgs} args - Arguments to find a Fornecedor
     * @example
     * // Get one Fornecedor
     * const fornecedor = await prisma.fornecedor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FornecedorFindFirstOrThrowArgs>(args?: SelectSubset<T, FornecedorFindFirstOrThrowArgs<ExtArgs>>): Prisma__FornecedorClient<$Result.GetResult<Prisma.$FornecedorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Fornecedors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FornecedorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fornecedors
     * const fornecedors = await prisma.fornecedor.findMany()
     * 
     * // Get first 10 Fornecedors
     * const fornecedors = await prisma.fornecedor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fornecedorWithIdOnly = await prisma.fornecedor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FornecedorFindManyArgs>(args?: SelectSubset<T, FornecedorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FornecedorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Fornecedor.
     * @param {FornecedorCreateArgs} args - Arguments to create a Fornecedor.
     * @example
     * // Create one Fornecedor
     * const Fornecedor = await prisma.fornecedor.create({
     *   data: {
     *     // ... data to create a Fornecedor
     *   }
     * })
     * 
     */
    create<T extends FornecedorCreateArgs>(args: SelectSubset<T, FornecedorCreateArgs<ExtArgs>>): Prisma__FornecedorClient<$Result.GetResult<Prisma.$FornecedorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Fornecedors.
     * @param {FornecedorCreateManyArgs} args - Arguments to create many Fornecedors.
     * @example
     * // Create many Fornecedors
     * const fornecedor = await prisma.fornecedor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FornecedorCreateManyArgs>(args?: SelectSubset<T, FornecedorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Fornecedors and returns the data saved in the database.
     * @param {FornecedorCreateManyAndReturnArgs} args - Arguments to create many Fornecedors.
     * @example
     * // Create many Fornecedors
     * const fornecedor = await prisma.fornecedor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Fornecedors and only return the `id`
     * const fornecedorWithIdOnly = await prisma.fornecedor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FornecedorCreateManyAndReturnArgs>(args?: SelectSubset<T, FornecedorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FornecedorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Fornecedor.
     * @param {FornecedorDeleteArgs} args - Arguments to delete one Fornecedor.
     * @example
     * // Delete one Fornecedor
     * const Fornecedor = await prisma.fornecedor.delete({
     *   where: {
     *     // ... filter to delete one Fornecedor
     *   }
     * })
     * 
     */
    delete<T extends FornecedorDeleteArgs>(args: SelectSubset<T, FornecedorDeleteArgs<ExtArgs>>): Prisma__FornecedorClient<$Result.GetResult<Prisma.$FornecedorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Fornecedor.
     * @param {FornecedorUpdateArgs} args - Arguments to update one Fornecedor.
     * @example
     * // Update one Fornecedor
     * const fornecedor = await prisma.fornecedor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FornecedorUpdateArgs>(args: SelectSubset<T, FornecedorUpdateArgs<ExtArgs>>): Prisma__FornecedorClient<$Result.GetResult<Prisma.$FornecedorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Fornecedors.
     * @param {FornecedorDeleteManyArgs} args - Arguments to filter Fornecedors to delete.
     * @example
     * // Delete a few Fornecedors
     * const { count } = await prisma.fornecedor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FornecedorDeleteManyArgs>(args?: SelectSubset<T, FornecedorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fornecedors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FornecedorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fornecedors
     * const fornecedor = await prisma.fornecedor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FornecedorUpdateManyArgs>(args: SelectSubset<T, FornecedorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fornecedors and returns the data updated in the database.
     * @param {FornecedorUpdateManyAndReturnArgs} args - Arguments to update many Fornecedors.
     * @example
     * // Update many Fornecedors
     * const fornecedor = await prisma.fornecedor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Fornecedors and only return the `id`
     * const fornecedorWithIdOnly = await prisma.fornecedor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FornecedorUpdateManyAndReturnArgs>(args: SelectSubset<T, FornecedorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FornecedorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Fornecedor.
     * @param {FornecedorUpsertArgs} args - Arguments to update or create a Fornecedor.
     * @example
     * // Update or create a Fornecedor
     * const fornecedor = await prisma.fornecedor.upsert({
     *   create: {
     *     // ... data to create a Fornecedor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fornecedor we want to update
     *   }
     * })
     */
    upsert<T extends FornecedorUpsertArgs>(args: SelectSubset<T, FornecedorUpsertArgs<ExtArgs>>): Prisma__FornecedorClient<$Result.GetResult<Prisma.$FornecedorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Fornecedors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FornecedorCountArgs} args - Arguments to filter Fornecedors to count.
     * @example
     * // Count the number of Fornecedors
     * const count = await prisma.fornecedor.count({
     *   where: {
     *     // ... the filter for the Fornecedors we want to count
     *   }
     * })
    **/
    count<T extends FornecedorCountArgs>(
      args?: Subset<T, FornecedorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FornecedorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fornecedor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FornecedorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FornecedorAggregateArgs>(args: Subset<T, FornecedorAggregateArgs>): Prisma.PrismaPromise<GetFornecedorAggregateType<T>>

    /**
     * Group by Fornecedor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FornecedorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FornecedorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FornecedorGroupByArgs['orderBy'] }
        : { orderBy?: FornecedorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FornecedorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFornecedorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Fornecedor model
   */
  readonly fields: FornecedorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Fornecedor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FornecedorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    avaliacoes<T extends Fornecedor$avaliacoesArgs<ExtArgs> = {}>(args?: Subset<T, Fornecedor$avaliacoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dadosBancarios<T extends Fornecedor$dadosBancariosArgs<ExtArgs> = {}>(args?: Subset<T, Fornecedor$dadosBancariosArgs<ExtArgs>>): Prisma__DadosBancariosClient<$Result.GetResult<Prisma.$DadosBancariosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    produtos<T extends Fornecedor$produtosArgs<ExtArgs> = {}>(args?: Subset<T, Fornecedor$produtosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    servicos<T extends Fornecedor$servicosArgs<ExtArgs> = {}>(args?: Subset<T, Fornecedor$servicosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Fornecedor model
   */
  interface FornecedorFieldRefs {
    readonly id: FieldRef<"Fornecedor", 'Int'>
    readonly avaliacaoTotal: FieldRef<"Fornecedor", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Fornecedor findUnique
   */
  export type FornecedorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fornecedor
     */
    select?: FornecedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fornecedor
     */
    omit?: FornecedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FornecedorInclude<ExtArgs> | null
    /**
     * Filter, which Fornecedor to fetch.
     */
    where: FornecedorWhereUniqueInput
  }

  /**
   * Fornecedor findUniqueOrThrow
   */
  export type FornecedorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fornecedor
     */
    select?: FornecedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fornecedor
     */
    omit?: FornecedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FornecedorInclude<ExtArgs> | null
    /**
     * Filter, which Fornecedor to fetch.
     */
    where: FornecedorWhereUniqueInput
  }

  /**
   * Fornecedor findFirst
   */
  export type FornecedorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fornecedor
     */
    select?: FornecedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fornecedor
     */
    omit?: FornecedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FornecedorInclude<ExtArgs> | null
    /**
     * Filter, which Fornecedor to fetch.
     */
    where?: FornecedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fornecedors to fetch.
     */
    orderBy?: FornecedorOrderByWithRelationInput | FornecedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fornecedors.
     */
    cursor?: FornecedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fornecedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fornecedors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fornecedors.
     */
    distinct?: FornecedorScalarFieldEnum | FornecedorScalarFieldEnum[]
  }

  /**
   * Fornecedor findFirstOrThrow
   */
  export type FornecedorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fornecedor
     */
    select?: FornecedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fornecedor
     */
    omit?: FornecedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FornecedorInclude<ExtArgs> | null
    /**
     * Filter, which Fornecedor to fetch.
     */
    where?: FornecedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fornecedors to fetch.
     */
    orderBy?: FornecedorOrderByWithRelationInput | FornecedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fornecedors.
     */
    cursor?: FornecedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fornecedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fornecedors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fornecedors.
     */
    distinct?: FornecedorScalarFieldEnum | FornecedorScalarFieldEnum[]
  }

  /**
   * Fornecedor findMany
   */
  export type FornecedorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fornecedor
     */
    select?: FornecedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fornecedor
     */
    omit?: FornecedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FornecedorInclude<ExtArgs> | null
    /**
     * Filter, which Fornecedors to fetch.
     */
    where?: FornecedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fornecedors to fetch.
     */
    orderBy?: FornecedorOrderByWithRelationInput | FornecedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fornecedors.
     */
    cursor?: FornecedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fornecedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fornecedors.
     */
    skip?: number
    distinct?: FornecedorScalarFieldEnum | FornecedorScalarFieldEnum[]
  }

  /**
   * Fornecedor create
   */
  export type FornecedorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fornecedor
     */
    select?: FornecedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fornecedor
     */
    omit?: FornecedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FornecedorInclude<ExtArgs> | null
    /**
     * The data needed to create a Fornecedor.
     */
    data: XOR<FornecedorCreateInput, FornecedorUncheckedCreateInput>
  }

  /**
   * Fornecedor createMany
   */
  export type FornecedorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Fornecedors.
     */
    data: FornecedorCreateManyInput | FornecedorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Fornecedor createManyAndReturn
   */
  export type FornecedorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fornecedor
     */
    select?: FornecedorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Fornecedor
     */
    omit?: FornecedorOmit<ExtArgs> | null
    /**
     * The data used to create many Fornecedors.
     */
    data: FornecedorCreateManyInput | FornecedorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FornecedorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Fornecedor update
   */
  export type FornecedorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fornecedor
     */
    select?: FornecedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fornecedor
     */
    omit?: FornecedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FornecedorInclude<ExtArgs> | null
    /**
     * The data needed to update a Fornecedor.
     */
    data: XOR<FornecedorUpdateInput, FornecedorUncheckedUpdateInput>
    /**
     * Choose, which Fornecedor to update.
     */
    where: FornecedorWhereUniqueInput
  }

  /**
   * Fornecedor updateMany
   */
  export type FornecedorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Fornecedors.
     */
    data: XOR<FornecedorUpdateManyMutationInput, FornecedorUncheckedUpdateManyInput>
    /**
     * Filter which Fornecedors to update
     */
    where?: FornecedorWhereInput
    /**
     * Limit how many Fornecedors to update.
     */
    limit?: number
  }

  /**
   * Fornecedor updateManyAndReturn
   */
  export type FornecedorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fornecedor
     */
    select?: FornecedorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Fornecedor
     */
    omit?: FornecedorOmit<ExtArgs> | null
    /**
     * The data used to update Fornecedors.
     */
    data: XOR<FornecedorUpdateManyMutationInput, FornecedorUncheckedUpdateManyInput>
    /**
     * Filter which Fornecedors to update
     */
    where?: FornecedorWhereInput
    /**
     * Limit how many Fornecedors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FornecedorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Fornecedor upsert
   */
  export type FornecedorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fornecedor
     */
    select?: FornecedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fornecedor
     */
    omit?: FornecedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FornecedorInclude<ExtArgs> | null
    /**
     * The filter to search for the Fornecedor to update in case it exists.
     */
    where: FornecedorWhereUniqueInput
    /**
     * In case the Fornecedor found by the `where` argument doesn't exist, create a new Fornecedor with this data.
     */
    create: XOR<FornecedorCreateInput, FornecedorUncheckedCreateInput>
    /**
     * In case the Fornecedor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FornecedorUpdateInput, FornecedorUncheckedUpdateInput>
  }

  /**
   * Fornecedor delete
   */
  export type FornecedorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fornecedor
     */
    select?: FornecedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fornecedor
     */
    omit?: FornecedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FornecedorInclude<ExtArgs> | null
    /**
     * Filter which Fornecedor to delete.
     */
    where: FornecedorWhereUniqueInput
  }

  /**
   * Fornecedor deleteMany
   */
  export type FornecedorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fornecedors to delete
     */
    where?: FornecedorWhereInput
    /**
     * Limit how many Fornecedors to delete.
     */
    limit?: number
  }

  /**
   * Fornecedor.avaliacoes
   */
  export type Fornecedor$avaliacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avaliacao
     */
    omit?: AvaliacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    where?: AvaliacaoWhereInput
    orderBy?: AvaliacaoOrderByWithRelationInput | AvaliacaoOrderByWithRelationInput[]
    cursor?: AvaliacaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AvaliacaoScalarFieldEnum | AvaliacaoScalarFieldEnum[]
  }

  /**
   * Fornecedor.dadosBancarios
   */
  export type Fornecedor$dadosBancariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DadosBancarios
     */
    select?: DadosBancariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DadosBancarios
     */
    omit?: DadosBancariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DadosBancariosInclude<ExtArgs> | null
    where?: DadosBancariosWhereInput
  }

  /**
   * Fornecedor.produtos
   */
  export type Fornecedor$produtosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produto
     */
    omit?: ProdutoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdutoInclude<ExtArgs> | null
    where?: ProdutoWhereInput
    orderBy?: ProdutoOrderByWithRelationInput | ProdutoOrderByWithRelationInput[]
    cursor?: ProdutoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProdutoScalarFieldEnum | ProdutoScalarFieldEnum[]
  }

  /**
   * Fornecedor.servicos
   */
  export type Fornecedor$servicosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servico
     */
    select?: ServicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Servico
     */
    omit?: ServicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicoInclude<ExtArgs> | null
    where?: ServicoWhereInput
    orderBy?: ServicoOrderByWithRelationInput | ServicoOrderByWithRelationInput[]
    cursor?: ServicoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicoScalarFieldEnum | ServicoScalarFieldEnum[]
  }

  /**
   * Fornecedor without action
   */
  export type FornecedorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fornecedor
     */
    select?: FornecedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fornecedor
     */
    omit?: FornecedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FornecedorInclude<ExtArgs> | null
  }


  /**
   * Model DadosBancarios
   */

  export type AggregateDadosBancarios = {
    _count: DadosBancariosCountAggregateOutputType | null
    _avg: DadosBancariosAvgAggregateOutputType | null
    _sum: DadosBancariosSumAggregateOutputType | null
    _min: DadosBancariosMinAggregateOutputType | null
    _max: DadosBancariosMaxAggregateOutputType | null
  }

  export type DadosBancariosAvgAggregateOutputType = {
    id: number | null
    fornecedorId: number | null
  }

  export type DadosBancariosSumAggregateOutputType = {
    id: number | null
    fornecedorId: number | null
  }

  export type DadosBancariosMinAggregateOutputType = {
    id: number | null
    idBanco: string | null
    numAgencia: string | null
    tipoConta: string | null
    fornecedorId: number | null
  }

  export type DadosBancariosMaxAggregateOutputType = {
    id: number | null
    idBanco: string | null
    numAgencia: string | null
    tipoConta: string | null
    fornecedorId: number | null
  }

  export type DadosBancariosCountAggregateOutputType = {
    id: number
    idBanco: number
    numAgencia: number
    tipoConta: number
    fornecedorId: number
    _all: number
  }


  export type DadosBancariosAvgAggregateInputType = {
    id?: true
    fornecedorId?: true
  }

  export type DadosBancariosSumAggregateInputType = {
    id?: true
    fornecedorId?: true
  }

  export type DadosBancariosMinAggregateInputType = {
    id?: true
    idBanco?: true
    numAgencia?: true
    tipoConta?: true
    fornecedorId?: true
  }

  export type DadosBancariosMaxAggregateInputType = {
    id?: true
    idBanco?: true
    numAgencia?: true
    tipoConta?: true
    fornecedorId?: true
  }

  export type DadosBancariosCountAggregateInputType = {
    id?: true
    idBanco?: true
    numAgencia?: true
    tipoConta?: true
    fornecedorId?: true
    _all?: true
  }

  export type DadosBancariosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DadosBancarios to aggregate.
     */
    where?: DadosBancariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DadosBancarios to fetch.
     */
    orderBy?: DadosBancariosOrderByWithRelationInput | DadosBancariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DadosBancariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DadosBancarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DadosBancarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DadosBancarios
    **/
    _count?: true | DadosBancariosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DadosBancariosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DadosBancariosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DadosBancariosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DadosBancariosMaxAggregateInputType
  }

  export type GetDadosBancariosAggregateType<T extends DadosBancariosAggregateArgs> = {
        [P in keyof T & keyof AggregateDadosBancarios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDadosBancarios[P]>
      : GetScalarType<T[P], AggregateDadosBancarios[P]>
  }




  export type DadosBancariosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DadosBancariosWhereInput
    orderBy?: DadosBancariosOrderByWithAggregationInput | DadosBancariosOrderByWithAggregationInput[]
    by: DadosBancariosScalarFieldEnum[] | DadosBancariosScalarFieldEnum
    having?: DadosBancariosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DadosBancariosCountAggregateInputType | true
    _avg?: DadosBancariosAvgAggregateInputType
    _sum?: DadosBancariosSumAggregateInputType
    _min?: DadosBancariosMinAggregateInputType
    _max?: DadosBancariosMaxAggregateInputType
  }

  export type DadosBancariosGroupByOutputType = {
    id: number
    idBanco: string
    numAgencia: string
    tipoConta: string
    fornecedorId: number
    _count: DadosBancariosCountAggregateOutputType | null
    _avg: DadosBancariosAvgAggregateOutputType | null
    _sum: DadosBancariosSumAggregateOutputType | null
    _min: DadosBancariosMinAggregateOutputType | null
    _max: DadosBancariosMaxAggregateOutputType | null
  }

  type GetDadosBancariosGroupByPayload<T extends DadosBancariosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DadosBancariosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DadosBancariosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DadosBancariosGroupByOutputType[P]>
            : GetScalarType<T[P], DadosBancariosGroupByOutputType[P]>
        }
      >
    >


  export type DadosBancariosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idBanco?: boolean
    numAgencia?: boolean
    tipoConta?: boolean
    fornecedorId?: boolean
    fornecedor?: boolean | FornecedorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dadosBancarios"]>

  export type DadosBancariosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idBanco?: boolean
    numAgencia?: boolean
    tipoConta?: boolean
    fornecedorId?: boolean
    fornecedor?: boolean | FornecedorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dadosBancarios"]>

  export type DadosBancariosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idBanco?: boolean
    numAgencia?: boolean
    tipoConta?: boolean
    fornecedorId?: boolean
    fornecedor?: boolean | FornecedorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dadosBancarios"]>

  export type DadosBancariosSelectScalar = {
    id?: boolean
    idBanco?: boolean
    numAgencia?: boolean
    tipoConta?: boolean
    fornecedorId?: boolean
  }

  export type DadosBancariosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "idBanco" | "numAgencia" | "tipoConta" | "fornecedorId", ExtArgs["result"]["dadosBancarios"]>
  export type DadosBancariosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fornecedor?: boolean | FornecedorDefaultArgs<ExtArgs>
  }
  export type DadosBancariosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fornecedor?: boolean | FornecedorDefaultArgs<ExtArgs>
  }
  export type DadosBancariosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fornecedor?: boolean | FornecedorDefaultArgs<ExtArgs>
  }

  export type $DadosBancariosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DadosBancarios"
    objects: {
      fornecedor: Prisma.$FornecedorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idBanco: string
      numAgencia: string
      tipoConta: string
      fornecedorId: number
    }, ExtArgs["result"]["dadosBancarios"]>
    composites: {}
  }

  type DadosBancariosGetPayload<S extends boolean | null | undefined | DadosBancariosDefaultArgs> = $Result.GetResult<Prisma.$DadosBancariosPayload, S>

  type DadosBancariosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DadosBancariosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DadosBancariosCountAggregateInputType | true
    }

  export interface DadosBancariosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DadosBancarios'], meta: { name: 'DadosBancarios' } }
    /**
     * Find zero or one DadosBancarios that matches the filter.
     * @param {DadosBancariosFindUniqueArgs} args - Arguments to find a DadosBancarios
     * @example
     * // Get one DadosBancarios
     * const dadosBancarios = await prisma.dadosBancarios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DadosBancariosFindUniqueArgs>(args: SelectSubset<T, DadosBancariosFindUniqueArgs<ExtArgs>>): Prisma__DadosBancariosClient<$Result.GetResult<Prisma.$DadosBancariosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DadosBancarios that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DadosBancariosFindUniqueOrThrowArgs} args - Arguments to find a DadosBancarios
     * @example
     * // Get one DadosBancarios
     * const dadosBancarios = await prisma.dadosBancarios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DadosBancariosFindUniqueOrThrowArgs>(args: SelectSubset<T, DadosBancariosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DadosBancariosClient<$Result.GetResult<Prisma.$DadosBancariosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DadosBancarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DadosBancariosFindFirstArgs} args - Arguments to find a DadosBancarios
     * @example
     * // Get one DadosBancarios
     * const dadosBancarios = await prisma.dadosBancarios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DadosBancariosFindFirstArgs>(args?: SelectSubset<T, DadosBancariosFindFirstArgs<ExtArgs>>): Prisma__DadosBancariosClient<$Result.GetResult<Prisma.$DadosBancariosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DadosBancarios that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DadosBancariosFindFirstOrThrowArgs} args - Arguments to find a DadosBancarios
     * @example
     * // Get one DadosBancarios
     * const dadosBancarios = await prisma.dadosBancarios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DadosBancariosFindFirstOrThrowArgs>(args?: SelectSubset<T, DadosBancariosFindFirstOrThrowArgs<ExtArgs>>): Prisma__DadosBancariosClient<$Result.GetResult<Prisma.$DadosBancariosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DadosBancarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DadosBancariosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DadosBancarios
     * const dadosBancarios = await prisma.dadosBancarios.findMany()
     * 
     * // Get first 10 DadosBancarios
     * const dadosBancarios = await prisma.dadosBancarios.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dadosBancariosWithIdOnly = await prisma.dadosBancarios.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DadosBancariosFindManyArgs>(args?: SelectSubset<T, DadosBancariosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DadosBancariosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DadosBancarios.
     * @param {DadosBancariosCreateArgs} args - Arguments to create a DadosBancarios.
     * @example
     * // Create one DadosBancarios
     * const DadosBancarios = await prisma.dadosBancarios.create({
     *   data: {
     *     // ... data to create a DadosBancarios
     *   }
     * })
     * 
     */
    create<T extends DadosBancariosCreateArgs>(args: SelectSubset<T, DadosBancariosCreateArgs<ExtArgs>>): Prisma__DadosBancariosClient<$Result.GetResult<Prisma.$DadosBancariosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DadosBancarios.
     * @param {DadosBancariosCreateManyArgs} args - Arguments to create many DadosBancarios.
     * @example
     * // Create many DadosBancarios
     * const dadosBancarios = await prisma.dadosBancarios.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DadosBancariosCreateManyArgs>(args?: SelectSubset<T, DadosBancariosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DadosBancarios and returns the data saved in the database.
     * @param {DadosBancariosCreateManyAndReturnArgs} args - Arguments to create many DadosBancarios.
     * @example
     * // Create many DadosBancarios
     * const dadosBancarios = await prisma.dadosBancarios.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DadosBancarios and only return the `id`
     * const dadosBancariosWithIdOnly = await prisma.dadosBancarios.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DadosBancariosCreateManyAndReturnArgs>(args?: SelectSubset<T, DadosBancariosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DadosBancariosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DadosBancarios.
     * @param {DadosBancariosDeleteArgs} args - Arguments to delete one DadosBancarios.
     * @example
     * // Delete one DadosBancarios
     * const DadosBancarios = await prisma.dadosBancarios.delete({
     *   where: {
     *     // ... filter to delete one DadosBancarios
     *   }
     * })
     * 
     */
    delete<T extends DadosBancariosDeleteArgs>(args: SelectSubset<T, DadosBancariosDeleteArgs<ExtArgs>>): Prisma__DadosBancariosClient<$Result.GetResult<Prisma.$DadosBancariosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DadosBancarios.
     * @param {DadosBancariosUpdateArgs} args - Arguments to update one DadosBancarios.
     * @example
     * // Update one DadosBancarios
     * const dadosBancarios = await prisma.dadosBancarios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DadosBancariosUpdateArgs>(args: SelectSubset<T, DadosBancariosUpdateArgs<ExtArgs>>): Prisma__DadosBancariosClient<$Result.GetResult<Prisma.$DadosBancariosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DadosBancarios.
     * @param {DadosBancariosDeleteManyArgs} args - Arguments to filter DadosBancarios to delete.
     * @example
     * // Delete a few DadosBancarios
     * const { count } = await prisma.dadosBancarios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DadosBancariosDeleteManyArgs>(args?: SelectSubset<T, DadosBancariosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DadosBancarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DadosBancariosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DadosBancarios
     * const dadosBancarios = await prisma.dadosBancarios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DadosBancariosUpdateManyArgs>(args: SelectSubset<T, DadosBancariosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DadosBancarios and returns the data updated in the database.
     * @param {DadosBancariosUpdateManyAndReturnArgs} args - Arguments to update many DadosBancarios.
     * @example
     * // Update many DadosBancarios
     * const dadosBancarios = await prisma.dadosBancarios.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DadosBancarios and only return the `id`
     * const dadosBancariosWithIdOnly = await prisma.dadosBancarios.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DadosBancariosUpdateManyAndReturnArgs>(args: SelectSubset<T, DadosBancariosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DadosBancariosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DadosBancarios.
     * @param {DadosBancariosUpsertArgs} args - Arguments to update or create a DadosBancarios.
     * @example
     * // Update or create a DadosBancarios
     * const dadosBancarios = await prisma.dadosBancarios.upsert({
     *   create: {
     *     // ... data to create a DadosBancarios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DadosBancarios we want to update
     *   }
     * })
     */
    upsert<T extends DadosBancariosUpsertArgs>(args: SelectSubset<T, DadosBancariosUpsertArgs<ExtArgs>>): Prisma__DadosBancariosClient<$Result.GetResult<Prisma.$DadosBancariosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DadosBancarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DadosBancariosCountArgs} args - Arguments to filter DadosBancarios to count.
     * @example
     * // Count the number of DadosBancarios
     * const count = await prisma.dadosBancarios.count({
     *   where: {
     *     // ... the filter for the DadosBancarios we want to count
     *   }
     * })
    **/
    count<T extends DadosBancariosCountArgs>(
      args?: Subset<T, DadosBancariosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DadosBancariosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DadosBancarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DadosBancariosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DadosBancariosAggregateArgs>(args: Subset<T, DadosBancariosAggregateArgs>): Prisma.PrismaPromise<GetDadosBancariosAggregateType<T>>

    /**
     * Group by DadosBancarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DadosBancariosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DadosBancariosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DadosBancariosGroupByArgs['orderBy'] }
        : { orderBy?: DadosBancariosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DadosBancariosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDadosBancariosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DadosBancarios model
   */
  readonly fields: DadosBancariosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DadosBancarios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DadosBancariosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fornecedor<T extends FornecedorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FornecedorDefaultArgs<ExtArgs>>): Prisma__FornecedorClient<$Result.GetResult<Prisma.$FornecedorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DadosBancarios model
   */
  interface DadosBancariosFieldRefs {
    readonly id: FieldRef<"DadosBancarios", 'Int'>
    readonly idBanco: FieldRef<"DadosBancarios", 'String'>
    readonly numAgencia: FieldRef<"DadosBancarios", 'String'>
    readonly tipoConta: FieldRef<"DadosBancarios", 'String'>
    readonly fornecedorId: FieldRef<"DadosBancarios", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DadosBancarios findUnique
   */
  export type DadosBancariosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DadosBancarios
     */
    select?: DadosBancariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DadosBancarios
     */
    omit?: DadosBancariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DadosBancariosInclude<ExtArgs> | null
    /**
     * Filter, which DadosBancarios to fetch.
     */
    where: DadosBancariosWhereUniqueInput
  }

  /**
   * DadosBancarios findUniqueOrThrow
   */
  export type DadosBancariosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DadosBancarios
     */
    select?: DadosBancariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DadosBancarios
     */
    omit?: DadosBancariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DadosBancariosInclude<ExtArgs> | null
    /**
     * Filter, which DadosBancarios to fetch.
     */
    where: DadosBancariosWhereUniqueInput
  }

  /**
   * DadosBancarios findFirst
   */
  export type DadosBancariosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DadosBancarios
     */
    select?: DadosBancariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DadosBancarios
     */
    omit?: DadosBancariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DadosBancariosInclude<ExtArgs> | null
    /**
     * Filter, which DadosBancarios to fetch.
     */
    where?: DadosBancariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DadosBancarios to fetch.
     */
    orderBy?: DadosBancariosOrderByWithRelationInput | DadosBancariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DadosBancarios.
     */
    cursor?: DadosBancariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DadosBancarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DadosBancarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DadosBancarios.
     */
    distinct?: DadosBancariosScalarFieldEnum | DadosBancariosScalarFieldEnum[]
  }

  /**
   * DadosBancarios findFirstOrThrow
   */
  export type DadosBancariosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DadosBancarios
     */
    select?: DadosBancariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DadosBancarios
     */
    omit?: DadosBancariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DadosBancariosInclude<ExtArgs> | null
    /**
     * Filter, which DadosBancarios to fetch.
     */
    where?: DadosBancariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DadosBancarios to fetch.
     */
    orderBy?: DadosBancariosOrderByWithRelationInput | DadosBancariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DadosBancarios.
     */
    cursor?: DadosBancariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DadosBancarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DadosBancarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DadosBancarios.
     */
    distinct?: DadosBancariosScalarFieldEnum | DadosBancariosScalarFieldEnum[]
  }

  /**
   * DadosBancarios findMany
   */
  export type DadosBancariosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DadosBancarios
     */
    select?: DadosBancariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DadosBancarios
     */
    omit?: DadosBancariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DadosBancariosInclude<ExtArgs> | null
    /**
     * Filter, which DadosBancarios to fetch.
     */
    where?: DadosBancariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DadosBancarios to fetch.
     */
    orderBy?: DadosBancariosOrderByWithRelationInput | DadosBancariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DadosBancarios.
     */
    cursor?: DadosBancariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DadosBancarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DadosBancarios.
     */
    skip?: number
    distinct?: DadosBancariosScalarFieldEnum | DadosBancariosScalarFieldEnum[]
  }

  /**
   * DadosBancarios create
   */
  export type DadosBancariosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DadosBancarios
     */
    select?: DadosBancariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DadosBancarios
     */
    omit?: DadosBancariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DadosBancariosInclude<ExtArgs> | null
    /**
     * The data needed to create a DadosBancarios.
     */
    data: XOR<DadosBancariosCreateInput, DadosBancariosUncheckedCreateInput>
  }

  /**
   * DadosBancarios createMany
   */
  export type DadosBancariosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DadosBancarios.
     */
    data: DadosBancariosCreateManyInput | DadosBancariosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DadosBancarios createManyAndReturn
   */
  export type DadosBancariosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DadosBancarios
     */
    select?: DadosBancariosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DadosBancarios
     */
    omit?: DadosBancariosOmit<ExtArgs> | null
    /**
     * The data used to create many DadosBancarios.
     */
    data: DadosBancariosCreateManyInput | DadosBancariosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DadosBancariosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DadosBancarios update
   */
  export type DadosBancariosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DadosBancarios
     */
    select?: DadosBancariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DadosBancarios
     */
    omit?: DadosBancariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DadosBancariosInclude<ExtArgs> | null
    /**
     * The data needed to update a DadosBancarios.
     */
    data: XOR<DadosBancariosUpdateInput, DadosBancariosUncheckedUpdateInput>
    /**
     * Choose, which DadosBancarios to update.
     */
    where: DadosBancariosWhereUniqueInput
  }

  /**
   * DadosBancarios updateMany
   */
  export type DadosBancariosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DadosBancarios.
     */
    data: XOR<DadosBancariosUpdateManyMutationInput, DadosBancariosUncheckedUpdateManyInput>
    /**
     * Filter which DadosBancarios to update
     */
    where?: DadosBancariosWhereInput
    /**
     * Limit how many DadosBancarios to update.
     */
    limit?: number
  }

  /**
   * DadosBancarios updateManyAndReturn
   */
  export type DadosBancariosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DadosBancarios
     */
    select?: DadosBancariosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DadosBancarios
     */
    omit?: DadosBancariosOmit<ExtArgs> | null
    /**
     * The data used to update DadosBancarios.
     */
    data: XOR<DadosBancariosUpdateManyMutationInput, DadosBancariosUncheckedUpdateManyInput>
    /**
     * Filter which DadosBancarios to update
     */
    where?: DadosBancariosWhereInput
    /**
     * Limit how many DadosBancarios to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DadosBancariosIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DadosBancarios upsert
   */
  export type DadosBancariosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DadosBancarios
     */
    select?: DadosBancariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DadosBancarios
     */
    omit?: DadosBancariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DadosBancariosInclude<ExtArgs> | null
    /**
     * The filter to search for the DadosBancarios to update in case it exists.
     */
    where: DadosBancariosWhereUniqueInput
    /**
     * In case the DadosBancarios found by the `where` argument doesn't exist, create a new DadosBancarios with this data.
     */
    create: XOR<DadosBancariosCreateInput, DadosBancariosUncheckedCreateInput>
    /**
     * In case the DadosBancarios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DadosBancariosUpdateInput, DadosBancariosUncheckedUpdateInput>
  }

  /**
   * DadosBancarios delete
   */
  export type DadosBancariosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DadosBancarios
     */
    select?: DadosBancariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DadosBancarios
     */
    omit?: DadosBancariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DadosBancariosInclude<ExtArgs> | null
    /**
     * Filter which DadosBancarios to delete.
     */
    where: DadosBancariosWhereUniqueInput
  }

  /**
   * DadosBancarios deleteMany
   */
  export type DadosBancariosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DadosBancarios to delete
     */
    where?: DadosBancariosWhereInput
    /**
     * Limit how many DadosBancarios to delete.
     */
    limit?: number
  }

  /**
   * DadosBancarios without action
   */
  export type DadosBancariosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DadosBancarios
     */
    select?: DadosBancariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DadosBancarios
     */
    omit?: DadosBancariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DadosBancariosInclude<ExtArgs> | null
  }


  /**
   * Model Cupom
   */

  export type AggregateCupom = {
    _count: CupomCountAggregateOutputType | null
    _avg: CupomAvgAggregateOutputType | null
    _sum: CupomSumAggregateOutputType | null
    _min: CupomMinAggregateOutputType | null
    _max: CupomMaxAggregateOutputType | null
  }

  export type CupomAvgAggregateOutputType = {
    id: number | null
    desconto: number | null
    clienteId: number | null
  }

  export type CupomSumAggregateOutputType = {
    id: number | null
    desconto: number | null
    clienteId: number | null
  }

  export type CupomMinAggregateOutputType = {
    id: number | null
    nome: string | null
    dataValidade: Date | null
    desconto: number | null
    clienteId: number | null
  }

  export type CupomMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    dataValidade: Date | null
    desconto: number | null
    clienteId: number | null
  }

  export type CupomCountAggregateOutputType = {
    id: number
    nome: number
    dataValidade: number
    desconto: number
    clienteId: number
    _all: number
  }


  export type CupomAvgAggregateInputType = {
    id?: true
    desconto?: true
    clienteId?: true
  }

  export type CupomSumAggregateInputType = {
    id?: true
    desconto?: true
    clienteId?: true
  }

  export type CupomMinAggregateInputType = {
    id?: true
    nome?: true
    dataValidade?: true
    desconto?: true
    clienteId?: true
  }

  export type CupomMaxAggregateInputType = {
    id?: true
    nome?: true
    dataValidade?: true
    desconto?: true
    clienteId?: true
  }

  export type CupomCountAggregateInputType = {
    id?: true
    nome?: true
    dataValidade?: true
    desconto?: true
    clienteId?: true
    _all?: true
  }

  export type CupomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cupom to aggregate.
     */
    where?: CupomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cupoms to fetch.
     */
    orderBy?: CupomOrderByWithRelationInput | CupomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CupomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cupoms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cupoms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cupoms
    **/
    _count?: true | CupomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CupomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CupomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CupomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CupomMaxAggregateInputType
  }

  export type GetCupomAggregateType<T extends CupomAggregateArgs> = {
        [P in keyof T & keyof AggregateCupom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCupom[P]>
      : GetScalarType<T[P], AggregateCupom[P]>
  }




  export type CupomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CupomWhereInput
    orderBy?: CupomOrderByWithAggregationInput | CupomOrderByWithAggregationInput[]
    by: CupomScalarFieldEnum[] | CupomScalarFieldEnum
    having?: CupomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CupomCountAggregateInputType | true
    _avg?: CupomAvgAggregateInputType
    _sum?: CupomSumAggregateInputType
    _min?: CupomMinAggregateInputType
    _max?: CupomMaxAggregateInputType
  }

  export type CupomGroupByOutputType = {
    id: number
    nome: string
    dataValidade: Date
    desconto: number
    clienteId: number
    _count: CupomCountAggregateOutputType | null
    _avg: CupomAvgAggregateOutputType | null
    _sum: CupomSumAggregateOutputType | null
    _min: CupomMinAggregateOutputType | null
    _max: CupomMaxAggregateOutputType | null
  }

  type GetCupomGroupByPayload<T extends CupomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CupomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CupomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CupomGroupByOutputType[P]>
            : GetScalarType<T[P], CupomGroupByOutputType[P]>
        }
      >
    >


  export type CupomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    dataValidade?: boolean
    desconto?: boolean
    clienteId?: boolean
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cupom"]>

  export type CupomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    dataValidade?: boolean
    desconto?: boolean
    clienteId?: boolean
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cupom"]>

  export type CupomSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    dataValidade?: boolean
    desconto?: boolean
    clienteId?: boolean
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cupom"]>

  export type CupomSelectScalar = {
    id?: boolean
    nome?: boolean
    dataValidade?: boolean
    desconto?: boolean
    clienteId?: boolean
  }

  export type CupomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "dataValidade" | "desconto" | "clienteId", ExtArgs["result"]["cupom"]>
  export type CupomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }
  export type CupomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }
  export type CupomIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }

  export type $CupomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cupom"
    objects: {
      cliente: Prisma.$ClientePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      dataValidade: Date
      desconto: number
      clienteId: number
    }, ExtArgs["result"]["cupom"]>
    composites: {}
  }

  type CupomGetPayload<S extends boolean | null | undefined | CupomDefaultArgs> = $Result.GetResult<Prisma.$CupomPayload, S>

  type CupomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CupomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CupomCountAggregateInputType | true
    }

  export interface CupomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cupom'], meta: { name: 'Cupom' } }
    /**
     * Find zero or one Cupom that matches the filter.
     * @param {CupomFindUniqueArgs} args - Arguments to find a Cupom
     * @example
     * // Get one Cupom
     * const cupom = await prisma.cupom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CupomFindUniqueArgs>(args: SelectSubset<T, CupomFindUniqueArgs<ExtArgs>>): Prisma__CupomClient<$Result.GetResult<Prisma.$CupomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cupom that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CupomFindUniqueOrThrowArgs} args - Arguments to find a Cupom
     * @example
     * // Get one Cupom
     * const cupom = await prisma.cupom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CupomFindUniqueOrThrowArgs>(args: SelectSubset<T, CupomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CupomClient<$Result.GetResult<Prisma.$CupomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cupom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CupomFindFirstArgs} args - Arguments to find a Cupom
     * @example
     * // Get one Cupom
     * const cupom = await prisma.cupom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CupomFindFirstArgs>(args?: SelectSubset<T, CupomFindFirstArgs<ExtArgs>>): Prisma__CupomClient<$Result.GetResult<Prisma.$CupomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cupom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CupomFindFirstOrThrowArgs} args - Arguments to find a Cupom
     * @example
     * // Get one Cupom
     * const cupom = await prisma.cupom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CupomFindFirstOrThrowArgs>(args?: SelectSubset<T, CupomFindFirstOrThrowArgs<ExtArgs>>): Prisma__CupomClient<$Result.GetResult<Prisma.$CupomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cupoms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CupomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cupoms
     * const cupoms = await prisma.cupom.findMany()
     * 
     * // Get first 10 Cupoms
     * const cupoms = await prisma.cupom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cupomWithIdOnly = await prisma.cupom.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CupomFindManyArgs>(args?: SelectSubset<T, CupomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CupomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cupom.
     * @param {CupomCreateArgs} args - Arguments to create a Cupom.
     * @example
     * // Create one Cupom
     * const Cupom = await prisma.cupom.create({
     *   data: {
     *     // ... data to create a Cupom
     *   }
     * })
     * 
     */
    create<T extends CupomCreateArgs>(args: SelectSubset<T, CupomCreateArgs<ExtArgs>>): Prisma__CupomClient<$Result.GetResult<Prisma.$CupomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cupoms.
     * @param {CupomCreateManyArgs} args - Arguments to create many Cupoms.
     * @example
     * // Create many Cupoms
     * const cupom = await prisma.cupom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CupomCreateManyArgs>(args?: SelectSubset<T, CupomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cupoms and returns the data saved in the database.
     * @param {CupomCreateManyAndReturnArgs} args - Arguments to create many Cupoms.
     * @example
     * // Create many Cupoms
     * const cupom = await prisma.cupom.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cupoms and only return the `id`
     * const cupomWithIdOnly = await prisma.cupom.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CupomCreateManyAndReturnArgs>(args?: SelectSubset<T, CupomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CupomPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cupom.
     * @param {CupomDeleteArgs} args - Arguments to delete one Cupom.
     * @example
     * // Delete one Cupom
     * const Cupom = await prisma.cupom.delete({
     *   where: {
     *     // ... filter to delete one Cupom
     *   }
     * })
     * 
     */
    delete<T extends CupomDeleteArgs>(args: SelectSubset<T, CupomDeleteArgs<ExtArgs>>): Prisma__CupomClient<$Result.GetResult<Prisma.$CupomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cupom.
     * @param {CupomUpdateArgs} args - Arguments to update one Cupom.
     * @example
     * // Update one Cupom
     * const cupom = await prisma.cupom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CupomUpdateArgs>(args: SelectSubset<T, CupomUpdateArgs<ExtArgs>>): Prisma__CupomClient<$Result.GetResult<Prisma.$CupomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cupoms.
     * @param {CupomDeleteManyArgs} args - Arguments to filter Cupoms to delete.
     * @example
     * // Delete a few Cupoms
     * const { count } = await prisma.cupom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CupomDeleteManyArgs>(args?: SelectSubset<T, CupomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cupoms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CupomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cupoms
     * const cupom = await prisma.cupom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CupomUpdateManyArgs>(args: SelectSubset<T, CupomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cupoms and returns the data updated in the database.
     * @param {CupomUpdateManyAndReturnArgs} args - Arguments to update many Cupoms.
     * @example
     * // Update many Cupoms
     * const cupom = await prisma.cupom.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cupoms and only return the `id`
     * const cupomWithIdOnly = await prisma.cupom.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CupomUpdateManyAndReturnArgs>(args: SelectSubset<T, CupomUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CupomPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cupom.
     * @param {CupomUpsertArgs} args - Arguments to update or create a Cupom.
     * @example
     * // Update or create a Cupom
     * const cupom = await prisma.cupom.upsert({
     *   create: {
     *     // ... data to create a Cupom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cupom we want to update
     *   }
     * })
     */
    upsert<T extends CupomUpsertArgs>(args: SelectSubset<T, CupomUpsertArgs<ExtArgs>>): Prisma__CupomClient<$Result.GetResult<Prisma.$CupomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cupoms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CupomCountArgs} args - Arguments to filter Cupoms to count.
     * @example
     * // Count the number of Cupoms
     * const count = await prisma.cupom.count({
     *   where: {
     *     // ... the filter for the Cupoms we want to count
     *   }
     * })
    **/
    count<T extends CupomCountArgs>(
      args?: Subset<T, CupomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CupomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cupom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CupomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CupomAggregateArgs>(args: Subset<T, CupomAggregateArgs>): Prisma.PrismaPromise<GetCupomAggregateType<T>>

    /**
     * Group by Cupom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CupomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CupomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CupomGroupByArgs['orderBy'] }
        : { orderBy?: CupomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CupomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCupomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cupom model
   */
  readonly fields: CupomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cupom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CupomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cliente<T extends ClienteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClienteDefaultArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cupom model
   */
  interface CupomFieldRefs {
    readonly id: FieldRef<"Cupom", 'Int'>
    readonly nome: FieldRef<"Cupom", 'String'>
    readonly dataValidade: FieldRef<"Cupom", 'DateTime'>
    readonly desconto: FieldRef<"Cupom", 'Float'>
    readonly clienteId: FieldRef<"Cupom", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Cupom findUnique
   */
  export type CupomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cupom
     */
    select?: CupomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cupom
     */
    omit?: CupomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CupomInclude<ExtArgs> | null
    /**
     * Filter, which Cupom to fetch.
     */
    where: CupomWhereUniqueInput
  }

  /**
   * Cupom findUniqueOrThrow
   */
  export type CupomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cupom
     */
    select?: CupomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cupom
     */
    omit?: CupomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CupomInclude<ExtArgs> | null
    /**
     * Filter, which Cupom to fetch.
     */
    where: CupomWhereUniqueInput
  }

  /**
   * Cupom findFirst
   */
  export type CupomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cupom
     */
    select?: CupomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cupom
     */
    omit?: CupomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CupomInclude<ExtArgs> | null
    /**
     * Filter, which Cupom to fetch.
     */
    where?: CupomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cupoms to fetch.
     */
    orderBy?: CupomOrderByWithRelationInput | CupomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cupoms.
     */
    cursor?: CupomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cupoms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cupoms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cupoms.
     */
    distinct?: CupomScalarFieldEnum | CupomScalarFieldEnum[]
  }

  /**
   * Cupom findFirstOrThrow
   */
  export type CupomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cupom
     */
    select?: CupomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cupom
     */
    omit?: CupomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CupomInclude<ExtArgs> | null
    /**
     * Filter, which Cupom to fetch.
     */
    where?: CupomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cupoms to fetch.
     */
    orderBy?: CupomOrderByWithRelationInput | CupomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cupoms.
     */
    cursor?: CupomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cupoms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cupoms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cupoms.
     */
    distinct?: CupomScalarFieldEnum | CupomScalarFieldEnum[]
  }

  /**
   * Cupom findMany
   */
  export type CupomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cupom
     */
    select?: CupomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cupom
     */
    omit?: CupomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CupomInclude<ExtArgs> | null
    /**
     * Filter, which Cupoms to fetch.
     */
    where?: CupomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cupoms to fetch.
     */
    orderBy?: CupomOrderByWithRelationInput | CupomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cupoms.
     */
    cursor?: CupomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cupoms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cupoms.
     */
    skip?: number
    distinct?: CupomScalarFieldEnum | CupomScalarFieldEnum[]
  }

  /**
   * Cupom create
   */
  export type CupomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cupom
     */
    select?: CupomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cupom
     */
    omit?: CupomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CupomInclude<ExtArgs> | null
    /**
     * The data needed to create a Cupom.
     */
    data: XOR<CupomCreateInput, CupomUncheckedCreateInput>
  }

  /**
   * Cupom createMany
   */
  export type CupomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cupoms.
     */
    data: CupomCreateManyInput | CupomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cupom createManyAndReturn
   */
  export type CupomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cupom
     */
    select?: CupomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cupom
     */
    omit?: CupomOmit<ExtArgs> | null
    /**
     * The data used to create many Cupoms.
     */
    data: CupomCreateManyInput | CupomCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CupomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cupom update
   */
  export type CupomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cupom
     */
    select?: CupomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cupom
     */
    omit?: CupomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CupomInclude<ExtArgs> | null
    /**
     * The data needed to update a Cupom.
     */
    data: XOR<CupomUpdateInput, CupomUncheckedUpdateInput>
    /**
     * Choose, which Cupom to update.
     */
    where: CupomWhereUniqueInput
  }

  /**
   * Cupom updateMany
   */
  export type CupomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cupoms.
     */
    data: XOR<CupomUpdateManyMutationInput, CupomUncheckedUpdateManyInput>
    /**
     * Filter which Cupoms to update
     */
    where?: CupomWhereInput
    /**
     * Limit how many Cupoms to update.
     */
    limit?: number
  }

  /**
   * Cupom updateManyAndReturn
   */
  export type CupomUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cupom
     */
    select?: CupomSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cupom
     */
    omit?: CupomOmit<ExtArgs> | null
    /**
     * The data used to update Cupoms.
     */
    data: XOR<CupomUpdateManyMutationInput, CupomUncheckedUpdateManyInput>
    /**
     * Filter which Cupoms to update
     */
    where?: CupomWhereInput
    /**
     * Limit how many Cupoms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CupomIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cupom upsert
   */
  export type CupomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cupom
     */
    select?: CupomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cupom
     */
    omit?: CupomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CupomInclude<ExtArgs> | null
    /**
     * The filter to search for the Cupom to update in case it exists.
     */
    where: CupomWhereUniqueInput
    /**
     * In case the Cupom found by the `where` argument doesn't exist, create a new Cupom with this data.
     */
    create: XOR<CupomCreateInput, CupomUncheckedCreateInput>
    /**
     * In case the Cupom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CupomUpdateInput, CupomUncheckedUpdateInput>
  }

  /**
   * Cupom delete
   */
  export type CupomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cupom
     */
    select?: CupomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cupom
     */
    omit?: CupomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CupomInclude<ExtArgs> | null
    /**
     * Filter which Cupom to delete.
     */
    where: CupomWhereUniqueInput
  }

  /**
   * Cupom deleteMany
   */
  export type CupomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cupoms to delete
     */
    where?: CupomWhereInput
    /**
     * Limit how many Cupoms to delete.
     */
    limit?: number
  }

  /**
   * Cupom without action
   */
  export type CupomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cupom
     */
    select?: CupomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cupom
     */
    omit?: CupomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CupomInclude<ExtArgs> | null
  }


  /**
   * Model CarrinhoCompras
   */

  export type AggregateCarrinhoCompras = {
    _count: CarrinhoComprasCountAggregateOutputType | null
    _avg: CarrinhoComprasAvgAggregateOutputType | null
    _sum: CarrinhoComprasSumAggregateOutputType | null
    _min: CarrinhoComprasMinAggregateOutputType | null
    _max: CarrinhoComprasMaxAggregateOutputType | null
  }

  export type CarrinhoComprasAvgAggregateOutputType = {
    id: number | null
    clienteId: number | null
  }

  export type CarrinhoComprasSumAggregateOutputType = {
    id: number | null
    clienteId: number | null
  }

  export type CarrinhoComprasMinAggregateOutputType = {
    id: number | null
    clienteId: number | null
  }

  export type CarrinhoComprasMaxAggregateOutputType = {
    id: number | null
    clienteId: number | null
  }

  export type CarrinhoComprasCountAggregateOutputType = {
    id: number
    clienteId: number
    _all: number
  }


  export type CarrinhoComprasAvgAggregateInputType = {
    id?: true
    clienteId?: true
  }

  export type CarrinhoComprasSumAggregateInputType = {
    id?: true
    clienteId?: true
  }

  export type CarrinhoComprasMinAggregateInputType = {
    id?: true
    clienteId?: true
  }

  export type CarrinhoComprasMaxAggregateInputType = {
    id?: true
    clienteId?: true
  }

  export type CarrinhoComprasCountAggregateInputType = {
    id?: true
    clienteId?: true
    _all?: true
  }

  export type CarrinhoComprasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CarrinhoCompras to aggregate.
     */
    where?: CarrinhoComprasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CarrinhoCompras to fetch.
     */
    orderBy?: CarrinhoComprasOrderByWithRelationInput | CarrinhoComprasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CarrinhoComprasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CarrinhoCompras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CarrinhoCompras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CarrinhoCompras
    **/
    _count?: true | CarrinhoComprasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CarrinhoComprasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CarrinhoComprasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CarrinhoComprasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CarrinhoComprasMaxAggregateInputType
  }

  export type GetCarrinhoComprasAggregateType<T extends CarrinhoComprasAggregateArgs> = {
        [P in keyof T & keyof AggregateCarrinhoCompras]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCarrinhoCompras[P]>
      : GetScalarType<T[P], AggregateCarrinhoCompras[P]>
  }




  export type CarrinhoComprasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CarrinhoComprasWhereInput
    orderBy?: CarrinhoComprasOrderByWithAggregationInput | CarrinhoComprasOrderByWithAggregationInput[]
    by: CarrinhoComprasScalarFieldEnum[] | CarrinhoComprasScalarFieldEnum
    having?: CarrinhoComprasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CarrinhoComprasCountAggregateInputType | true
    _avg?: CarrinhoComprasAvgAggregateInputType
    _sum?: CarrinhoComprasSumAggregateInputType
    _min?: CarrinhoComprasMinAggregateInputType
    _max?: CarrinhoComprasMaxAggregateInputType
  }

  export type CarrinhoComprasGroupByOutputType = {
    id: number
    clienteId: number
    _count: CarrinhoComprasCountAggregateOutputType | null
    _avg: CarrinhoComprasAvgAggregateOutputType | null
    _sum: CarrinhoComprasSumAggregateOutputType | null
    _min: CarrinhoComprasMinAggregateOutputType | null
    _max: CarrinhoComprasMaxAggregateOutputType | null
  }

  type GetCarrinhoComprasGroupByPayload<T extends CarrinhoComprasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CarrinhoComprasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CarrinhoComprasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CarrinhoComprasGroupByOutputType[P]>
            : GetScalarType<T[P], CarrinhoComprasGroupByOutputType[P]>
        }
      >
    >


  export type CarrinhoComprasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clienteId?: boolean
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
    items?: boolean | CarrinhoCompras$itemsArgs<ExtArgs>
    _count?: boolean | CarrinhoComprasCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["carrinhoCompras"]>

  export type CarrinhoComprasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clienteId?: boolean
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["carrinhoCompras"]>

  export type CarrinhoComprasSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clienteId?: boolean
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["carrinhoCompras"]>

  export type CarrinhoComprasSelectScalar = {
    id?: boolean
    clienteId?: boolean
  }

  export type CarrinhoComprasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clienteId", ExtArgs["result"]["carrinhoCompras"]>
  export type CarrinhoComprasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
    items?: boolean | CarrinhoCompras$itemsArgs<ExtArgs>
    _count?: boolean | CarrinhoComprasCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CarrinhoComprasIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }
  export type CarrinhoComprasIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }

  export type $CarrinhoComprasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CarrinhoCompras"
    objects: {
      cliente: Prisma.$ClientePayload<ExtArgs>
      items: Prisma.$ItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      clienteId: number
    }, ExtArgs["result"]["carrinhoCompras"]>
    composites: {}
  }

  type CarrinhoComprasGetPayload<S extends boolean | null | undefined | CarrinhoComprasDefaultArgs> = $Result.GetResult<Prisma.$CarrinhoComprasPayload, S>

  type CarrinhoComprasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CarrinhoComprasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CarrinhoComprasCountAggregateInputType | true
    }

  export interface CarrinhoComprasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CarrinhoCompras'], meta: { name: 'CarrinhoCompras' } }
    /**
     * Find zero or one CarrinhoCompras that matches the filter.
     * @param {CarrinhoComprasFindUniqueArgs} args - Arguments to find a CarrinhoCompras
     * @example
     * // Get one CarrinhoCompras
     * const carrinhoCompras = await prisma.carrinhoCompras.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CarrinhoComprasFindUniqueArgs>(args: SelectSubset<T, CarrinhoComprasFindUniqueArgs<ExtArgs>>): Prisma__CarrinhoComprasClient<$Result.GetResult<Prisma.$CarrinhoComprasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CarrinhoCompras that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CarrinhoComprasFindUniqueOrThrowArgs} args - Arguments to find a CarrinhoCompras
     * @example
     * // Get one CarrinhoCompras
     * const carrinhoCompras = await prisma.carrinhoCompras.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CarrinhoComprasFindUniqueOrThrowArgs>(args: SelectSubset<T, CarrinhoComprasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CarrinhoComprasClient<$Result.GetResult<Prisma.$CarrinhoComprasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CarrinhoCompras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarrinhoComprasFindFirstArgs} args - Arguments to find a CarrinhoCompras
     * @example
     * // Get one CarrinhoCompras
     * const carrinhoCompras = await prisma.carrinhoCompras.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CarrinhoComprasFindFirstArgs>(args?: SelectSubset<T, CarrinhoComprasFindFirstArgs<ExtArgs>>): Prisma__CarrinhoComprasClient<$Result.GetResult<Prisma.$CarrinhoComprasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CarrinhoCompras that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarrinhoComprasFindFirstOrThrowArgs} args - Arguments to find a CarrinhoCompras
     * @example
     * // Get one CarrinhoCompras
     * const carrinhoCompras = await prisma.carrinhoCompras.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CarrinhoComprasFindFirstOrThrowArgs>(args?: SelectSubset<T, CarrinhoComprasFindFirstOrThrowArgs<ExtArgs>>): Prisma__CarrinhoComprasClient<$Result.GetResult<Prisma.$CarrinhoComprasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CarrinhoCompras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarrinhoComprasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CarrinhoCompras
     * const carrinhoCompras = await prisma.carrinhoCompras.findMany()
     * 
     * // Get first 10 CarrinhoCompras
     * const carrinhoCompras = await prisma.carrinhoCompras.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const carrinhoComprasWithIdOnly = await prisma.carrinhoCompras.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CarrinhoComprasFindManyArgs>(args?: SelectSubset<T, CarrinhoComprasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarrinhoComprasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CarrinhoCompras.
     * @param {CarrinhoComprasCreateArgs} args - Arguments to create a CarrinhoCompras.
     * @example
     * // Create one CarrinhoCompras
     * const CarrinhoCompras = await prisma.carrinhoCompras.create({
     *   data: {
     *     // ... data to create a CarrinhoCompras
     *   }
     * })
     * 
     */
    create<T extends CarrinhoComprasCreateArgs>(args: SelectSubset<T, CarrinhoComprasCreateArgs<ExtArgs>>): Prisma__CarrinhoComprasClient<$Result.GetResult<Prisma.$CarrinhoComprasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CarrinhoCompras.
     * @param {CarrinhoComprasCreateManyArgs} args - Arguments to create many CarrinhoCompras.
     * @example
     * // Create many CarrinhoCompras
     * const carrinhoCompras = await prisma.carrinhoCompras.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CarrinhoComprasCreateManyArgs>(args?: SelectSubset<T, CarrinhoComprasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CarrinhoCompras and returns the data saved in the database.
     * @param {CarrinhoComprasCreateManyAndReturnArgs} args - Arguments to create many CarrinhoCompras.
     * @example
     * // Create many CarrinhoCompras
     * const carrinhoCompras = await prisma.carrinhoCompras.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CarrinhoCompras and only return the `id`
     * const carrinhoComprasWithIdOnly = await prisma.carrinhoCompras.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CarrinhoComprasCreateManyAndReturnArgs>(args?: SelectSubset<T, CarrinhoComprasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarrinhoComprasPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CarrinhoCompras.
     * @param {CarrinhoComprasDeleteArgs} args - Arguments to delete one CarrinhoCompras.
     * @example
     * // Delete one CarrinhoCompras
     * const CarrinhoCompras = await prisma.carrinhoCompras.delete({
     *   where: {
     *     // ... filter to delete one CarrinhoCompras
     *   }
     * })
     * 
     */
    delete<T extends CarrinhoComprasDeleteArgs>(args: SelectSubset<T, CarrinhoComprasDeleteArgs<ExtArgs>>): Prisma__CarrinhoComprasClient<$Result.GetResult<Prisma.$CarrinhoComprasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CarrinhoCompras.
     * @param {CarrinhoComprasUpdateArgs} args - Arguments to update one CarrinhoCompras.
     * @example
     * // Update one CarrinhoCompras
     * const carrinhoCompras = await prisma.carrinhoCompras.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CarrinhoComprasUpdateArgs>(args: SelectSubset<T, CarrinhoComprasUpdateArgs<ExtArgs>>): Prisma__CarrinhoComprasClient<$Result.GetResult<Prisma.$CarrinhoComprasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CarrinhoCompras.
     * @param {CarrinhoComprasDeleteManyArgs} args - Arguments to filter CarrinhoCompras to delete.
     * @example
     * // Delete a few CarrinhoCompras
     * const { count } = await prisma.carrinhoCompras.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CarrinhoComprasDeleteManyArgs>(args?: SelectSubset<T, CarrinhoComprasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CarrinhoCompras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarrinhoComprasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CarrinhoCompras
     * const carrinhoCompras = await prisma.carrinhoCompras.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CarrinhoComprasUpdateManyArgs>(args: SelectSubset<T, CarrinhoComprasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CarrinhoCompras and returns the data updated in the database.
     * @param {CarrinhoComprasUpdateManyAndReturnArgs} args - Arguments to update many CarrinhoCompras.
     * @example
     * // Update many CarrinhoCompras
     * const carrinhoCompras = await prisma.carrinhoCompras.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CarrinhoCompras and only return the `id`
     * const carrinhoComprasWithIdOnly = await prisma.carrinhoCompras.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CarrinhoComprasUpdateManyAndReturnArgs>(args: SelectSubset<T, CarrinhoComprasUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarrinhoComprasPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CarrinhoCompras.
     * @param {CarrinhoComprasUpsertArgs} args - Arguments to update or create a CarrinhoCompras.
     * @example
     * // Update or create a CarrinhoCompras
     * const carrinhoCompras = await prisma.carrinhoCompras.upsert({
     *   create: {
     *     // ... data to create a CarrinhoCompras
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CarrinhoCompras we want to update
     *   }
     * })
     */
    upsert<T extends CarrinhoComprasUpsertArgs>(args: SelectSubset<T, CarrinhoComprasUpsertArgs<ExtArgs>>): Prisma__CarrinhoComprasClient<$Result.GetResult<Prisma.$CarrinhoComprasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CarrinhoCompras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarrinhoComprasCountArgs} args - Arguments to filter CarrinhoCompras to count.
     * @example
     * // Count the number of CarrinhoCompras
     * const count = await prisma.carrinhoCompras.count({
     *   where: {
     *     // ... the filter for the CarrinhoCompras we want to count
     *   }
     * })
    **/
    count<T extends CarrinhoComprasCountArgs>(
      args?: Subset<T, CarrinhoComprasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CarrinhoComprasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CarrinhoCompras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarrinhoComprasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CarrinhoComprasAggregateArgs>(args: Subset<T, CarrinhoComprasAggregateArgs>): Prisma.PrismaPromise<GetCarrinhoComprasAggregateType<T>>

    /**
     * Group by CarrinhoCompras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarrinhoComprasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CarrinhoComprasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CarrinhoComprasGroupByArgs['orderBy'] }
        : { orderBy?: CarrinhoComprasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CarrinhoComprasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCarrinhoComprasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CarrinhoCompras model
   */
  readonly fields: CarrinhoComprasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CarrinhoCompras.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CarrinhoComprasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cliente<T extends ClienteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClienteDefaultArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends CarrinhoCompras$itemsArgs<ExtArgs> = {}>(args?: Subset<T, CarrinhoCompras$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CarrinhoCompras model
   */
  interface CarrinhoComprasFieldRefs {
    readonly id: FieldRef<"CarrinhoCompras", 'Int'>
    readonly clienteId: FieldRef<"CarrinhoCompras", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CarrinhoCompras findUnique
   */
  export type CarrinhoComprasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarrinhoCompras
     */
    select?: CarrinhoComprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarrinhoCompras
     */
    omit?: CarrinhoComprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrinhoComprasInclude<ExtArgs> | null
    /**
     * Filter, which CarrinhoCompras to fetch.
     */
    where: CarrinhoComprasWhereUniqueInput
  }

  /**
   * CarrinhoCompras findUniqueOrThrow
   */
  export type CarrinhoComprasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarrinhoCompras
     */
    select?: CarrinhoComprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarrinhoCompras
     */
    omit?: CarrinhoComprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrinhoComprasInclude<ExtArgs> | null
    /**
     * Filter, which CarrinhoCompras to fetch.
     */
    where: CarrinhoComprasWhereUniqueInput
  }

  /**
   * CarrinhoCompras findFirst
   */
  export type CarrinhoComprasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarrinhoCompras
     */
    select?: CarrinhoComprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarrinhoCompras
     */
    omit?: CarrinhoComprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrinhoComprasInclude<ExtArgs> | null
    /**
     * Filter, which CarrinhoCompras to fetch.
     */
    where?: CarrinhoComprasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CarrinhoCompras to fetch.
     */
    orderBy?: CarrinhoComprasOrderByWithRelationInput | CarrinhoComprasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CarrinhoCompras.
     */
    cursor?: CarrinhoComprasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CarrinhoCompras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CarrinhoCompras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CarrinhoCompras.
     */
    distinct?: CarrinhoComprasScalarFieldEnum | CarrinhoComprasScalarFieldEnum[]
  }

  /**
   * CarrinhoCompras findFirstOrThrow
   */
  export type CarrinhoComprasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarrinhoCompras
     */
    select?: CarrinhoComprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarrinhoCompras
     */
    omit?: CarrinhoComprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrinhoComprasInclude<ExtArgs> | null
    /**
     * Filter, which CarrinhoCompras to fetch.
     */
    where?: CarrinhoComprasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CarrinhoCompras to fetch.
     */
    orderBy?: CarrinhoComprasOrderByWithRelationInput | CarrinhoComprasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CarrinhoCompras.
     */
    cursor?: CarrinhoComprasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CarrinhoCompras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CarrinhoCompras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CarrinhoCompras.
     */
    distinct?: CarrinhoComprasScalarFieldEnum | CarrinhoComprasScalarFieldEnum[]
  }

  /**
   * CarrinhoCompras findMany
   */
  export type CarrinhoComprasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarrinhoCompras
     */
    select?: CarrinhoComprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarrinhoCompras
     */
    omit?: CarrinhoComprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrinhoComprasInclude<ExtArgs> | null
    /**
     * Filter, which CarrinhoCompras to fetch.
     */
    where?: CarrinhoComprasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CarrinhoCompras to fetch.
     */
    orderBy?: CarrinhoComprasOrderByWithRelationInput | CarrinhoComprasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CarrinhoCompras.
     */
    cursor?: CarrinhoComprasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CarrinhoCompras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CarrinhoCompras.
     */
    skip?: number
    distinct?: CarrinhoComprasScalarFieldEnum | CarrinhoComprasScalarFieldEnum[]
  }

  /**
   * CarrinhoCompras create
   */
  export type CarrinhoComprasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarrinhoCompras
     */
    select?: CarrinhoComprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarrinhoCompras
     */
    omit?: CarrinhoComprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrinhoComprasInclude<ExtArgs> | null
    /**
     * The data needed to create a CarrinhoCompras.
     */
    data: XOR<CarrinhoComprasCreateInput, CarrinhoComprasUncheckedCreateInput>
  }

  /**
   * CarrinhoCompras createMany
   */
  export type CarrinhoComprasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CarrinhoCompras.
     */
    data: CarrinhoComprasCreateManyInput | CarrinhoComprasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CarrinhoCompras createManyAndReturn
   */
  export type CarrinhoComprasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarrinhoCompras
     */
    select?: CarrinhoComprasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CarrinhoCompras
     */
    omit?: CarrinhoComprasOmit<ExtArgs> | null
    /**
     * The data used to create many CarrinhoCompras.
     */
    data: CarrinhoComprasCreateManyInput | CarrinhoComprasCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrinhoComprasIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CarrinhoCompras update
   */
  export type CarrinhoComprasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarrinhoCompras
     */
    select?: CarrinhoComprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarrinhoCompras
     */
    omit?: CarrinhoComprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrinhoComprasInclude<ExtArgs> | null
    /**
     * The data needed to update a CarrinhoCompras.
     */
    data: XOR<CarrinhoComprasUpdateInput, CarrinhoComprasUncheckedUpdateInput>
    /**
     * Choose, which CarrinhoCompras to update.
     */
    where: CarrinhoComprasWhereUniqueInput
  }

  /**
   * CarrinhoCompras updateMany
   */
  export type CarrinhoComprasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CarrinhoCompras.
     */
    data: XOR<CarrinhoComprasUpdateManyMutationInput, CarrinhoComprasUncheckedUpdateManyInput>
    /**
     * Filter which CarrinhoCompras to update
     */
    where?: CarrinhoComprasWhereInput
    /**
     * Limit how many CarrinhoCompras to update.
     */
    limit?: number
  }

  /**
   * CarrinhoCompras updateManyAndReturn
   */
  export type CarrinhoComprasUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarrinhoCompras
     */
    select?: CarrinhoComprasSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CarrinhoCompras
     */
    omit?: CarrinhoComprasOmit<ExtArgs> | null
    /**
     * The data used to update CarrinhoCompras.
     */
    data: XOR<CarrinhoComprasUpdateManyMutationInput, CarrinhoComprasUncheckedUpdateManyInput>
    /**
     * Filter which CarrinhoCompras to update
     */
    where?: CarrinhoComprasWhereInput
    /**
     * Limit how many CarrinhoCompras to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrinhoComprasIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CarrinhoCompras upsert
   */
  export type CarrinhoComprasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarrinhoCompras
     */
    select?: CarrinhoComprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarrinhoCompras
     */
    omit?: CarrinhoComprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrinhoComprasInclude<ExtArgs> | null
    /**
     * The filter to search for the CarrinhoCompras to update in case it exists.
     */
    where: CarrinhoComprasWhereUniqueInput
    /**
     * In case the CarrinhoCompras found by the `where` argument doesn't exist, create a new CarrinhoCompras with this data.
     */
    create: XOR<CarrinhoComprasCreateInput, CarrinhoComprasUncheckedCreateInput>
    /**
     * In case the CarrinhoCompras was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CarrinhoComprasUpdateInput, CarrinhoComprasUncheckedUpdateInput>
  }

  /**
   * CarrinhoCompras delete
   */
  export type CarrinhoComprasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarrinhoCompras
     */
    select?: CarrinhoComprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarrinhoCompras
     */
    omit?: CarrinhoComprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrinhoComprasInclude<ExtArgs> | null
    /**
     * Filter which CarrinhoCompras to delete.
     */
    where: CarrinhoComprasWhereUniqueInput
  }

  /**
   * CarrinhoCompras deleteMany
   */
  export type CarrinhoComprasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CarrinhoCompras to delete
     */
    where?: CarrinhoComprasWhereInput
    /**
     * Limit how many CarrinhoCompras to delete.
     */
    limit?: number
  }

  /**
   * CarrinhoCompras.items
   */
  export type CarrinhoCompras$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    cursor?: ItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * CarrinhoCompras without action
   */
  export type CarrinhoComprasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarrinhoCompras
     */
    select?: CarrinhoComprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarrinhoCompras
     */
    omit?: CarrinhoComprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarrinhoComprasInclude<ExtArgs> | null
  }


  /**
   * Model Item
   */

  export type AggregateItem = {
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  export type ItemAvgAggregateOutputType = {
    id: number | null
    valor: number | null
    carrinhoId: number | null
    produtoId: number | null
    servicoId: number | null
  }

  export type ItemSumAggregateOutputType = {
    id: number | null
    valor: number | null
    carrinhoId: number | null
    produtoId: number | null
    servicoId: number | null
  }

  export type ItemMinAggregateOutputType = {
    id: number | null
    nome: string | null
    valor: number | null
    carrinhoId: number | null
    produtoId: number | null
    servicoId: number | null
  }

  export type ItemMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    valor: number | null
    carrinhoId: number | null
    produtoId: number | null
    servicoId: number | null
  }

  export type ItemCountAggregateOutputType = {
    id: number
    nome: number
    valor: number
    carrinhoId: number
    produtoId: number
    servicoId: number
    _all: number
  }


  export type ItemAvgAggregateInputType = {
    id?: true
    valor?: true
    carrinhoId?: true
    produtoId?: true
    servicoId?: true
  }

  export type ItemSumAggregateInputType = {
    id?: true
    valor?: true
    carrinhoId?: true
    produtoId?: true
    servicoId?: true
  }

  export type ItemMinAggregateInputType = {
    id?: true
    nome?: true
    valor?: true
    carrinhoId?: true
    produtoId?: true
    servicoId?: true
  }

  export type ItemMaxAggregateInputType = {
    id?: true
    nome?: true
    valor?: true
    carrinhoId?: true
    produtoId?: true
    servicoId?: true
  }

  export type ItemCountAggregateInputType = {
    id?: true
    nome?: true
    valor?: true
    carrinhoId?: true
    produtoId?: true
    servicoId?: true
    _all?: true
  }

  export type ItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Item to aggregate.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Items
    **/
    _count?: true | ItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemMaxAggregateInputType
  }

  export type GetItemAggregateType<T extends ItemAggregateArgs> = {
        [P in keyof T & keyof AggregateItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem[P]>
      : GetScalarType<T[P], AggregateItem[P]>
  }




  export type ItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithAggregationInput | ItemOrderByWithAggregationInput[]
    by: ItemScalarFieldEnum[] | ItemScalarFieldEnum
    having?: ItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCountAggregateInputType | true
    _avg?: ItemAvgAggregateInputType
    _sum?: ItemSumAggregateInputType
    _min?: ItemMinAggregateInputType
    _max?: ItemMaxAggregateInputType
  }

  export type ItemGroupByOutputType = {
    id: number
    nome: string
    valor: number
    carrinhoId: number
    produtoId: number | null
    servicoId: number | null
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  type GetItemGroupByPayload<T extends ItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemGroupByOutputType[P]>
            : GetScalarType<T[P], ItemGroupByOutputType[P]>
        }
      >
    >


  export type ItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    valor?: boolean
    carrinhoId?: boolean
    produtoId?: boolean
    servicoId?: boolean
    carrinho?: boolean | CarrinhoComprasDefaultArgs<ExtArgs>
    produto?: boolean | Item$produtoArgs<ExtArgs>
    servico?: boolean | Item$servicoArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type ItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    valor?: boolean
    carrinhoId?: boolean
    produtoId?: boolean
    servicoId?: boolean
    carrinho?: boolean | CarrinhoComprasDefaultArgs<ExtArgs>
    produto?: boolean | Item$produtoArgs<ExtArgs>
    servico?: boolean | Item$servicoArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type ItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    valor?: boolean
    carrinhoId?: boolean
    produtoId?: boolean
    servicoId?: boolean
    carrinho?: boolean | CarrinhoComprasDefaultArgs<ExtArgs>
    produto?: boolean | Item$produtoArgs<ExtArgs>
    servico?: boolean | Item$servicoArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type ItemSelectScalar = {
    id?: boolean
    nome?: boolean
    valor?: boolean
    carrinhoId?: boolean
    produtoId?: boolean
    servicoId?: boolean
  }

  export type ItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "valor" | "carrinhoId" | "produtoId" | "servicoId", ExtArgs["result"]["item"]>
  export type ItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    carrinho?: boolean | CarrinhoComprasDefaultArgs<ExtArgs>
    produto?: boolean | Item$produtoArgs<ExtArgs>
    servico?: boolean | Item$servicoArgs<ExtArgs>
  }
  export type ItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    carrinho?: boolean | CarrinhoComprasDefaultArgs<ExtArgs>
    produto?: boolean | Item$produtoArgs<ExtArgs>
    servico?: boolean | Item$servicoArgs<ExtArgs>
  }
  export type ItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    carrinho?: boolean | CarrinhoComprasDefaultArgs<ExtArgs>
    produto?: boolean | Item$produtoArgs<ExtArgs>
    servico?: boolean | Item$servicoArgs<ExtArgs>
  }

  export type $ItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Item"
    objects: {
      carrinho: Prisma.$CarrinhoComprasPayload<ExtArgs>
      produto: Prisma.$ProdutoPayload<ExtArgs> | null
      servico: Prisma.$ServicoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      valor: number
      carrinhoId: number
      produtoId: number | null
      servicoId: number | null
    }, ExtArgs["result"]["item"]>
    composites: {}
  }

  type ItemGetPayload<S extends boolean | null | undefined | ItemDefaultArgs> = $Result.GetResult<Prisma.$ItemPayload, S>

  type ItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemCountAggregateInputType | true
    }

  export interface ItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Item'], meta: { name: 'Item' } }
    /**
     * Find zero or one Item that matches the filter.
     * @param {ItemFindUniqueArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemFindUniqueArgs>(args: SelectSubset<T, ItemFindUniqueArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Item that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemFindUniqueOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemFindFirstArgs>(args?: SelectSubset<T, ItemFindFirstArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.item.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemWithIdOnly = await prisma.item.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemFindManyArgs>(args?: SelectSubset<T, ItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Item.
     * @param {ItemCreateArgs} args - Arguments to create a Item.
     * @example
     * // Create one Item
     * const Item = await prisma.item.create({
     *   data: {
     *     // ... data to create a Item
     *   }
     * })
     * 
     */
    create<T extends ItemCreateArgs>(args: SelectSubset<T, ItemCreateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Items.
     * @param {ItemCreateManyArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemCreateManyArgs>(args?: SelectSubset<T, ItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Items and returns the data saved in the database.
     * @param {ItemCreateManyAndReturnArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Items and only return the `id`
     * const itemWithIdOnly = await prisma.item.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Item.
     * @param {ItemDeleteArgs} args - Arguments to delete one Item.
     * @example
     * // Delete one Item
     * const Item = await prisma.item.delete({
     *   where: {
     *     // ... filter to delete one Item
     *   }
     * })
     * 
     */
    delete<T extends ItemDeleteArgs>(args: SelectSubset<T, ItemDeleteArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Item.
     * @param {ItemUpdateArgs} args - Arguments to update one Item.
     * @example
     * // Update one Item
     * const item = await prisma.item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemUpdateArgs>(args: SelectSubset<T, ItemUpdateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Items.
     * @param {ItemDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemDeleteManyArgs>(args?: SelectSubset<T, ItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemUpdateManyArgs>(args: SelectSubset<T, ItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items and returns the data updated in the database.
     * @param {ItemUpdateManyAndReturnArgs} args - Arguments to update many Items.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Items and only return the `id`
     * const itemWithIdOnly = await prisma.item.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Item.
     * @param {ItemUpsertArgs} args - Arguments to update or create a Item.
     * @example
     * // Update or create a Item
     * const item = await prisma.item.upsert({
     *   create: {
     *     // ... data to create a Item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item we want to update
     *   }
     * })
     */
    upsert<T extends ItemUpsertArgs>(args: SelectSubset<T, ItemUpsertArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.item.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends ItemCountArgs>(
      args?: Subset<T, ItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemAggregateArgs>(args: Subset<T, ItemAggregateArgs>): Prisma.PrismaPromise<GetItemAggregateType<T>>

    /**
     * Group by Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemGroupByArgs['orderBy'] }
        : { orderBy?: ItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Item model
   */
  readonly fields: ItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    carrinho<T extends CarrinhoComprasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CarrinhoComprasDefaultArgs<ExtArgs>>): Prisma__CarrinhoComprasClient<$Result.GetResult<Prisma.$CarrinhoComprasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    produto<T extends Item$produtoArgs<ExtArgs> = {}>(args?: Subset<T, Item$produtoArgs<ExtArgs>>): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    servico<T extends Item$servicoArgs<ExtArgs> = {}>(args?: Subset<T, Item$servicoArgs<ExtArgs>>): Prisma__ServicoClient<$Result.GetResult<Prisma.$ServicoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Item model
   */
  interface ItemFieldRefs {
    readonly id: FieldRef<"Item", 'Int'>
    readonly nome: FieldRef<"Item", 'String'>
    readonly valor: FieldRef<"Item", 'Float'>
    readonly carrinhoId: FieldRef<"Item", 'Int'>
    readonly produtoId: FieldRef<"Item", 'Int'>
    readonly servicoId: FieldRef<"Item", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Item findUnique
   */
  export type ItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findUniqueOrThrow
   */
  export type ItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findFirst
   */
  export type ItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findFirstOrThrow
   */
  export type ItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findMany
   */
  export type ItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Items to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item create
   */
  export type ItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to create a Item.
     */
    data: XOR<ItemCreateInput, ItemUncheckedCreateInput>
  }

  /**
   * Item createMany
   */
  export type ItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Item createManyAndReturn
   */
  export type ItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Item update
   */
  export type ItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to update a Item.
     */
    data: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
    /**
     * Choose, which Item to update.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item updateMany
   */
  export type ItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to update.
     */
    limit?: number
  }

  /**
   * Item updateManyAndReturn
   */
  export type ItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Item upsert
   */
  export type ItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The filter to search for the Item to update in case it exists.
     */
    where: ItemWhereUniqueInput
    /**
     * In case the Item found by the `where` argument doesn't exist, create a new Item with this data.
     */
    create: XOR<ItemCreateInput, ItemUncheckedCreateInput>
    /**
     * In case the Item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
  }

  /**
   * Item delete
   */
  export type ItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter which Item to delete.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item deleteMany
   */
  export type ItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Items to delete
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to delete.
     */
    limit?: number
  }

  /**
   * Item.produto
   */
  export type Item$produtoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produto
     */
    omit?: ProdutoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdutoInclude<ExtArgs> | null
    where?: ProdutoWhereInput
  }

  /**
   * Item.servico
   */
  export type Item$servicoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servico
     */
    select?: ServicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Servico
     */
    omit?: ServicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicoInclude<ExtArgs> | null
    where?: ServicoWhereInput
  }

  /**
   * Item without action
   */
  export type ItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
  }


  /**
   * Model Produto
   */

  export type AggregateProduto = {
    _count: ProdutoCountAggregateOutputType | null
    _avg: ProdutoAvgAggregateOutputType | null
    _sum: ProdutoSumAggregateOutputType | null
    _min: ProdutoMinAggregateOutputType | null
    _max: ProdutoMaxAggregateOutputType | null
  }

  export type ProdutoAvgAggregateOutputType = {
    id: number | null
    valor: number | null
    quantidade: number | null
    fornecedorId: number | null
  }

  export type ProdutoSumAggregateOutputType = {
    id: number | null
    valor: number | null
    quantidade: number | null
    fornecedorId: number | null
  }

  export type ProdutoMinAggregateOutputType = {
    id: number | null
    nome: string | null
    valor: number | null
    quantidade: number | null
    fornecedorId: number | null
  }

  export type ProdutoMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    valor: number | null
    quantidade: number | null
    fornecedorId: number | null
  }

  export type ProdutoCountAggregateOutputType = {
    id: number
    nome: number
    valor: number
    quantidade: number
    fornecedorId: number
    _all: number
  }


  export type ProdutoAvgAggregateInputType = {
    id?: true
    valor?: true
    quantidade?: true
    fornecedorId?: true
  }

  export type ProdutoSumAggregateInputType = {
    id?: true
    valor?: true
    quantidade?: true
    fornecedorId?: true
  }

  export type ProdutoMinAggregateInputType = {
    id?: true
    nome?: true
    valor?: true
    quantidade?: true
    fornecedorId?: true
  }

  export type ProdutoMaxAggregateInputType = {
    id?: true
    nome?: true
    valor?: true
    quantidade?: true
    fornecedorId?: true
  }

  export type ProdutoCountAggregateInputType = {
    id?: true
    nome?: true
    valor?: true
    quantidade?: true
    fornecedorId?: true
    _all?: true
  }

  export type ProdutoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Produto to aggregate.
     */
    where?: ProdutoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Produtos to fetch.
     */
    orderBy?: ProdutoOrderByWithRelationInput | ProdutoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProdutoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Produtos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Produtos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Produtos
    **/
    _count?: true | ProdutoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProdutoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProdutoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProdutoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProdutoMaxAggregateInputType
  }

  export type GetProdutoAggregateType<T extends ProdutoAggregateArgs> = {
        [P in keyof T & keyof AggregateProduto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduto[P]>
      : GetScalarType<T[P], AggregateProduto[P]>
  }




  export type ProdutoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProdutoWhereInput
    orderBy?: ProdutoOrderByWithAggregationInput | ProdutoOrderByWithAggregationInput[]
    by: ProdutoScalarFieldEnum[] | ProdutoScalarFieldEnum
    having?: ProdutoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProdutoCountAggregateInputType | true
    _avg?: ProdutoAvgAggregateInputType
    _sum?: ProdutoSumAggregateInputType
    _min?: ProdutoMinAggregateInputType
    _max?: ProdutoMaxAggregateInputType
  }

  export type ProdutoGroupByOutputType = {
    id: number
    nome: string
    valor: number
    quantidade: number
    fornecedorId: number
    _count: ProdutoCountAggregateOutputType | null
    _avg: ProdutoAvgAggregateOutputType | null
    _sum: ProdutoSumAggregateOutputType | null
    _min: ProdutoMinAggregateOutputType | null
    _max: ProdutoMaxAggregateOutputType | null
  }

  type GetProdutoGroupByPayload<T extends ProdutoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProdutoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProdutoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProdutoGroupByOutputType[P]>
            : GetScalarType<T[P], ProdutoGroupByOutputType[P]>
        }
      >
    >


  export type ProdutoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    valor?: boolean
    quantidade?: boolean
    fornecedorId?: boolean
    fornecedor?: boolean | FornecedorDefaultArgs<ExtArgs>
    item?: boolean | Produto$itemArgs<ExtArgs>
  }, ExtArgs["result"]["produto"]>

  export type ProdutoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    valor?: boolean
    quantidade?: boolean
    fornecedorId?: boolean
    fornecedor?: boolean | FornecedorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["produto"]>

  export type ProdutoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    valor?: boolean
    quantidade?: boolean
    fornecedorId?: boolean
    fornecedor?: boolean | FornecedorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["produto"]>

  export type ProdutoSelectScalar = {
    id?: boolean
    nome?: boolean
    valor?: boolean
    quantidade?: boolean
    fornecedorId?: boolean
  }

  export type ProdutoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "valor" | "quantidade" | "fornecedorId", ExtArgs["result"]["produto"]>
  export type ProdutoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fornecedor?: boolean | FornecedorDefaultArgs<ExtArgs>
    item?: boolean | Produto$itemArgs<ExtArgs>
  }
  export type ProdutoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fornecedor?: boolean | FornecedorDefaultArgs<ExtArgs>
  }
  export type ProdutoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fornecedor?: boolean | FornecedorDefaultArgs<ExtArgs>
  }

  export type $ProdutoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Produto"
    objects: {
      fornecedor: Prisma.$FornecedorPayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      valor: number
      quantidade: number
      fornecedorId: number
    }, ExtArgs["result"]["produto"]>
    composites: {}
  }

  type ProdutoGetPayload<S extends boolean | null | undefined | ProdutoDefaultArgs> = $Result.GetResult<Prisma.$ProdutoPayload, S>

  type ProdutoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProdutoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProdutoCountAggregateInputType | true
    }

  export interface ProdutoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Produto'], meta: { name: 'Produto' } }
    /**
     * Find zero or one Produto that matches the filter.
     * @param {ProdutoFindUniqueArgs} args - Arguments to find a Produto
     * @example
     * // Get one Produto
     * const produto = await prisma.produto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProdutoFindUniqueArgs>(args: SelectSubset<T, ProdutoFindUniqueArgs<ExtArgs>>): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Produto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProdutoFindUniqueOrThrowArgs} args - Arguments to find a Produto
     * @example
     * // Get one Produto
     * const produto = await prisma.produto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProdutoFindUniqueOrThrowArgs>(args: SelectSubset<T, ProdutoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Produto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutoFindFirstArgs} args - Arguments to find a Produto
     * @example
     * // Get one Produto
     * const produto = await prisma.produto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProdutoFindFirstArgs>(args?: SelectSubset<T, ProdutoFindFirstArgs<ExtArgs>>): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Produto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutoFindFirstOrThrowArgs} args - Arguments to find a Produto
     * @example
     * // Get one Produto
     * const produto = await prisma.produto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProdutoFindFirstOrThrowArgs>(args?: SelectSubset<T, ProdutoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Produtos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Produtos
     * const produtos = await prisma.produto.findMany()
     * 
     * // Get first 10 Produtos
     * const produtos = await prisma.produto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const produtoWithIdOnly = await prisma.produto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProdutoFindManyArgs>(args?: SelectSubset<T, ProdutoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Produto.
     * @param {ProdutoCreateArgs} args - Arguments to create a Produto.
     * @example
     * // Create one Produto
     * const Produto = await prisma.produto.create({
     *   data: {
     *     // ... data to create a Produto
     *   }
     * })
     * 
     */
    create<T extends ProdutoCreateArgs>(args: SelectSubset<T, ProdutoCreateArgs<ExtArgs>>): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Produtos.
     * @param {ProdutoCreateManyArgs} args - Arguments to create many Produtos.
     * @example
     * // Create many Produtos
     * const produto = await prisma.produto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProdutoCreateManyArgs>(args?: SelectSubset<T, ProdutoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Produtos and returns the data saved in the database.
     * @param {ProdutoCreateManyAndReturnArgs} args - Arguments to create many Produtos.
     * @example
     * // Create many Produtos
     * const produto = await prisma.produto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Produtos and only return the `id`
     * const produtoWithIdOnly = await prisma.produto.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProdutoCreateManyAndReturnArgs>(args?: SelectSubset<T, ProdutoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Produto.
     * @param {ProdutoDeleteArgs} args - Arguments to delete one Produto.
     * @example
     * // Delete one Produto
     * const Produto = await prisma.produto.delete({
     *   where: {
     *     // ... filter to delete one Produto
     *   }
     * })
     * 
     */
    delete<T extends ProdutoDeleteArgs>(args: SelectSubset<T, ProdutoDeleteArgs<ExtArgs>>): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Produto.
     * @param {ProdutoUpdateArgs} args - Arguments to update one Produto.
     * @example
     * // Update one Produto
     * const produto = await prisma.produto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProdutoUpdateArgs>(args: SelectSubset<T, ProdutoUpdateArgs<ExtArgs>>): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Produtos.
     * @param {ProdutoDeleteManyArgs} args - Arguments to filter Produtos to delete.
     * @example
     * // Delete a few Produtos
     * const { count } = await prisma.produto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProdutoDeleteManyArgs>(args?: SelectSubset<T, ProdutoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Produtos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Produtos
     * const produto = await prisma.produto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProdutoUpdateManyArgs>(args: SelectSubset<T, ProdutoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Produtos and returns the data updated in the database.
     * @param {ProdutoUpdateManyAndReturnArgs} args - Arguments to update many Produtos.
     * @example
     * // Update many Produtos
     * const produto = await prisma.produto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Produtos and only return the `id`
     * const produtoWithIdOnly = await prisma.produto.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProdutoUpdateManyAndReturnArgs>(args: SelectSubset<T, ProdutoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Produto.
     * @param {ProdutoUpsertArgs} args - Arguments to update or create a Produto.
     * @example
     * // Update or create a Produto
     * const produto = await prisma.produto.upsert({
     *   create: {
     *     // ... data to create a Produto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Produto we want to update
     *   }
     * })
     */
    upsert<T extends ProdutoUpsertArgs>(args: SelectSubset<T, ProdutoUpsertArgs<ExtArgs>>): Prisma__ProdutoClient<$Result.GetResult<Prisma.$ProdutoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Produtos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutoCountArgs} args - Arguments to filter Produtos to count.
     * @example
     * // Count the number of Produtos
     * const count = await prisma.produto.count({
     *   where: {
     *     // ... the filter for the Produtos we want to count
     *   }
     * })
    **/
    count<T extends ProdutoCountArgs>(
      args?: Subset<T, ProdutoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProdutoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Produto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProdutoAggregateArgs>(args: Subset<T, ProdutoAggregateArgs>): Prisma.PrismaPromise<GetProdutoAggregateType<T>>

    /**
     * Group by Produto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProdutoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProdutoGroupByArgs['orderBy'] }
        : { orderBy?: ProdutoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProdutoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProdutoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Produto model
   */
  readonly fields: ProdutoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Produto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProdutoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fornecedor<T extends FornecedorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FornecedorDefaultArgs<ExtArgs>>): Prisma__FornecedorClient<$Result.GetResult<Prisma.$FornecedorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    item<T extends Produto$itemArgs<ExtArgs> = {}>(args?: Subset<T, Produto$itemArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Produto model
   */
  interface ProdutoFieldRefs {
    readonly id: FieldRef<"Produto", 'Int'>
    readonly nome: FieldRef<"Produto", 'String'>
    readonly valor: FieldRef<"Produto", 'Float'>
    readonly quantidade: FieldRef<"Produto", 'Float'>
    readonly fornecedorId: FieldRef<"Produto", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Produto findUnique
   */
  export type ProdutoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produto
     */
    omit?: ProdutoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdutoInclude<ExtArgs> | null
    /**
     * Filter, which Produto to fetch.
     */
    where: ProdutoWhereUniqueInput
  }

  /**
   * Produto findUniqueOrThrow
   */
  export type ProdutoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produto
     */
    omit?: ProdutoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdutoInclude<ExtArgs> | null
    /**
     * Filter, which Produto to fetch.
     */
    where: ProdutoWhereUniqueInput
  }

  /**
   * Produto findFirst
   */
  export type ProdutoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produto
     */
    omit?: ProdutoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdutoInclude<ExtArgs> | null
    /**
     * Filter, which Produto to fetch.
     */
    where?: ProdutoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Produtos to fetch.
     */
    orderBy?: ProdutoOrderByWithRelationInput | ProdutoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Produtos.
     */
    cursor?: ProdutoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Produtos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Produtos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Produtos.
     */
    distinct?: ProdutoScalarFieldEnum | ProdutoScalarFieldEnum[]
  }

  /**
   * Produto findFirstOrThrow
   */
  export type ProdutoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produto
     */
    omit?: ProdutoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdutoInclude<ExtArgs> | null
    /**
     * Filter, which Produto to fetch.
     */
    where?: ProdutoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Produtos to fetch.
     */
    orderBy?: ProdutoOrderByWithRelationInput | ProdutoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Produtos.
     */
    cursor?: ProdutoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Produtos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Produtos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Produtos.
     */
    distinct?: ProdutoScalarFieldEnum | ProdutoScalarFieldEnum[]
  }

  /**
   * Produto findMany
   */
  export type ProdutoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produto
     */
    omit?: ProdutoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdutoInclude<ExtArgs> | null
    /**
     * Filter, which Produtos to fetch.
     */
    where?: ProdutoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Produtos to fetch.
     */
    orderBy?: ProdutoOrderByWithRelationInput | ProdutoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Produtos.
     */
    cursor?: ProdutoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Produtos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Produtos.
     */
    skip?: number
    distinct?: ProdutoScalarFieldEnum | ProdutoScalarFieldEnum[]
  }

  /**
   * Produto create
   */
  export type ProdutoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produto
     */
    omit?: ProdutoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdutoInclude<ExtArgs> | null
    /**
     * The data needed to create a Produto.
     */
    data: XOR<ProdutoCreateInput, ProdutoUncheckedCreateInput>
  }

  /**
   * Produto createMany
   */
  export type ProdutoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Produtos.
     */
    data: ProdutoCreateManyInput | ProdutoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Produto createManyAndReturn
   */
  export type ProdutoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Produto
     */
    omit?: ProdutoOmit<ExtArgs> | null
    /**
     * The data used to create many Produtos.
     */
    data: ProdutoCreateManyInput | ProdutoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdutoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Produto update
   */
  export type ProdutoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produto
     */
    omit?: ProdutoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdutoInclude<ExtArgs> | null
    /**
     * The data needed to update a Produto.
     */
    data: XOR<ProdutoUpdateInput, ProdutoUncheckedUpdateInput>
    /**
     * Choose, which Produto to update.
     */
    where: ProdutoWhereUniqueInput
  }

  /**
   * Produto updateMany
   */
  export type ProdutoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Produtos.
     */
    data: XOR<ProdutoUpdateManyMutationInput, ProdutoUncheckedUpdateManyInput>
    /**
     * Filter which Produtos to update
     */
    where?: ProdutoWhereInput
    /**
     * Limit how many Produtos to update.
     */
    limit?: number
  }

  /**
   * Produto updateManyAndReturn
   */
  export type ProdutoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Produto
     */
    omit?: ProdutoOmit<ExtArgs> | null
    /**
     * The data used to update Produtos.
     */
    data: XOR<ProdutoUpdateManyMutationInput, ProdutoUncheckedUpdateManyInput>
    /**
     * Filter which Produtos to update
     */
    where?: ProdutoWhereInput
    /**
     * Limit how many Produtos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdutoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Produto upsert
   */
  export type ProdutoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produto
     */
    omit?: ProdutoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdutoInclude<ExtArgs> | null
    /**
     * The filter to search for the Produto to update in case it exists.
     */
    where: ProdutoWhereUniqueInput
    /**
     * In case the Produto found by the `where` argument doesn't exist, create a new Produto with this data.
     */
    create: XOR<ProdutoCreateInput, ProdutoUncheckedCreateInput>
    /**
     * In case the Produto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProdutoUpdateInput, ProdutoUncheckedUpdateInput>
  }

  /**
   * Produto delete
   */
  export type ProdutoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produto
     */
    omit?: ProdutoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdutoInclude<ExtArgs> | null
    /**
     * Filter which Produto to delete.
     */
    where: ProdutoWhereUniqueInput
  }

  /**
   * Produto deleteMany
   */
  export type ProdutoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Produtos to delete
     */
    where?: ProdutoWhereInput
    /**
     * Limit how many Produtos to delete.
     */
    limit?: number
  }

  /**
   * Produto.item
   */
  export type Produto$itemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
  }

  /**
   * Produto without action
   */
  export type ProdutoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produto
     */
    select?: ProdutoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produto
     */
    omit?: ProdutoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdutoInclude<ExtArgs> | null
  }


  /**
   * Model Servico
   */

  export type AggregateServico = {
    _count: ServicoCountAggregateOutputType | null
    _avg: ServicoAvgAggregateOutputType | null
    _sum: ServicoSumAggregateOutputType | null
    _min: ServicoMinAggregateOutputType | null
    _max: ServicoMaxAggregateOutputType | null
  }

  export type ServicoAvgAggregateOutputType = {
    id: number | null
    valor: number | null
    fornecedorId: number | null
  }

  export type ServicoSumAggregateOutputType = {
    id: number | null
    valor: number | null
    fornecedorId: number | null
  }

  export type ServicoMinAggregateOutputType = {
    id: number | null
    nome: string | null
    valor: number | null
    dataAgendada: Date | null
    fornecedorId: number | null
  }

  export type ServicoMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    valor: number | null
    dataAgendada: Date | null
    fornecedorId: number | null
  }

  export type ServicoCountAggregateOutputType = {
    id: number
    nome: number
    valor: number
    dataAgendada: number
    fornecedorId: number
    _all: number
  }


  export type ServicoAvgAggregateInputType = {
    id?: true
    valor?: true
    fornecedorId?: true
  }

  export type ServicoSumAggregateInputType = {
    id?: true
    valor?: true
    fornecedorId?: true
  }

  export type ServicoMinAggregateInputType = {
    id?: true
    nome?: true
    valor?: true
    dataAgendada?: true
    fornecedorId?: true
  }

  export type ServicoMaxAggregateInputType = {
    id?: true
    nome?: true
    valor?: true
    dataAgendada?: true
    fornecedorId?: true
  }

  export type ServicoCountAggregateInputType = {
    id?: true
    nome?: true
    valor?: true
    dataAgendada?: true
    fornecedorId?: true
    _all?: true
  }

  export type ServicoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Servico to aggregate.
     */
    where?: ServicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servicos to fetch.
     */
    orderBy?: ServicoOrderByWithRelationInput | ServicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Servicos
    **/
    _count?: true | ServicoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServicoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServicoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicoMaxAggregateInputType
  }

  export type GetServicoAggregateType<T extends ServicoAggregateArgs> = {
        [P in keyof T & keyof AggregateServico]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServico[P]>
      : GetScalarType<T[P], AggregateServico[P]>
  }




  export type ServicoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicoWhereInput
    orderBy?: ServicoOrderByWithAggregationInput | ServicoOrderByWithAggregationInput[]
    by: ServicoScalarFieldEnum[] | ServicoScalarFieldEnum
    having?: ServicoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicoCountAggregateInputType | true
    _avg?: ServicoAvgAggregateInputType
    _sum?: ServicoSumAggregateInputType
    _min?: ServicoMinAggregateInputType
    _max?: ServicoMaxAggregateInputType
  }

  export type ServicoGroupByOutputType = {
    id: number
    nome: string
    valor: number
    dataAgendada: Date
    fornecedorId: number
    _count: ServicoCountAggregateOutputType | null
    _avg: ServicoAvgAggregateOutputType | null
    _sum: ServicoSumAggregateOutputType | null
    _min: ServicoMinAggregateOutputType | null
    _max: ServicoMaxAggregateOutputType | null
  }

  type GetServicoGroupByPayload<T extends ServicoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServicoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicoGroupByOutputType[P]>
            : GetScalarType<T[P], ServicoGroupByOutputType[P]>
        }
      >
    >


  export type ServicoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    valor?: boolean
    dataAgendada?: boolean
    fornecedorId?: boolean
    fornecedor?: boolean | FornecedorDefaultArgs<ExtArgs>
    item?: boolean | Servico$itemArgs<ExtArgs>
  }, ExtArgs["result"]["servico"]>

  export type ServicoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    valor?: boolean
    dataAgendada?: boolean
    fornecedorId?: boolean
    fornecedor?: boolean | FornecedorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servico"]>

  export type ServicoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    valor?: boolean
    dataAgendada?: boolean
    fornecedorId?: boolean
    fornecedor?: boolean | FornecedorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servico"]>

  export type ServicoSelectScalar = {
    id?: boolean
    nome?: boolean
    valor?: boolean
    dataAgendada?: boolean
    fornecedorId?: boolean
  }

  export type ServicoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "valor" | "dataAgendada" | "fornecedorId", ExtArgs["result"]["servico"]>
  export type ServicoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fornecedor?: boolean | FornecedorDefaultArgs<ExtArgs>
    item?: boolean | Servico$itemArgs<ExtArgs>
  }
  export type ServicoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fornecedor?: boolean | FornecedorDefaultArgs<ExtArgs>
  }
  export type ServicoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fornecedor?: boolean | FornecedorDefaultArgs<ExtArgs>
  }

  export type $ServicoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Servico"
    objects: {
      fornecedor: Prisma.$FornecedorPayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      valor: number
      dataAgendada: Date
      fornecedorId: number
    }, ExtArgs["result"]["servico"]>
    composites: {}
  }

  type ServicoGetPayload<S extends boolean | null | undefined | ServicoDefaultArgs> = $Result.GetResult<Prisma.$ServicoPayload, S>

  type ServicoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServicoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServicoCountAggregateInputType | true
    }

  export interface ServicoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Servico'], meta: { name: 'Servico' } }
    /**
     * Find zero or one Servico that matches the filter.
     * @param {ServicoFindUniqueArgs} args - Arguments to find a Servico
     * @example
     * // Get one Servico
     * const servico = await prisma.servico.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServicoFindUniqueArgs>(args: SelectSubset<T, ServicoFindUniqueArgs<ExtArgs>>): Prisma__ServicoClient<$Result.GetResult<Prisma.$ServicoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Servico that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServicoFindUniqueOrThrowArgs} args - Arguments to find a Servico
     * @example
     * // Get one Servico
     * const servico = await prisma.servico.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServicoFindUniqueOrThrowArgs>(args: SelectSubset<T, ServicoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServicoClient<$Result.GetResult<Prisma.$ServicoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Servico that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicoFindFirstArgs} args - Arguments to find a Servico
     * @example
     * // Get one Servico
     * const servico = await prisma.servico.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServicoFindFirstArgs>(args?: SelectSubset<T, ServicoFindFirstArgs<ExtArgs>>): Prisma__ServicoClient<$Result.GetResult<Prisma.$ServicoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Servico that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicoFindFirstOrThrowArgs} args - Arguments to find a Servico
     * @example
     * // Get one Servico
     * const servico = await prisma.servico.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServicoFindFirstOrThrowArgs>(args?: SelectSubset<T, ServicoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServicoClient<$Result.GetResult<Prisma.$ServicoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Servicos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servicos
     * const servicos = await prisma.servico.findMany()
     * 
     * // Get first 10 Servicos
     * const servicos = await prisma.servico.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const servicoWithIdOnly = await prisma.servico.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServicoFindManyArgs>(args?: SelectSubset<T, ServicoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Servico.
     * @param {ServicoCreateArgs} args - Arguments to create a Servico.
     * @example
     * // Create one Servico
     * const Servico = await prisma.servico.create({
     *   data: {
     *     // ... data to create a Servico
     *   }
     * })
     * 
     */
    create<T extends ServicoCreateArgs>(args: SelectSubset<T, ServicoCreateArgs<ExtArgs>>): Prisma__ServicoClient<$Result.GetResult<Prisma.$ServicoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Servicos.
     * @param {ServicoCreateManyArgs} args - Arguments to create many Servicos.
     * @example
     * // Create many Servicos
     * const servico = await prisma.servico.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServicoCreateManyArgs>(args?: SelectSubset<T, ServicoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Servicos and returns the data saved in the database.
     * @param {ServicoCreateManyAndReturnArgs} args - Arguments to create many Servicos.
     * @example
     * // Create many Servicos
     * const servico = await prisma.servico.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Servicos and only return the `id`
     * const servicoWithIdOnly = await prisma.servico.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServicoCreateManyAndReturnArgs>(args?: SelectSubset<T, ServicoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Servico.
     * @param {ServicoDeleteArgs} args - Arguments to delete one Servico.
     * @example
     * // Delete one Servico
     * const Servico = await prisma.servico.delete({
     *   where: {
     *     // ... filter to delete one Servico
     *   }
     * })
     * 
     */
    delete<T extends ServicoDeleteArgs>(args: SelectSubset<T, ServicoDeleteArgs<ExtArgs>>): Prisma__ServicoClient<$Result.GetResult<Prisma.$ServicoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Servico.
     * @param {ServicoUpdateArgs} args - Arguments to update one Servico.
     * @example
     * // Update one Servico
     * const servico = await prisma.servico.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServicoUpdateArgs>(args: SelectSubset<T, ServicoUpdateArgs<ExtArgs>>): Prisma__ServicoClient<$Result.GetResult<Prisma.$ServicoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Servicos.
     * @param {ServicoDeleteManyArgs} args - Arguments to filter Servicos to delete.
     * @example
     * // Delete a few Servicos
     * const { count } = await prisma.servico.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServicoDeleteManyArgs>(args?: SelectSubset<T, ServicoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servicos
     * const servico = await prisma.servico.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServicoUpdateManyArgs>(args: SelectSubset<T, ServicoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicos and returns the data updated in the database.
     * @param {ServicoUpdateManyAndReturnArgs} args - Arguments to update many Servicos.
     * @example
     * // Update many Servicos
     * const servico = await prisma.servico.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Servicos and only return the `id`
     * const servicoWithIdOnly = await prisma.servico.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServicoUpdateManyAndReturnArgs>(args: SelectSubset<T, ServicoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Servico.
     * @param {ServicoUpsertArgs} args - Arguments to update or create a Servico.
     * @example
     * // Update or create a Servico
     * const servico = await prisma.servico.upsert({
     *   create: {
     *     // ... data to create a Servico
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servico we want to update
     *   }
     * })
     */
    upsert<T extends ServicoUpsertArgs>(args: SelectSubset<T, ServicoUpsertArgs<ExtArgs>>): Prisma__ServicoClient<$Result.GetResult<Prisma.$ServicoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Servicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicoCountArgs} args - Arguments to filter Servicos to count.
     * @example
     * // Count the number of Servicos
     * const count = await prisma.servico.count({
     *   where: {
     *     // ... the filter for the Servicos we want to count
     *   }
     * })
    **/
    count<T extends ServicoCountArgs>(
      args?: Subset<T, ServicoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servico.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicoAggregateArgs>(args: Subset<T, ServicoAggregateArgs>): Prisma.PrismaPromise<GetServicoAggregateType<T>>

    /**
     * Group by Servico.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServicoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServicoGroupByArgs['orderBy'] }
        : { orderBy?: ServicoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServicoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Servico model
   */
  readonly fields: ServicoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Servico.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServicoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fornecedor<T extends FornecedorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FornecedorDefaultArgs<ExtArgs>>): Prisma__FornecedorClient<$Result.GetResult<Prisma.$FornecedorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    item<T extends Servico$itemArgs<ExtArgs> = {}>(args?: Subset<T, Servico$itemArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Servico model
   */
  interface ServicoFieldRefs {
    readonly id: FieldRef<"Servico", 'Int'>
    readonly nome: FieldRef<"Servico", 'String'>
    readonly valor: FieldRef<"Servico", 'Float'>
    readonly dataAgendada: FieldRef<"Servico", 'DateTime'>
    readonly fornecedorId: FieldRef<"Servico", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Servico findUnique
   */
  export type ServicoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servico
     */
    select?: ServicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Servico
     */
    omit?: ServicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicoInclude<ExtArgs> | null
    /**
     * Filter, which Servico to fetch.
     */
    where: ServicoWhereUniqueInput
  }

  /**
   * Servico findUniqueOrThrow
   */
  export type ServicoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servico
     */
    select?: ServicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Servico
     */
    omit?: ServicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicoInclude<ExtArgs> | null
    /**
     * Filter, which Servico to fetch.
     */
    where: ServicoWhereUniqueInput
  }

  /**
   * Servico findFirst
   */
  export type ServicoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servico
     */
    select?: ServicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Servico
     */
    omit?: ServicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicoInclude<ExtArgs> | null
    /**
     * Filter, which Servico to fetch.
     */
    where?: ServicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servicos to fetch.
     */
    orderBy?: ServicoOrderByWithRelationInput | ServicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Servicos.
     */
    cursor?: ServicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Servicos.
     */
    distinct?: ServicoScalarFieldEnum | ServicoScalarFieldEnum[]
  }

  /**
   * Servico findFirstOrThrow
   */
  export type ServicoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servico
     */
    select?: ServicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Servico
     */
    omit?: ServicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicoInclude<ExtArgs> | null
    /**
     * Filter, which Servico to fetch.
     */
    where?: ServicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servicos to fetch.
     */
    orderBy?: ServicoOrderByWithRelationInput | ServicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Servicos.
     */
    cursor?: ServicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Servicos.
     */
    distinct?: ServicoScalarFieldEnum | ServicoScalarFieldEnum[]
  }

  /**
   * Servico findMany
   */
  export type ServicoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servico
     */
    select?: ServicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Servico
     */
    omit?: ServicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicoInclude<ExtArgs> | null
    /**
     * Filter, which Servicos to fetch.
     */
    where?: ServicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servicos to fetch.
     */
    orderBy?: ServicoOrderByWithRelationInput | ServicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Servicos.
     */
    cursor?: ServicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servicos.
     */
    skip?: number
    distinct?: ServicoScalarFieldEnum | ServicoScalarFieldEnum[]
  }

  /**
   * Servico create
   */
  export type ServicoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servico
     */
    select?: ServicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Servico
     */
    omit?: ServicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicoInclude<ExtArgs> | null
    /**
     * The data needed to create a Servico.
     */
    data: XOR<ServicoCreateInput, ServicoUncheckedCreateInput>
  }

  /**
   * Servico createMany
   */
  export type ServicoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Servicos.
     */
    data: ServicoCreateManyInput | ServicoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Servico createManyAndReturn
   */
  export type ServicoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servico
     */
    select?: ServicoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Servico
     */
    omit?: ServicoOmit<ExtArgs> | null
    /**
     * The data used to create many Servicos.
     */
    data: ServicoCreateManyInput | ServicoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Servico update
   */
  export type ServicoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servico
     */
    select?: ServicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Servico
     */
    omit?: ServicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicoInclude<ExtArgs> | null
    /**
     * The data needed to update a Servico.
     */
    data: XOR<ServicoUpdateInput, ServicoUncheckedUpdateInput>
    /**
     * Choose, which Servico to update.
     */
    where: ServicoWhereUniqueInput
  }

  /**
   * Servico updateMany
   */
  export type ServicoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Servicos.
     */
    data: XOR<ServicoUpdateManyMutationInput, ServicoUncheckedUpdateManyInput>
    /**
     * Filter which Servicos to update
     */
    where?: ServicoWhereInput
    /**
     * Limit how many Servicos to update.
     */
    limit?: number
  }

  /**
   * Servico updateManyAndReturn
   */
  export type ServicoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servico
     */
    select?: ServicoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Servico
     */
    omit?: ServicoOmit<ExtArgs> | null
    /**
     * The data used to update Servicos.
     */
    data: XOR<ServicoUpdateManyMutationInput, ServicoUncheckedUpdateManyInput>
    /**
     * Filter which Servicos to update
     */
    where?: ServicoWhereInput
    /**
     * Limit how many Servicos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Servico upsert
   */
  export type ServicoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servico
     */
    select?: ServicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Servico
     */
    omit?: ServicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicoInclude<ExtArgs> | null
    /**
     * The filter to search for the Servico to update in case it exists.
     */
    where: ServicoWhereUniqueInput
    /**
     * In case the Servico found by the `where` argument doesn't exist, create a new Servico with this data.
     */
    create: XOR<ServicoCreateInput, ServicoUncheckedCreateInput>
    /**
     * In case the Servico was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServicoUpdateInput, ServicoUncheckedUpdateInput>
  }

  /**
   * Servico delete
   */
  export type ServicoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servico
     */
    select?: ServicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Servico
     */
    omit?: ServicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicoInclude<ExtArgs> | null
    /**
     * Filter which Servico to delete.
     */
    where: ServicoWhereUniqueInput
  }

  /**
   * Servico deleteMany
   */
  export type ServicoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Servicos to delete
     */
    where?: ServicoWhereInput
    /**
     * Limit how many Servicos to delete.
     */
    limit?: number
  }

  /**
   * Servico.item
   */
  export type Servico$itemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
  }

  /**
   * Servico without action
   */
  export type ServicoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servico
     */
    select?: ServicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Servico
     */
    omit?: ServicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicoInclude<ExtArgs> | null
  }


  /**
   * Model Avaliacao
   */

  export type AggregateAvaliacao = {
    _count: AvaliacaoCountAggregateOutputType | null
    _avg: AvaliacaoAvgAggregateOutputType | null
    _sum: AvaliacaoSumAggregateOutputType | null
    _min: AvaliacaoMinAggregateOutputType | null
    _max: AvaliacaoMaxAggregateOutputType | null
  }

  export type AvaliacaoAvgAggregateOutputType = {
    id: number | null
    nota: number | null
    fornecedorId: number | null
  }

  export type AvaliacaoSumAggregateOutputType = {
    id: number | null
    nota: number | null
    fornecedorId: number | null
  }

  export type AvaliacaoMinAggregateOutputType = {
    id: number | null
    nota: number | null
    fornecedorId: number | null
  }

  export type AvaliacaoMaxAggregateOutputType = {
    id: number | null
    nota: number | null
    fornecedorId: number | null
  }

  export type AvaliacaoCountAggregateOutputType = {
    id: number
    nota: number
    fornecedorId: number
    _all: number
  }


  export type AvaliacaoAvgAggregateInputType = {
    id?: true
    nota?: true
    fornecedorId?: true
  }

  export type AvaliacaoSumAggregateInputType = {
    id?: true
    nota?: true
    fornecedorId?: true
  }

  export type AvaliacaoMinAggregateInputType = {
    id?: true
    nota?: true
    fornecedorId?: true
  }

  export type AvaliacaoMaxAggregateInputType = {
    id?: true
    nota?: true
    fornecedorId?: true
  }

  export type AvaliacaoCountAggregateInputType = {
    id?: true
    nota?: true
    fornecedorId?: true
    _all?: true
  }

  export type AvaliacaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Avaliacao to aggregate.
     */
    where?: AvaliacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Avaliacaos to fetch.
     */
    orderBy?: AvaliacaoOrderByWithRelationInput | AvaliacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AvaliacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Avaliacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Avaliacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Avaliacaos
    **/
    _count?: true | AvaliacaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AvaliacaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AvaliacaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AvaliacaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AvaliacaoMaxAggregateInputType
  }

  export type GetAvaliacaoAggregateType<T extends AvaliacaoAggregateArgs> = {
        [P in keyof T & keyof AggregateAvaliacao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAvaliacao[P]>
      : GetScalarType<T[P], AggregateAvaliacao[P]>
  }




  export type AvaliacaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvaliacaoWhereInput
    orderBy?: AvaliacaoOrderByWithAggregationInput | AvaliacaoOrderByWithAggregationInput[]
    by: AvaliacaoScalarFieldEnum[] | AvaliacaoScalarFieldEnum
    having?: AvaliacaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AvaliacaoCountAggregateInputType | true
    _avg?: AvaliacaoAvgAggregateInputType
    _sum?: AvaliacaoSumAggregateInputType
    _min?: AvaliacaoMinAggregateInputType
    _max?: AvaliacaoMaxAggregateInputType
  }

  export type AvaliacaoGroupByOutputType = {
    id: number
    nota: number
    fornecedorId: number
    _count: AvaliacaoCountAggregateOutputType | null
    _avg: AvaliacaoAvgAggregateOutputType | null
    _sum: AvaliacaoSumAggregateOutputType | null
    _min: AvaliacaoMinAggregateOutputType | null
    _max: AvaliacaoMaxAggregateOutputType | null
  }

  type GetAvaliacaoGroupByPayload<T extends AvaliacaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AvaliacaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AvaliacaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AvaliacaoGroupByOutputType[P]>
            : GetScalarType<T[P], AvaliacaoGroupByOutputType[P]>
        }
      >
    >


  export type AvaliacaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nota?: boolean
    fornecedorId?: boolean
    fornecedor?: boolean | FornecedorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["avaliacao"]>

  export type AvaliacaoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nota?: boolean
    fornecedorId?: boolean
    fornecedor?: boolean | FornecedorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["avaliacao"]>

  export type AvaliacaoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nota?: boolean
    fornecedorId?: boolean
    fornecedor?: boolean | FornecedorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["avaliacao"]>

  export type AvaliacaoSelectScalar = {
    id?: boolean
    nota?: boolean
    fornecedorId?: boolean
  }

  export type AvaliacaoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nota" | "fornecedorId", ExtArgs["result"]["avaliacao"]>
  export type AvaliacaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fornecedor?: boolean | FornecedorDefaultArgs<ExtArgs>
  }
  export type AvaliacaoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fornecedor?: boolean | FornecedorDefaultArgs<ExtArgs>
  }
  export type AvaliacaoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fornecedor?: boolean | FornecedorDefaultArgs<ExtArgs>
  }

  export type $AvaliacaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Avaliacao"
    objects: {
      fornecedor: Prisma.$FornecedorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nota: number
      fornecedorId: number
    }, ExtArgs["result"]["avaliacao"]>
    composites: {}
  }

  type AvaliacaoGetPayload<S extends boolean | null | undefined | AvaliacaoDefaultArgs> = $Result.GetResult<Prisma.$AvaliacaoPayload, S>

  type AvaliacaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AvaliacaoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AvaliacaoCountAggregateInputType | true
    }

  export interface AvaliacaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Avaliacao'], meta: { name: 'Avaliacao' } }
    /**
     * Find zero or one Avaliacao that matches the filter.
     * @param {AvaliacaoFindUniqueArgs} args - Arguments to find a Avaliacao
     * @example
     * // Get one Avaliacao
     * const avaliacao = await prisma.avaliacao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AvaliacaoFindUniqueArgs>(args: SelectSubset<T, AvaliacaoFindUniqueArgs<ExtArgs>>): Prisma__AvaliacaoClient<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Avaliacao that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AvaliacaoFindUniqueOrThrowArgs} args - Arguments to find a Avaliacao
     * @example
     * // Get one Avaliacao
     * const avaliacao = await prisma.avaliacao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AvaliacaoFindUniqueOrThrowArgs>(args: SelectSubset<T, AvaliacaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AvaliacaoClient<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Avaliacao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvaliacaoFindFirstArgs} args - Arguments to find a Avaliacao
     * @example
     * // Get one Avaliacao
     * const avaliacao = await prisma.avaliacao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AvaliacaoFindFirstArgs>(args?: SelectSubset<T, AvaliacaoFindFirstArgs<ExtArgs>>): Prisma__AvaliacaoClient<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Avaliacao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvaliacaoFindFirstOrThrowArgs} args - Arguments to find a Avaliacao
     * @example
     * // Get one Avaliacao
     * const avaliacao = await prisma.avaliacao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AvaliacaoFindFirstOrThrowArgs>(args?: SelectSubset<T, AvaliacaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__AvaliacaoClient<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Avaliacaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvaliacaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Avaliacaos
     * const avaliacaos = await prisma.avaliacao.findMany()
     * 
     * // Get first 10 Avaliacaos
     * const avaliacaos = await prisma.avaliacao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const avaliacaoWithIdOnly = await prisma.avaliacao.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AvaliacaoFindManyArgs>(args?: SelectSubset<T, AvaliacaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Avaliacao.
     * @param {AvaliacaoCreateArgs} args - Arguments to create a Avaliacao.
     * @example
     * // Create one Avaliacao
     * const Avaliacao = await prisma.avaliacao.create({
     *   data: {
     *     // ... data to create a Avaliacao
     *   }
     * })
     * 
     */
    create<T extends AvaliacaoCreateArgs>(args: SelectSubset<T, AvaliacaoCreateArgs<ExtArgs>>): Prisma__AvaliacaoClient<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Avaliacaos.
     * @param {AvaliacaoCreateManyArgs} args - Arguments to create many Avaliacaos.
     * @example
     * // Create many Avaliacaos
     * const avaliacao = await prisma.avaliacao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AvaliacaoCreateManyArgs>(args?: SelectSubset<T, AvaliacaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Avaliacaos and returns the data saved in the database.
     * @param {AvaliacaoCreateManyAndReturnArgs} args - Arguments to create many Avaliacaos.
     * @example
     * // Create many Avaliacaos
     * const avaliacao = await prisma.avaliacao.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Avaliacaos and only return the `id`
     * const avaliacaoWithIdOnly = await prisma.avaliacao.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AvaliacaoCreateManyAndReturnArgs>(args?: SelectSubset<T, AvaliacaoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Avaliacao.
     * @param {AvaliacaoDeleteArgs} args - Arguments to delete one Avaliacao.
     * @example
     * // Delete one Avaliacao
     * const Avaliacao = await prisma.avaliacao.delete({
     *   where: {
     *     // ... filter to delete one Avaliacao
     *   }
     * })
     * 
     */
    delete<T extends AvaliacaoDeleteArgs>(args: SelectSubset<T, AvaliacaoDeleteArgs<ExtArgs>>): Prisma__AvaliacaoClient<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Avaliacao.
     * @param {AvaliacaoUpdateArgs} args - Arguments to update one Avaliacao.
     * @example
     * // Update one Avaliacao
     * const avaliacao = await prisma.avaliacao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AvaliacaoUpdateArgs>(args: SelectSubset<T, AvaliacaoUpdateArgs<ExtArgs>>): Prisma__AvaliacaoClient<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Avaliacaos.
     * @param {AvaliacaoDeleteManyArgs} args - Arguments to filter Avaliacaos to delete.
     * @example
     * // Delete a few Avaliacaos
     * const { count } = await prisma.avaliacao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AvaliacaoDeleteManyArgs>(args?: SelectSubset<T, AvaliacaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Avaliacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvaliacaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Avaliacaos
     * const avaliacao = await prisma.avaliacao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AvaliacaoUpdateManyArgs>(args: SelectSubset<T, AvaliacaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Avaliacaos and returns the data updated in the database.
     * @param {AvaliacaoUpdateManyAndReturnArgs} args - Arguments to update many Avaliacaos.
     * @example
     * // Update many Avaliacaos
     * const avaliacao = await prisma.avaliacao.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Avaliacaos and only return the `id`
     * const avaliacaoWithIdOnly = await prisma.avaliacao.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AvaliacaoUpdateManyAndReturnArgs>(args: SelectSubset<T, AvaliacaoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Avaliacao.
     * @param {AvaliacaoUpsertArgs} args - Arguments to update or create a Avaliacao.
     * @example
     * // Update or create a Avaliacao
     * const avaliacao = await prisma.avaliacao.upsert({
     *   create: {
     *     // ... data to create a Avaliacao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Avaliacao we want to update
     *   }
     * })
     */
    upsert<T extends AvaliacaoUpsertArgs>(args: SelectSubset<T, AvaliacaoUpsertArgs<ExtArgs>>): Prisma__AvaliacaoClient<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Avaliacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvaliacaoCountArgs} args - Arguments to filter Avaliacaos to count.
     * @example
     * // Count the number of Avaliacaos
     * const count = await prisma.avaliacao.count({
     *   where: {
     *     // ... the filter for the Avaliacaos we want to count
     *   }
     * })
    **/
    count<T extends AvaliacaoCountArgs>(
      args?: Subset<T, AvaliacaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AvaliacaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Avaliacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvaliacaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AvaliacaoAggregateArgs>(args: Subset<T, AvaliacaoAggregateArgs>): Prisma.PrismaPromise<GetAvaliacaoAggregateType<T>>

    /**
     * Group by Avaliacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvaliacaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AvaliacaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AvaliacaoGroupByArgs['orderBy'] }
        : { orderBy?: AvaliacaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AvaliacaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAvaliacaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Avaliacao model
   */
  readonly fields: AvaliacaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Avaliacao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AvaliacaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fornecedor<T extends FornecedorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FornecedorDefaultArgs<ExtArgs>>): Prisma__FornecedorClient<$Result.GetResult<Prisma.$FornecedorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Avaliacao model
   */
  interface AvaliacaoFieldRefs {
    readonly id: FieldRef<"Avaliacao", 'Int'>
    readonly nota: FieldRef<"Avaliacao", 'Float'>
    readonly fornecedorId: FieldRef<"Avaliacao", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Avaliacao findUnique
   */
  export type AvaliacaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avaliacao
     */
    omit?: AvaliacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    /**
     * Filter, which Avaliacao to fetch.
     */
    where: AvaliacaoWhereUniqueInput
  }

  /**
   * Avaliacao findUniqueOrThrow
   */
  export type AvaliacaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avaliacao
     */
    omit?: AvaliacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    /**
     * Filter, which Avaliacao to fetch.
     */
    where: AvaliacaoWhereUniqueInput
  }

  /**
   * Avaliacao findFirst
   */
  export type AvaliacaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avaliacao
     */
    omit?: AvaliacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    /**
     * Filter, which Avaliacao to fetch.
     */
    where?: AvaliacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Avaliacaos to fetch.
     */
    orderBy?: AvaliacaoOrderByWithRelationInput | AvaliacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Avaliacaos.
     */
    cursor?: AvaliacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Avaliacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Avaliacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Avaliacaos.
     */
    distinct?: AvaliacaoScalarFieldEnum | AvaliacaoScalarFieldEnum[]
  }

  /**
   * Avaliacao findFirstOrThrow
   */
  export type AvaliacaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avaliacao
     */
    omit?: AvaliacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    /**
     * Filter, which Avaliacao to fetch.
     */
    where?: AvaliacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Avaliacaos to fetch.
     */
    orderBy?: AvaliacaoOrderByWithRelationInput | AvaliacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Avaliacaos.
     */
    cursor?: AvaliacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Avaliacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Avaliacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Avaliacaos.
     */
    distinct?: AvaliacaoScalarFieldEnum | AvaliacaoScalarFieldEnum[]
  }

  /**
   * Avaliacao findMany
   */
  export type AvaliacaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avaliacao
     */
    omit?: AvaliacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    /**
     * Filter, which Avaliacaos to fetch.
     */
    where?: AvaliacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Avaliacaos to fetch.
     */
    orderBy?: AvaliacaoOrderByWithRelationInput | AvaliacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Avaliacaos.
     */
    cursor?: AvaliacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Avaliacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Avaliacaos.
     */
    skip?: number
    distinct?: AvaliacaoScalarFieldEnum | AvaliacaoScalarFieldEnum[]
  }

  /**
   * Avaliacao create
   */
  export type AvaliacaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avaliacao
     */
    omit?: AvaliacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    /**
     * The data needed to create a Avaliacao.
     */
    data: XOR<AvaliacaoCreateInput, AvaliacaoUncheckedCreateInput>
  }

  /**
   * Avaliacao createMany
   */
  export type AvaliacaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Avaliacaos.
     */
    data: AvaliacaoCreateManyInput | AvaliacaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Avaliacao createManyAndReturn
   */
  export type AvaliacaoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Avaliacao
     */
    omit?: AvaliacaoOmit<ExtArgs> | null
    /**
     * The data used to create many Avaliacaos.
     */
    data: AvaliacaoCreateManyInput | AvaliacaoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Avaliacao update
   */
  export type AvaliacaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avaliacao
     */
    omit?: AvaliacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    /**
     * The data needed to update a Avaliacao.
     */
    data: XOR<AvaliacaoUpdateInput, AvaliacaoUncheckedUpdateInput>
    /**
     * Choose, which Avaliacao to update.
     */
    where: AvaliacaoWhereUniqueInput
  }

  /**
   * Avaliacao updateMany
   */
  export type AvaliacaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Avaliacaos.
     */
    data: XOR<AvaliacaoUpdateManyMutationInput, AvaliacaoUncheckedUpdateManyInput>
    /**
     * Filter which Avaliacaos to update
     */
    where?: AvaliacaoWhereInput
    /**
     * Limit how many Avaliacaos to update.
     */
    limit?: number
  }

  /**
   * Avaliacao updateManyAndReturn
   */
  export type AvaliacaoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Avaliacao
     */
    omit?: AvaliacaoOmit<ExtArgs> | null
    /**
     * The data used to update Avaliacaos.
     */
    data: XOR<AvaliacaoUpdateManyMutationInput, AvaliacaoUncheckedUpdateManyInput>
    /**
     * Filter which Avaliacaos to update
     */
    where?: AvaliacaoWhereInput
    /**
     * Limit how many Avaliacaos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Avaliacao upsert
   */
  export type AvaliacaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avaliacao
     */
    omit?: AvaliacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    /**
     * The filter to search for the Avaliacao to update in case it exists.
     */
    where: AvaliacaoWhereUniqueInput
    /**
     * In case the Avaliacao found by the `where` argument doesn't exist, create a new Avaliacao with this data.
     */
    create: XOR<AvaliacaoCreateInput, AvaliacaoUncheckedCreateInput>
    /**
     * In case the Avaliacao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AvaliacaoUpdateInput, AvaliacaoUncheckedUpdateInput>
  }

  /**
   * Avaliacao delete
   */
  export type AvaliacaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avaliacao
     */
    omit?: AvaliacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    /**
     * Filter which Avaliacao to delete.
     */
    where: AvaliacaoWhereUniqueInput
  }

  /**
   * Avaliacao deleteMany
   */
  export type AvaliacaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Avaliacaos to delete
     */
    where?: AvaliacaoWhereInput
    /**
     * Limit how many Avaliacaos to delete.
     */
    limit?: number
  }

  /**
   * Avaliacao without action
   */
  export type AvaliacaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avaliacao
     */
    omit?: AvaliacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    email: 'email',
    senha: 'senha',
    imagemPerfil: 'imagemPerfil',
    tipo: 'tipo'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const EnderecoScalarFieldEnum: {
    id: 'id',
    rua: 'rua',
    bairro: 'bairro',
    cep: 'cep',
    numero: 'numero',
    complemento: 'complemento',
    usuarioId: 'usuarioId'
  };

  export type EnderecoScalarFieldEnum = (typeof EnderecoScalarFieldEnum)[keyof typeof EnderecoScalarFieldEnum]


  export const CartaoScalarFieldEnum: {
    id: 'id',
    tipoCartao: 'tipoCartao',
    numeroCartao: 'numeroCartao',
    cvc: 'cvc',
    nomeCartao: 'nomeCartao',
    dataValidade: 'dataValidade',
    usuarioId: 'usuarioId'
  };

  export type CartaoScalarFieldEnum = (typeof CartaoScalarFieldEnum)[keyof typeof CartaoScalarFieldEnum]


  export const ClienteScalarFieldEnum: {
    id: 'id'
  };

  export type ClienteScalarFieldEnum = (typeof ClienteScalarFieldEnum)[keyof typeof ClienteScalarFieldEnum]


  export const FornecedorScalarFieldEnum: {
    id: 'id',
    avaliacaoTotal: 'avaliacaoTotal'
  };

  export type FornecedorScalarFieldEnum = (typeof FornecedorScalarFieldEnum)[keyof typeof FornecedorScalarFieldEnum]


  export const DadosBancariosScalarFieldEnum: {
    id: 'id',
    idBanco: 'idBanco',
    numAgencia: 'numAgencia',
    tipoConta: 'tipoConta',
    fornecedorId: 'fornecedorId'
  };

  export type DadosBancariosScalarFieldEnum = (typeof DadosBancariosScalarFieldEnum)[keyof typeof DadosBancariosScalarFieldEnum]


  export const CupomScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    dataValidade: 'dataValidade',
    desconto: 'desconto',
    clienteId: 'clienteId'
  };

  export type CupomScalarFieldEnum = (typeof CupomScalarFieldEnum)[keyof typeof CupomScalarFieldEnum]


  export const CarrinhoComprasScalarFieldEnum: {
    id: 'id',
    clienteId: 'clienteId'
  };

  export type CarrinhoComprasScalarFieldEnum = (typeof CarrinhoComprasScalarFieldEnum)[keyof typeof CarrinhoComprasScalarFieldEnum]


  export const ItemScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    valor: 'valor',
    carrinhoId: 'carrinhoId',
    produtoId: 'produtoId',
    servicoId: 'servicoId'
  };

  export type ItemScalarFieldEnum = (typeof ItemScalarFieldEnum)[keyof typeof ItemScalarFieldEnum]


  export const ProdutoScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    valor: 'valor',
    quantidade: 'quantidade',
    fornecedorId: 'fornecedorId'
  };

  export type ProdutoScalarFieldEnum = (typeof ProdutoScalarFieldEnum)[keyof typeof ProdutoScalarFieldEnum]


  export const ServicoScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    valor: 'valor',
    dataAgendada: 'dataAgendada',
    fornecedorId: 'fornecedorId'
  };

  export type ServicoScalarFieldEnum = (typeof ServicoScalarFieldEnum)[keyof typeof ServicoScalarFieldEnum]


  export const AvaliacaoScalarFieldEnum: {
    id: 'id',
    nota: 'nota',
    fornecedorId: 'fornecedorId'
  };

  export type AvaliacaoScalarFieldEnum = (typeof AvaliacaoScalarFieldEnum)[keyof typeof AvaliacaoScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'TipoCartao'
   */
  export type EnumTipoCartaoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoCartao'>
    


  /**
   * Reference to a field of type 'TipoCartao[]'
   */
  export type ListEnumTipoCartaoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoCartao[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    id?: IntFilter<"Usuario"> | number
    nome?: StringFilter<"Usuario"> | string
    email?: StringFilter<"Usuario"> | string
    senha?: StringFilter<"Usuario"> | string
    imagemPerfil?: StringNullableFilter<"Usuario"> | string | null
    tipo?: StringFilter<"Usuario"> | string
    endereco?: XOR<EnderecoNullableScalarRelationFilter, EnderecoWhereInput> | null
    cartoes?: CartaoListRelationFilter
    cliente?: XOR<ClienteNullableScalarRelationFilter, ClienteWhereInput> | null
    fornecedor?: XOR<FornecedorNullableScalarRelationFilter, FornecedorWhereInput> | null
  }

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    imagemPerfil?: SortOrderInput | SortOrder
    tipo?: SortOrder
    endereco?: EnderecoOrderByWithRelationInput
    cartoes?: CartaoOrderByRelationAggregateInput
    cliente?: ClienteOrderByWithRelationInput
    fornecedor?: FornecedorOrderByWithRelationInput
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    nome?: StringFilter<"Usuario"> | string
    senha?: StringFilter<"Usuario"> | string
    imagemPerfil?: StringNullableFilter<"Usuario"> | string | null
    tipo?: StringFilter<"Usuario"> | string
    endereco?: XOR<EnderecoNullableScalarRelationFilter, EnderecoWhereInput> | null
    cartoes?: CartaoListRelationFilter
    cliente?: XOR<ClienteNullableScalarRelationFilter, ClienteWhereInput> | null
    fornecedor?: XOR<FornecedorNullableScalarRelationFilter, FornecedorWhereInput> | null
  }, "id" | "email">

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    imagemPerfil?: SortOrderInput | SortOrder
    tipo?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Usuario"> | number
    nome?: StringWithAggregatesFilter<"Usuario"> | string
    email?: StringWithAggregatesFilter<"Usuario"> | string
    senha?: StringWithAggregatesFilter<"Usuario"> | string
    imagemPerfil?: StringNullableWithAggregatesFilter<"Usuario"> | string | null
    tipo?: StringWithAggregatesFilter<"Usuario"> | string
  }

  export type EnderecoWhereInput = {
    AND?: EnderecoWhereInput | EnderecoWhereInput[]
    OR?: EnderecoWhereInput[]
    NOT?: EnderecoWhereInput | EnderecoWhereInput[]
    id?: IntFilter<"Endereco"> | number
    rua?: StringFilter<"Endereco"> | string
    bairro?: StringFilter<"Endereco"> | string
    cep?: StringFilter<"Endereco"> | string
    numero?: StringFilter<"Endereco"> | string
    complemento?: StringFilter<"Endereco"> | string
    usuarioId?: IntFilter<"Endereco"> | number
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }

  export type EnderecoOrderByWithRelationInput = {
    id?: SortOrder
    rua?: SortOrder
    bairro?: SortOrder
    cep?: SortOrder
    numero?: SortOrder
    complemento?: SortOrder
    usuarioId?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type EnderecoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    usuarioId?: number
    AND?: EnderecoWhereInput | EnderecoWhereInput[]
    OR?: EnderecoWhereInput[]
    NOT?: EnderecoWhereInput | EnderecoWhereInput[]
    rua?: StringFilter<"Endereco"> | string
    bairro?: StringFilter<"Endereco"> | string
    cep?: StringFilter<"Endereco"> | string
    numero?: StringFilter<"Endereco"> | string
    complemento?: StringFilter<"Endereco"> | string
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }, "id" | "usuarioId">

  export type EnderecoOrderByWithAggregationInput = {
    id?: SortOrder
    rua?: SortOrder
    bairro?: SortOrder
    cep?: SortOrder
    numero?: SortOrder
    complemento?: SortOrder
    usuarioId?: SortOrder
    _count?: EnderecoCountOrderByAggregateInput
    _avg?: EnderecoAvgOrderByAggregateInput
    _max?: EnderecoMaxOrderByAggregateInput
    _min?: EnderecoMinOrderByAggregateInput
    _sum?: EnderecoSumOrderByAggregateInput
  }

  export type EnderecoScalarWhereWithAggregatesInput = {
    AND?: EnderecoScalarWhereWithAggregatesInput | EnderecoScalarWhereWithAggregatesInput[]
    OR?: EnderecoScalarWhereWithAggregatesInput[]
    NOT?: EnderecoScalarWhereWithAggregatesInput | EnderecoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Endereco"> | number
    rua?: StringWithAggregatesFilter<"Endereco"> | string
    bairro?: StringWithAggregatesFilter<"Endereco"> | string
    cep?: StringWithAggregatesFilter<"Endereco"> | string
    numero?: StringWithAggregatesFilter<"Endereco"> | string
    complemento?: StringWithAggregatesFilter<"Endereco"> | string
    usuarioId?: IntWithAggregatesFilter<"Endereco"> | number
  }

  export type CartaoWhereInput = {
    AND?: CartaoWhereInput | CartaoWhereInput[]
    OR?: CartaoWhereInput[]
    NOT?: CartaoWhereInput | CartaoWhereInput[]
    id?: IntFilter<"Cartao"> | number
    tipoCartao?: EnumTipoCartaoFilter<"Cartao"> | $Enums.TipoCartao
    numeroCartao?: StringFilter<"Cartao"> | string
    cvc?: IntFilter<"Cartao"> | number
    nomeCartao?: StringFilter<"Cartao"> | string
    dataValidade?: DateTimeFilter<"Cartao"> | Date | string
    usuarioId?: IntFilter<"Cartao"> | number
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }

  export type CartaoOrderByWithRelationInput = {
    id?: SortOrder
    tipoCartao?: SortOrder
    numeroCartao?: SortOrder
    cvc?: SortOrder
    nomeCartao?: SortOrder
    dataValidade?: SortOrder
    usuarioId?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type CartaoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CartaoWhereInput | CartaoWhereInput[]
    OR?: CartaoWhereInput[]
    NOT?: CartaoWhereInput | CartaoWhereInput[]
    tipoCartao?: EnumTipoCartaoFilter<"Cartao"> | $Enums.TipoCartao
    numeroCartao?: StringFilter<"Cartao"> | string
    cvc?: IntFilter<"Cartao"> | number
    nomeCartao?: StringFilter<"Cartao"> | string
    dataValidade?: DateTimeFilter<"Cartao"> | Date | string
    usuarioId?: IntFilter<"Cartao"> | number
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }, "id">

  export type CartaoOrderByWithAggregationInput = {
    id?: SortOrder
    tipoCartao?: SortOrder
    numeroCartao?: SortOrder
    cvc?: SortOrder
    nomeCartao?: SortOrder
    dataValidade?: SortOrder
    usuarioId?: SortOrder
    _count?: CartaoCountOrderByAggregateInput
    _avg?: CartaoAvgOrderByAggregateInput
    _max?: CartaoMaxOrderByAggregateInput
    _min?: CartaoMinOrderByAggregateInput
    _sum?: CartaoSumOrderByAggregateInput
  }

  export type CartaoScalarWhereWithAggregatesInput = {
    AND?: CartaoScalarWhereWithAggregatesInput | CartaoScalarWhereWithAggregatesInput[]
    OR?: CartaoScalarWhereWithAggregatesInput[]
    NOT?: CartaoScalarWhereWithAggregatesInput | CartaoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Cartao"> | number
    tipoCartao?: EnumTipoCartaoWithAggregatesFilter<"Cartao"> | $Enums.TipoCartao
    numeroCartao?: StringWithAggregatesFilter<"Cartao"> | string
    cvc?: IntWithAggregatesFilter<"Cartao"> | number
    nomeCartao?: StringWithAggregatesFilter<"Cartao"> | string
    dataValidade?: DateTimeWithAggregatesFilter<"Cartao"> | Date | string
    usuarioId?: IntWithAggregatesFilter<"Cartao"> | number
  }

  export type ClienteWhereInput = {
    AND?: ClienteWhereInput | ClienteWhereInput[]
    OR?: ClienteWhereInput[]
    NOT?: ClienteWhereInput | ClienteWhereInput[]
    id?: IntFilter<"Cliente"> | number
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    cupons?: CupomListRelationFilter
    carrinho?: XOR<CarrinhoComprasNullableScalarRelationFilter, CarrinhoComprasWhereInput> | null
  }

  export type ClienteOrderByWithRelationInput = {
    id?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
    cupons?: CupomOrderByRelationAggregateInput
    carrinho?: CarrinhoComprasOrderByWithRelationInput
  }

  export type ClienteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClienteWhereInput | ClienteWhereInput[]
    OR?: ClienteWhereInput[]
    NOT?: ClienteWhereInput | ClienteWhereInput[]
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    cupons?: CupomListRelationFilter
    carrinho?: XOR<CarrinhoComprasNullableScalarRelationFilter, CarrinhoComprasWhereInput> | null
  }, "id">

  export type ClienteOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: ClienteCountOrderByAggregateInput
    _avg?: ClienteAvgOrderByAggregateInput
    _max?: ClienteMaxOrderByAggregateInput
    _min?: ClienteMinOrderByAggregateInput
    _sum?: ClienteSumOrderByAggregateInput
  }

  export type ClienteScalarWhereWithAggregatesInput = {
    AND?: ClienteScalarWhereWithAggregatesInput | ClienteScalarWhereWithAggregatesInput[]
    OR?: ClienteScalarWhereWithAggregatesInput[]
    NOT?: ClienteScalarWhereWithAggregatesInput | ClienteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Cliente"> | number
  }

  export type FornecedorWhereInput = {
    AND?: FornecedorWhereInput | FornecedorWhereInput[]
    OR?: FornecedorWhereInput[]
    NOT?: FornecedorWhereInput | FornecedorWhereInput[]
    id?: IntFilter<"Fornecedor"> | number
    avaliacaoTotal?: FloatFilter<"Fornecedor"> | number
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    avaliacoes?: AvaliacaoListRelationFilter
    dadosBancarios?: XOR<DadosBancariosNullableScalarRelationFilter, DadosBancariosWhereInput> | null
    produtos?: ProdutoListRelationFilter
    servicos?: ServicoListRelationFilter
  }

  export type FornecedorOrderByWithRelationInput = {
    id?: SortOrder
    avaliacaoTotal?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
    avaliacoes?: AvaliacaoOrderByRelationAggregateInput
    dadosBancarios?: DadosBancariosOrderByWithRelationInput
    produtos?: ProdutoOrderByRelationAggregateInput
    servicos?: ServicoOrderByRelationAggregateInput
  }

  export type FornecedorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FornecedorWhereInput | FornecedorWhereInput[]
    OR?: FornecedorWhereInput[]
    NOT?: FornecedorWhereInput | FornecedorWhereInput[]
    avaliacaoTotal?: FloatFilter<"Fornecedor"> | number
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    avaliacoes?: AvaliacaoListRelationFilter
    dadosBancarios?: XOR<DadosBancariosNullableScalarRelationFilter, DadosBancariosWhereInput> | null
    produtos?: ProdutoListRelationFilter
    servicos?: ServicoListRelationFilter
  }, "id">

  export type FornecedorOrderByWithAggregationInput = {
    id?: SortOrder
    avaliacaoTotal?: SortOrder
    _count?: FornecedorCountOrderByAggregateInput
    _avg?: FornecedorAvgOrderByAggregateInput
    _max?: FornecedorMaxOrderByAggregateInput
    _min?: FornecedorMinOrderByAggregateInput
    _sum?: FornecedorSumOrderByAggregateInput
  }

  export type FornecedorScalarWhereWithAggregatesInput = {
    AND?: FornecedorScalarWhereWithAggregatesInput | FornecedorScalarWhereWithAggregatesInput[]
    OR?: FornecedorScalarWhereWithAggregatesInput[]
    NOT?: FornecedorScalarWhereWithAggregatesInput | FornecedorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Fornecedor"> | number
    avaliacaoTotal?: FloatWithAggregatesFilter<"Fornecedor"> | number
  }

  export type DadosBancariosWhereInput = {
    AND?: DadosBancariosWhereInput | DadosBancariosWhereInput[]
    OR?: DadosBancariosWhereInput[]
    NOT?: DadosBancariosWhereInput | DadosBancariosWhereInput[]
    id?: IntFilter<"DadosBancarios"> | number
    idBanco?: StringFilter<"DadosBancarios"> | string
    numAgencia?: StringFilter<"DadosBancarios"> | string
    tipoConta?: StringFilter<"DadosBancarios"> | string
    fornecedorId?: IntFilter<"DadosBancarios"> | number
    fornecedor?: XOR<FornecedorScalarRelationFilter, FornecedorWhereInput>
  }

  export type DadosBancariosOrderByWithRelationInput = {
    id?: SortOrder
    idBanco?: SortOrder
    numAgencia?: SortOrder
    tipoConta?: SortOrder
    fornecedorId?: SortOrder
    fornecedor?: FornecedorOrderByWithRelationInput
  }

  export type DadosBancariosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    fornecedorId?: number
    AND?: DadosBancariosWhereInput | DadosBancariosWhereInput[]
    OR?: DadosBancariosWhereInput[]
    NOT?: DadosBancariosWhereInput | DadosBancariosWhereInput[]
    idBanco?: StringFilter<"DadosBancarios"> | string
    numAgencia?: StringFilter<"DadosBancarios"> | string
    tipoConta?: StringFilter<"DadosBancarios"> | string
    fornecedor?: XOR<FornecedorScalarRelationFilter, FornecedorWhereInput>
  }, "id" | "fornecedorId">

  export type DadosBancariosOrderByWithAggregationInput = {
    id?: SortOrder
    idBanco?: SortOrder
    numAgencia?: SortOrder
    tipoConta?: SortOrder
    fornecedorId?: SortOrder
    _count?: DadosBancariosCountOrderByAggregateInput
    _avg?: DadosBancariosAvgOrderByAggregateInput
    _max?: DadosBancariosMaxOrderByAggregateInput
    _min?: DadosBancariosMinOrderByAggregateInput
    _sum?: DadosBancariosSumOrderByAggregateInput
  }

  export type DadosBancariosScalarWhereWithAggregatesInput = {
    AND?: DadosBancariosScalarWhereWithAggregatesInput | DadosBancariosScalarWhereWithAggregatesInput[]
    OR?: DadosBancariosScalarWhereWithAggregatesInput[]
    NOT?: DadosBancariosScalarWhereWithAggregatesInput | DadosBancariosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DadosBancarios"> | number
    idBanco?: StringWithAggregatesFilter<"DadosBancarios"> | string
    numAgencia?: StringWithAggregatesFilter<"DadosBancarios"> | string
    tipoConta?: StringWithAggregatesFilter<"DadosBancarios"> | string
    fornecedorId?: IntWithAggregatesFilter<"DadosBancarios"> | number
  }

  export type CupomWhereInput = {
    AND?: CupomWhereInput | CupomWhereInput[]
    OR?: CupomWhereInput[]
    NOT?: CupomWhereInput | CupomWhereInput[]
    id?: IntFilter<"Cupom"> | number
    nome?: StringFilter<"Cupom"> | string
    dataValidade?: DateTimeFilter<"Cupom"> | Date | string
    desconto?: FloatFilter<"Cupom"> | number
    clienteId?: IntFilter<"Cupom"> | number
    cliente?: XOR<ClienteScalarRelationFilter, ClienteWhereInput>
  }

  export type CupomOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    dataValidade?: SortOrder
    desconto?: SortOrder
    clienteId?: SortOrder
    cliente?: ClienteOrderByWithRelationInput
  }

  export type CupomWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CupomWhereInput | CupomWhereInput[]
    OR?: CupomWhereInput[]
    NOT?: CupomWhereInput | CupomWhereInput[]
    nome?: StringFilter<"Cupom"> | string
    dataValidade?: DateTimeFilter<"Cupom"> | Date | string
    desconto?: FloatFilter<"Cupom"> | number
    clienteId?: IntFilter<"Cupom"> | number
    cliente?: XOR<ClienteScalarRelationFilter, ClienteWhereInput>
  }, "id">

  export type CupomOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    dataValidade?: SortOrder
    desconto?: SortOrder
    clienteId?: SortOrder
    _count?: CupomCountOrderByAggregateInput
    _avg?: CupomAvgOrderByAggregateInput
    _max?: CupomMaxOrderByAggregateInput
    _min?: CupomMinOrderByAggregateInput
    _sum?: CupomSumOrderByAggregateInput
  }

  export type CupomScalarWhereWithAggregatesInput = {
    AND?: CupomScalarWhereWithAggregatesInput | CupomScalarWhereWithAggregatesInput[]
    OR?: CupomScalarWhereWithAggregatesInput[]
    NOT?: CupomScalarWhereWithAggregatesInput | CupomScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Cupom"> | number
    nome?: StringWithAggregatesFilter<"Cupom"> | string
    dataValidade?: DateTimeWithAggregatesFilter<"Cupom"> | Date | string
    desconto?: FloatWithAggregatesFilter<"Cupom"> | number
    clienteId?: IntWithAggregatesFilter<"Cupom"> | number
  }

  export type CarrinhoComprasWhereInput = {
    AND?: CarrinhoComprasWhereInput | CarrinhoComprasWhereInput[]
    OR?: CarrinhoComprasWhereInput[]
    NOT?: CarrinhoComprasWhereInput | CarrinhoComprasWhereInput[]
    id?: IntFilter<"CarrinhoCompras"> | number
    clienteId?: IntFilter<"CarrinhoCompras"> | number
    cliente?: XOR<ClienteScalarRelationFilter, ClienteWhereInput>
    items?: ItemListRelationFilter
  }

  export type CarrinhoComprasOrderByWithRelationInput = {
    id?: SortOrder
    clienteId?: SortOrder
    cliente?: ClienteOrderByWithRelationInput
    items?: ItemOrderByRelationAggregateInput
  }

  export type CarrinhoComprasWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    clienteId?: number
    AND?: CarrinhoComprasWhereInput | CarrinhoComprasWhereInput[]
    OR?: CarrinhoComprasWhereInput[]
    NOT?: CarrinhoComprasWhereInput | CarrinhoComprasWhereInput[]
    cliente?: XOR<ClienteScalarRelationFilter, ClienteWhereInput>
    items?: ItemListRelationFilter
  }, "id" | "clienteId">

  export type CarrinhoComprasOrderByWithAggregationInput = {
    id?: SortOrder
    clienteId?: SortOrder
    _count?: CarrinhoComprasCountOrderByAggregateInput
    _avg?: CarrinhoComprasAvgOrderByAggregateInput
    _max?: CarrinhoComprasMaxOrderByAggregateInput
    _min?: CarrinhoComprasMinOrderByAggregateInput
    _sum?: CarrinhoComprasSumOrderByAggregateInput
  }

  export type CarrinhoComprasScalarWhereWithAggregatesInput = {
    AND?: CarrinhoComprasScalarWhereWithAggregatesInput | CarrinhoComprasScalarWhereWithAggregatesInput[]
    OR?: CarrinhoComprasScalarWhereWithAggregatesInput[]
    NOT?: CarrinhoComprasScalarWhereWithAggregatesInput | CarrinhoComprasScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CarrinhoCompras"> | number
    clienteId?: IntWithAggregatesFilter<"CarrinhoCompras"> | number
  }

  export type ItemWhereInput = {
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    id?: IntFilter<"Item"> | number
    nome?: StringFilter<"Item"> | string
    valor?: FloatFilter<"Item"> | number
    carrinhoId?: IntFilter<"Item"> | number
    produtoId?: IntNullableFilter<"Item"> | number | null
    servicoId?: IntNullableFilter<"Item"> | number | null
    carrinho?: XOR<CarrinhoComprasScalarRelationFilter, CarrinhoComprasWhereInput>
    produto?: XOR<ProdutoNullableScalarRelationFilter, ProdutoWhereInput> | null
    servico?: XOR<ServicoNullableScalarRelationFilter, ServicoWhereInput> | null
  }

  export type ItemOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    valor?: SortOrder
    carrinhoId?: SortOrder
    produtoId?: SortOrderInput | SortOrder
    servicoId?: SortOrderInput | SortOrder
    carrinho?: CarrinhoComprasOrderByWithRelationInput
    produto?: ProdutoOrderByWithRelationInput
    servico?: ServicoOrderByWithRelationInput
  }

  export type ItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    produtoId?: number
    servicoId?: number
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    nome?: StringFilter<"Item"> | string
    valor?: FloatFilter<"Item"> | number
    carrinhoId?: IntFilter<"Item"> | number
    carrinho?: XOR<CarrinhoComprasScalarRelationFilter, CarrinhoComprasWhereInput>
    produto?: XOR<ProdutoNullableScalarRelationFilter, ProdutoWhereInput> | null
    servico?: XOR<ServicoNullableScalarRelationFilter, ServicoWhereInput> | null
  }, "id" | "produtoId" | "servicoId">

  export type ItemOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    valor?: SortOrder
    carrinhoId?: SortOrder
    produtoId?: SortOrderInput | SortOrder
    servicoId?: SortOrderInput | SortOrder
    _count?: ItemCountOrderByAggregateInput
    _avg?: ItemAvgOrderByAggregateInput
    _max?: ItemMaxOrderByAggregateInput
    _min?: ItemMinOrderByAggregateInput
    _sum?: ItemSumOrderByAggregateInput
  }

  export type ItemScalarWhereWithAggregatesInput = {
    AND?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    OR?: ItemScalarWhereWithAggregatesInput[]
    NOT?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Item"> | number
    nome?: StringWithAggregatesFilter<"Item"> | string
    valor?: FloatWithAggregatesFilter<"Item"> | number
    carrinhoId?: IntWithAggregatesFilter<"Item"> | number
    produtoId?: IntNullableWithAggregatesFilter<"Item"> | number | null
    servicoId?: IntNullableWithAggregatesFilter<"Item"> | number | null
  }

  export type ProdutoWhereInput = {
    AND?: ProdutoWhereInput | ProdutoWhereInput[]
    OR?: ProdutoWhereInput[]
    NOT?: ProdutoWhereInput | ProdutoWhereInput[]
    id?: IntFilter<"Produto"> | number
    nome?: StringFilter<"Produto"> | string
    valor?: FloatFilter<"Produto"> | number
    quantidade?: FloatFilter<"Produto"> | number
    fornecedorId?: IntFilter<"Produto"> | number
    fornecedor?: XOR<FornecedorScalarRelationFilter, FornecedorWhereInput>
    item?: XOR<ItemNullableScalarRelationFilter, ItemWhereInput> | null
  }

  export type ProdutoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    valor?: SortOrder
    quantidade?: SortOrder
    fornecedorId?: SortOrder
    fornecedor?: FornecedorOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
  }

  export type ProdutoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProdutoWhereInput | ProdutoWhereInput[]
    OR?: ProdutoWhereInput[]
    NOT?: ProdutoWhereInput | ProdutoWhereInput[]
    nome?: StringFilter<"Produto"> | string
    valor?: FloatFilter<"Produto"> | number
    quantidade?: FloatFilter<"Produto"> | number
    fornecedorId?: IntFilter<"Produto"> | number
    fornecedor?: XOR<FornecedorScalarRelationFilter, FornecedorWhereInput>
    item?: XOR<ItemNullableScalarRelationFilter, ItemWhereInput> | null
  }, "id">

  export type ProdutoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    valor?: SortOrder
    quantidade?: SortOrder
    fornecedorId?: SortOrder
    _count?: ProdutoCountOrderByAggregateInput
    _avg?: ProdutoAvgOrderByAggregateInput
    _max?: ProdutoMaxOrderByAggregateInput
    _min?: ProdutoMinOrderByAggregateInput
    _sum?: ProdutoSumOrderByAggregateInput
  }

  export type ProdutoScalarWhereWithAggregatesInput = {
    AND?: ProdutoScalarWhereWithAggregatesInput | ProdutoScalarWhereWithAggregatesInput[]
    OR?: ProdutoScalarWhereWithAggregatesInput[]
    NOT?: ProdutoScalarWhereWithAggregatesInput | ProdutoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Produto"> | number
    nome?: StringWithAggregatesFilter<"Produto"> | string
    valor?: FloatWithAggregatesFilter<"Produto"> | number
    quantidade?: FloatWithAggregatesFilter<"Produto"> | number
    fornecedorId?: IntWithAggregatesFilter<"Produto"> | number
  }

  export type ServicoWhereInput = {
    AND?: ServicoWhereInput | ServicoWhereInput[]
    OR?: ServicoWhereInput[]
    NOT?: ServicoWhereInput | ServicoWhereInput[]
    id?: IntFilter<"Servico"> | number
    nome?: StringFilter<"Servico"> | string
    valor?: FloatFilter<"Servico"> | number
    dataAgendada?: DateTimeFilter<"Servico"> | Date | string
    fornecedorId?: IntFilter<"Servico"> | number
    fornecedor?: XOR<FornecedorScalarRelationFilter, FornecedorWhereInput>
    item?: XOR<ItemNullableScalarRelationFilter, ItemWhereInput> | null
  }

  export type ServicoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    valor?: SortOrder
    dataAgendada?: SortOrder
    fornecedorId?: SortOrder
    fornecedor?: FornecedorOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
  }

  export type ServicoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ServicoWhereInput | ServicoWhereInput[]
    OR?: ServicoWhereInput[]
    NOT?: ServicoWhereInput | ServicoWhereInput[]
    nome?: StringFilter<"Servico"> | string
    valor?: FloatFilter<"Servico"> | number
    dataAgendada?: DateTimeFilter<"Servico"> | Date | string
    fornecedorId?: IntFilter<"Servico"> | number
    fornecedor?: XOR<FornecedorScalarRelationFilter, FornecedorWhereInput>
    item?: XOR<ItemNullableScalarRelationFilter, ItemWhereInput> | null
  }, "id">

  export type ServicoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    valor?: SortOrder
    dataAgendada?: SortOrder
    fornecedorId?: SortOrder
    _count?: ServicoCountOrderByAggregateInput
    _avg?: ServicoAvgOrderByAggregateInput
    _max?: ServicoMaxOrderByAggregateInput
    _min?: ServicoMinOrderByAggregateInput
    _sum?: ServicoSumOrderByAggregateInput
  }

  export type ServicoScalarWhereWithAggregatesInput = {
    AND?: ServicoScalarWhereWithAggregatesInput | ServicoScalarWhereWithAggregatesInput[]
    OR?: ServicoScalarWhereWithAggregatesInput[]
    NOT?: ServicoScalarWhereWithAggregatesInput | ServicoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Servico"> | number
    nome?: StringWithAggregatesFilter<"Servico"> | string
    valor?: FloatWithAggregatesFilter<"Servico"> | number
    dataAgendada?: DateTimeWithAggregatesFilter<"Servico"> | Date | string
    fornecedorId?: IntWithAggregatesFilter<"Servico"> | number
  }

  export type AvaliacaoWhereInput = {
    AND?: AvaliacaoWhereInput | AvaliacaoWhereInput[]
    OR?: AvaliacaoWhereInput[]
    NOT?: AvaliacaoWhereInput | AvaliacaoWhereInput[]
    id?: IntFilter<"Avaliacao"> | number
    nota?: FloatFilter<"Avaliacao"> | number
    fornecedorId?: IntFilter<"Avaliacao"> | number
    fornecedor?: XOR<FornecedorScalarRelationFilter, FornecedorWhereInput>
  }

  export type AvaliacaoOrderByWithRelationInput = {
    id?: SortOrder
    nota?: SortOrder
    fornecedorId?: SortOrder
    fornecedor?: FornecedorOrderByWithRelationInput
  }

  export type AvaliacaoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AvaliacaoWhereInput | AvaliacaoWhereInput[]
    OR?: AvaliacaoWhereInput[]
    NOT?: AvaliacaoWhereInput | AvaliacaoWhereInput[]
    nota?: FloatFilter<"Avaliacao"> | number
    fornecedorId?: IntFilter<"Avaliacao"> | number
    fornecedor?: XOR<FornecedorScalarRelationFilter, FornecedorWhereInput>
  }, "id">

  export type AvaliacaoOrderByWithAggregationInput = {
    id?: SortOrder
    nota?: SortOrder
    fornecedorId?: SortOrder
    _count?: AvaliacaoCountOrderByAggregateInput
    _avg?: AvaliacaoAvgOrderByAggregateInput
    _max?: AvaliacaoMaxOrderByAggregateInput
    _min?: AvaliacaoMinOrderByAggregateInput
    _sum?: AvaliacaoSumOrderByAggregateInput
  }

  export type AvaliacaoScalarWhereWithAggregatesInput = {
    AND?: AvaliacaoScalarWhereWithAggregatesInput | AvaliacaoScalarWhereWithAggregatesInput[]
    OR?: AvaliacaoScalarWhereWithAggregatesInput[]
    NOT?: AvaliacaoScalarWhereWithAggregatesInput | AvaliacaoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Avaliacao"> | number
    nota?: FloatWithAggregatesFilter<"Avaliacao"> | number
    fornecedorId?: IntWithAggregatesFilter<"Avaliacao"> | number
  }

  export type UsuarioCreateInput = {
    nome: string
    email: string
    senha: string
    imagemPerfil?: string | null
    tipo: string
    endereco?: EnderecoCreateNestedOneWithoutUsuarioInput
    cartoes?: CartaoCreateNestedManyWithoutUsuarioInput
    cliente?: ClienteCreateNestedOneWithoutUsuarioInput
    fornecedor?: FornecedorCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateInput = {
    id?: number
    nome: string
    email: string
    senha: string
    imagemPerfil?: string | null
    tipo: string
    endereco?: EnderecoUncheckedCreateNestedOneWithoutUsuarioInput
    cartoes?: CartaoUncheckedCreateNestedManyWithoutUsuarioInput
    cliente?: ClienteUncheckedCreateNestedOneWithoutUsuarioInput
    fornecedor?: FornecedorUncheckedCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    imagemPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    endereco?: EnderecoUpdateOneWithoutUsuarioNestedInput
    cartoes?: CartaoUpdateManyWithoutUsuarioNestedInput
    cliente?: ClienteUpdateOneWithoutUsuarioNestedInput
    fornecedor?: FornecedorUpdateOneWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    imagemPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    endereco?: EnderecoUncheckedUpdateOneWithoutUsuarioNestedInput
    cartoes?: CartaoUncheckedUpdateManyWithoutUsuarioNestedInput
    cliente?: ClienteUncheckedUpdateOneWithoutUsuarioNestedInput
    fornecedor?: FornecedorUncheckedUpdateOneWithoutUsuarioNestedInput
  }

  export type UsuarioCreateManyInput = {
    id?: number
    nome: string
    email: string
    senha: string
    imagemPerfil?: string | null
    tipo: string
  }

  export type UsuarioUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    imagemPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    imagemPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
  }

  export type EnderecoCreateInput = {
    rua: string
    bairro: string
    cep: string
    numero: string
    complemento: string
    usuario: UsuarioCreateNestedOneWithoutEnderecoInput
  }

  export type EnderecoUncheckedCreateInput = {
    id?: number
    rua: string
    bairro: string
    cep: string
    numero: string
    complemento: string
    usuarioId: number
  }

  export type EnderecoUpdateInput = {
    rua?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    cep?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    complemento?: StringFieldUpdateOperationsInput | string
    usuario?: UsuarioUpdateOneRequiredWithoutEnderecoNestedInput
  }

  export type EnderecoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rua?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    cep?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    complemento?: StringFieldUpdateOperationsInput | string
    usuarioId?: IntFieldUpdateOperationsInput | number
  }

  export type EnderecoCreateManyInput = {
    id?: number
    rua: string
    bairro: string
    cep: string
    numero: string
    complemento: string
    usuarioId: number
  }

  export type EnderecoUpdateManyMutationInput = {
    rua?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    cep?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    complemento?: StringFieldUpdateOperationsInput | string
  }

  export type EnderecoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rua?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    cep?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    complemento?: StringFieldUpdateOperationsInput | string
    usuarioId?: IntFieldUpdateOperationsInput | number
  }

  export type CartaoCreateInput = {
    tipoCartao: $Enums.TipoCartao
    numeroCartao: string
    cvc: number
    nomeCartao: string
    dataValidade: Date | string
    usuario: UsuarioCreateNestedOneWithoutCartoesInput
  }

  export type CartaoUncheckedCreateInput = {
    id?: number
    tipoCartao: $Enums.TipoCartao
    numeroCartao: string
    cvc: number
    nomeCartao: string
    dataValidade: Date | string
    usuarioId: number
  }

  export type CartaoUpdateInput = {
    tipoCartao?: EnumTipoCartaoFieldUpdateOperationsInput | $Enums.TipoCartao
    numeroCartao?: StringFieldUpdateOperationsInput | string
    cvc?: IntFieldUpdateOperationsInput | number
    nomeCartao?: StringFieldUpdateOperationsInput | string
    dataValidade?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutCartoesNestedInput
  }

  export type CartaoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoCartao?: EnumTipoCartaoFieldUpdateOperationsInput | $Enums.TipoCartao
    numeroCartao?: StringFieldUpdateOperationsInput | string
    cvc?: IntFieldUpdateOperationsInput | number
    nomeCartao?: StringFieldUpdateOperationsInput | string
    dataValidade?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioId?: IntFieldUpdateOperationsInput | number
  }

  export type CartaoCreateManyInput = {
    id?: number
    tipoCartao: $Enums.TipoCartao
    numeroCartao: string
    cvc: number
    nomeCartao: string
    dataValidade: Date | string
    usuarioId: number
  }

  export type CartaoUpdateManyMutationInput = {
    tipoCartao?: EnumTipoCartaoFieldUpdateOperationsInput | $Enums.TipoCartao
    numeroCartao?: StringFieldUpdateOperationsInput | string
    cvc?: IntFieldUpdateOperationsInput | number
    nomeCartao?: StringFieldUpdateOperationsInput | string
    dataValidade?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartaoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoCartao?: EnumTipoCartaoFieldUpdateOperationsInput | $Enums.TipoCartao
    numeroCartao?: StringFieldUpdateOperationsInput | string
    cvc?: IntFieldUpdateOperationsInput | number
    nomeCartao?: StringFieldUpdateOperationsInput | string
    dataValidade?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioId?: IntFieldUpdateOperationsInput | number
  }

  export type ClienteCreateInput = {
    usuario: UsuarioCreateNestedOneWithoutClienteInput
    cupons?: CupomCreateNestedManyWithoutClienteInput
    carrinho?: CarrinhoComprasCreateNestedOneWithoutClienteInput
  }

  export type ClienteUncheckedCreateInput = {
    id: number
    cupons?: CupomUncheckedCreateNestedManyWithoutClienteInput
    carrinho?: CarrinhoComprasUncheckedCreateNestedOneWithoutClienteInput
  }

  export type ClienteUpdateInput = {
    usuario?: UsuarioUpdateOneRequiredWithoutClienteNestedInput
    cupons?: CupomUpdateManyWithoutClienteNestedInput
    carrinho?: CarrinhoComprasUpdateOneWithoutClienteNestedInput
  }

  export type ClienteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cupons?: CupomUncheckedUpdateManyWithoutClienteNestedInput
    carrinho?: CarrinhoComprasUncheckedUpdateOneWithoutClienteNestedInput
  }

  export type ClienteCreateManyInput = {
    id: number
  }

  export type ClienteUpdateManyMutationInput = {

  }

  export type ClienteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type FornecedorCreateInput = {
    avaliacaoTotal: number
    usuario: UsuarioCreateNestedOneWithoutFornecedorInput
    avaliacoes?: AvaliacaoCreateNestedManyWithoutFornecedorInput
    dadosBancarios?: DadosBancariosCreateNestedOneWithoutFornecedorInput
    produtos?: ProdutoCreateNestedManyWithoutFornecedorInput
    servicos?: ServicoCreateNestedManyWithoutFornecedorInput
  }

  export type FornecedorUncheckedCreateInput = {
    id: number
    avaliacaoTotal: number
    avaliacoes?: AvaliacaoUncheckedCreateNestedManyWithoutFornecedorInput
    dadosBancarios?: DadosBancariosUncheckedCreateNestedOneWithoutFornecedorInput
    produtos?: ProdutoUncheckedCreateNestedManyWithoutFornecedorInput
    servicos?: ServicoUncheckedCreateNestedManyWithoutFornecedorInput
  }

  export type FornecedorUpdateInput = {
    avaliacaoTotal?: FloatFieldUpdateOperationsInput | number
    usuario?: UsuarioUpdateOneRequiredWithoutFornecedorNestedInput
    avaliacoes?: AvaliacaoUpdateManyWithoutFornecedorNestedInput
    dadosBancarios?: DadosBancariosUpdateOneWithoutFornecedorNestedInput
    produtos?: ProdutoUpdateManyWithoutFornecedorNestedInput
    servicos?: ServicoUpdateManyWithoutFornecedorNestedInput
  }

  export type FornecedorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    avaliacaoTotal?: FloatFieldUpdateOperationsInput | number
    avaliacoes?: AvaliacaoUncheckedUpdateManyWithoutFornecedorNestedInput
    dadosBancarios?: DadosBancariosUncheckedUpdateOneWithoutFornecedorNestedInput
    produtos?: ProdutoUncheckedUpdateManyWithoutFornecedorNestedInput
    servicos?: ServicoUncheckedUpdateManyWithoutFornecedorNestedInput
  }

  export type FornecedorCreateManyInput = {
    id: number
    avaliacaoTotal: number
  }

  export type FornecedorUpdateManyMutationInput = {
    avaliacaoTotal?: FloatFieldUpdateOperationsInput | number
  }

  export type FornecedorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    avaliacaoTotal?: FloatFieldUpdateOperationsInput | number
  }

  export type DadosBancariosCreateInput = {
    idBanco: string
    numAgencia: string
    tipoConta: string
    fornecedor: FornecedorCreateNestedOneWithoutDadosBancariosInput
  }

  export type DadosBancariosUncheckedCreateInput = {
    id?: number
    idBanco: string
    numAgencia: string
    tipoConta: string
    fornecedorId: number
  }

  export type DadosBancariosUpdateInput = {
    idBanco?: StringFieldUpdateOperationsInput | string
    numAgencia?: StringFieldUpdateOperationsInput | string
    tipoConta?: StringFieldUpdateOperationsInput | string
    fornecedor?: FornecedorUpdateOneRequiredWithoutDadosBancariosNestedInput
  }

  export type DadosBancariosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idBanco?: StringFieldUpdateOperationsInput | string
    numAgencia?: StringFieldUpdateOperationsInput | string
    tipoConta?: StringFieldUpdateOperationsInput | string
    fornecedorId?: IntFieldUpdateOperationsInput | number
  }

  export type DadosBancariosCreateManyInput = {
    id?: number
    idBanco: string
    numAgencia: string
    tipoConta: string
    fornecedorId: number
  }

  export type DadosBancariosUpdateManyMutationInput = {
    idBanco?: StringFieldUpdateOperationsInput | string
    numAgencia?: StringFieldUpdateOperationsInput | string
    tipoConta?: StringFieldUpdateOperationsInput | string
  }

  export type DadosBancariosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idBanco?: StringFieldUpdateOperationsInput | string
    numAgencia?: StringFieldUpdateOperationsInput | string
    tipoConta?: StringFieldUpdateOperationsInput | string
    fornecedorId?: IntFieldUpdateOperationsInput | number
  }

  export type CupomCreateInput = {
    nome: string
    dataValidade: Date | string
    desconto: number
    cliente: ClienteCreateNestedOneWithoutCuponsInput
  }

  export type CupomUncheckedCreateInput = {
    id?: number
    nome: string
    dataValidade: Date | string
    desconto: number
    clienteId: number
  }

  export type CupomUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    dataValidade?: DateTimeFieldUpdateOperationsInput | Date | string
    desconto?: FloatFieldUpdateOperationsInput | number
    cliente?: ClienteUpdateOneRequiredWithoutCuponsNestedInput
  }

  export type CupomUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    dataValidade?: DateTimeFieldUpdateOperationsInput | Date | string
    desconto?: FloatFieldUpdateOperationsInput | number
    clienteId?: IntFieldUpdateOperationsInput | number
  }

  export type CupomCreateManyInput = {
    id?: number
    nome: string
    dataValidade: Date | string
    desconto: number
    clienteId: number
  }

  export type CupomUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    dataValidade?: DateTimeFieldUpdateOperationsInput | Date | string
    desconto?: FloatFieldUpdateOperationsInput | number
  }

  export type CupomUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    dataValidade?: DateTimeFieldUpdateOperationsInput | Date | string
    desconto?: FloatFieldUpdateOperationsInput | number
    clienteId?: IntFieldUpdateOperationsInput | number
  }

  export type CarrinhoComprasCreateInput = {
    cliente: ClienteCreateNestedOneWithoutCarrinhoInput
    items?: ItemCreateNestedManyWithoutCarrinhoInput
  }

  export type CarrinhoComprasUncheckedCreateInput = {
    id?: number
    clienteId: number
    items?: ItemUncheckedCreateNestedManyWithoutCarrinhoInput
  }

  export type CarrinhoComprasUpdateInput = {
    cliente?: ClienteUpdateOneRequiredWithoutCarrinhoNestedInput
    items?: ItemUpdateManyWithoutCarrinhoNestedInput
  }

  export type CarrinhoComprasUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    clienteId?: IntFieldUpdateOperationsInput | number
    items?: ItemUncheckedUpdateManyWithoutCarrinhoNestedInput
  }

  export type CarrinhoComprasCreateManyInput = {
    id?: number
    clienteId: number
  }

  export type CarrinhoComprasUpdateManyMutationInput = {

  }

  export type CarrinhoComprasUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    clienteId?: IntFieldUpdateOperationsInput | number
  }

  export type ItemCreateInput = {
    nome: string
    valor: number
    carrinho: CarrinhoComprasCreateNestedOneWithoutItemsInput
    produto?: ProdutoCreateNestedOneWithoutItemInput
    servico?: ServicoCreateNestedOneWithoutItemInput
  }

  export type ItemUncheckedCreateInput = {
    id?: number
    nome: string
    valor: number
    carrinhoId: number
    produtoId?: number | null
    servicoId?: number | null
  }

  export type ItemUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    carrinho?: CarrinhoComprasUpdateOneRequiredWithoutItemsNestedInput
    produto?: ProdutoUpdateOneWithoutItemNestedInput
    servico?: ServicoUpdateOneWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    carrinhoId?: IntFieldUpdateOperationsInput | number
    produtoId?: NullableIntFieldUpdateOperationsInput | number | null
    servicoId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ItemCreateManyInput = {
    id?: number
    nome: string
    valor: number
    carrinhoId: number
    produtoId?: number | null
    servicoId?: number | null
  }

  export type ItemUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
  }

  export type ItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    carrinhoId?: IntFieldUpdateOperationsInput | number
    produtoId?: NullableIntFieldUpdateOperationsInput | number | null
    servicoId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProdutoCreateInput = {
    nome: string
    valor: number
    quantidade: number
    fornecedor: FornecedorCreateNestedOneWithoutProdutosInput
    item?: ItemCreateNestedOneWithoutProdutoInput
  }

  export type ProdutoUncheckedCreateInput = {
    id?: number
    nome: string
    valor: number
    quantidade: number
    fornecedorId: number
    item?: ItemUncheckedCreateNestedOneWithoutProdutoInput
  }

  export type ProdutoUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    quantidade?: FloatFieldUpdateOperationsInput | number
    fornecedor?: FornecedorUpdateOneRequiredWithoutProdutosNestedInput
    item?: ItemUpdateOneWithoutProdutoNestedInput
  }

  export type ProdutoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    quantidade?: FloatFieldUpdateOperationsInput | number
    fornecedorId?: IntFieldUpdateOperationsInput | number
    item?: ItemUncheckedUpdateOneWithoutProdutoNestedInput
  }

  export type ProdutoCreateManyInput = {
    id?: number
    nome: string
    valor: number
    quantidade: number
    fornecedorId: number
  }

  export type ProdutoUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    quantidade?: FloatFieldUpdateOperationsInput | number
  }

  export type ProdutoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    quantidade?: FloatFieldUpdateOperationsInput | number
    fornecedorId?: IntFieldUpdateOperationsInput | number
  }

  export type ServicoCreateInput = {
    nome: string
    valor: number
    dataAgendada: Date | string
    fornecedor: FornecedorCreateNestedOneWithoutServicosInput
    item?: ItemCreateNestedOneWithoutServicoInput
  }

  export type ServicoUncheckedCreateInput = {
    id?: number
    nome: string
    valor: number
    dataAgendada: Date | string
    fornecedorId: number
    item?: ItemUncheckedCreateNestedOneWithoutServicoInput
  }

  export type ServicoUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    dataAgendada?: DateTimeFieldUpdateOperationsInput | Date | string
    fornecedor?: FornecedorUpdateOneRequiredWithoutServicosNestedInput
    item?: ItemUpdateOneWithoutServicoNestedInput
  }

  export type ServicoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    dataAgendada?: DateTimeFieldUpdateOperationsInput | Date | string
    fornecedorId?: IntFieldUpdateOperationsInput | number
    item?: ItemUncheckedUpdateOneWithoutServicoNestedInput
  }

  export type ServicoCreateManyInput = {
    id?: number
    nome: string
    valor: number
    dataAgendada: Date | string
    fornecedorId: number
  }

  export type ServicoUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    dataAgendada?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    dataAgendada?: DateTimeFieldUpdateOperationsInput | Date | string
    fornecedorId?: IntFieldUpdateOperationsInput | number
  }

  export type AvaliacaoCreateInput = {
    nota: number
    fornecedor: FornecedorCreateNestedOneWithoutAvaliacoesInput
  }

  export type AvaliacaoUncheckedCreateInput = {
    id?: number
    nota: number
    fornecedorId: number
  }

  export type AvaliacaoUpdateInput = {
    nota?: FloatFieldUpdateOperationsInput | number
    fornecedor?: FornecedorUpdateOneRequiredWithoutAvaliacoesNestedInput
  }

  export type AvaliacaoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nota?: FloatFieldUpdateOperationsInput | number
    fornecedorId?: IntFieldUpdateOperationsInput | number
  }

  export type AvaliacaoCreateManyInput = {
    id?: number
    nota: number
    fornecedorId: number
  }

  export type AvaliacaoUpdateManyMutationInput = {
    nota?: FloatFieldUpdateOperationsInput | number
  }

  export type AvaliacaoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nota?: FloatFieldUpdateOperationsInput | number
    fornecedorId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnderecoNullableScalarRelationFilter = {
    is?: EnderecoWhereInput | null
    isNot?: EnderecoWhereInput | null
  }

  export type CartaoListRelationFilter = {
    every?: CartaoWhereInput
    some?: CartaoWhereInput
    none?: CartaoWhereInput
  }

  export type ClienteNullableScalarRelationFilter = {
    is?: ClienteWhereInput | null
    isNot?: ClienteWhereInput | null
  }

  export type FornecedorNullableScalarRelationFilter = {
    is?: FornecedorWhereInput | null
    isNot?: FornecedorWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CartaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    imagemPerfil?: SortOrder
    tipo?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    imagemPerfil?: SortOrder
    tipo?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    imagemPerfil?: SortOrder
    tipo?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type UsuarioScalarRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type EnderecoCountOrderByAggregateInput = {
    id?: SortOrder
    rua?: SortOrder
    bairro?: SortOrder
    cep?: SortOrder
    numero?: SortOrder
    complemento?: SortOrder
    usuarioId?: SortOrder
  }

  export type EnderecoAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type EnderecoMaxOrderByAggregateInput = {
    id?: SortOrder
    rua?: SortOrder
    bairro?: SortOrder
    cep?: SortOrder
    numero?: SortOrder
    complemento?: SortOrder
    usuarioId?: SortOrder
  }

  export type EnderecoMinOrderByAggregateInput = {
    id?: SortOrder
    rua?: SortOrder
    bairro?: SortOrder
    cep?: SortOrder
    numero?: SortOrder
    complemento?: SortOrder
    usuarioId?: SortOrder
  }

  export type EnderecoSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type EnumTipoCartaoFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoCartao | EnumTipoCartaoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoCartao[] | ListEnumTipoCartaoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoCartao[] | ListEnumTipoCartaoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoCartaoFilter<$PrismaModel> | $Enums.TipoCartao
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CartaoCountOrderByAggregateInput = {
    id?: SortOrder
    tipoCartao?: SortOrder
    numeroCartao?: SortOrder
    cvc?: SortOrder
    nomeCartao?: SortOrder
    dataValidade?: SortOrder
    usuarioId?: SortOrder
  }

  export type CartaoAvgOrderByAggregateInput = {
    id?: SortOrder
    cvc?: SortOrder
    usuarioId?: SortOrder
  }

  export type CartaoMaxOrderByAggregateInput = {
    id?: SortOrder
    tipoCartao?: SortOrder
    numeroCartao?: SortOrder
    cvc?: SortOrder
    nomeCartao?: SortOrder
    dataValidade?: SortOrder
    usuarioId?: SortOrder
  }

  export type CartaoMinOrderByAggregateInput = {
    id?: SortOrder
    tipoCartao?: SortOrder
    numeroCartao?: SortOrder
    cvc?: SortOrder
    nomeCartao?: SortOrder
    dataValidade?: SortOrder
    usuarioId?: SortOrder
  }

  export type CartaoSumOrderByAggregateInput = {
    id?: SortOrder
    cvc?: SortOrder
    usuarioId?: SortOrder
  }

  export type EnumTipoCartaoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoCartao | EnumTipoCartaoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoCartao[] | ListEnumTipoCartaoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoCartao[] | ListEnumTipoCartaoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoCartaoWithAggregatesFilter<$PrismaModel> | $Enums.TipoCartao
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoCartaoFilter<$PrismaModel>
    _max?: NestedEnumTipoCartaoFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type CupomListRelationFilter = {
    every?: CupomWhereInput
    some?: CupomWhereInput
    none?: CupomWhereInput
  }

  export type CarrinhoComprasNullableScalarRelationFilter = {
    is?: CarrinhoComprasWhereInput | null
    isNot?: CarrinhoComprasWhereInput | null
  }

  export type CupomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClienteCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ClienteAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ClienteMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ClienteMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ClienteSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type AvaliacaoListRelationFilter = {
    every?: AvaliacaoWhereInput
    some?: AvaliacaoWhereInput
    none?: AvaliacaoWhereInput
  }

  export type DadosBancariosNullableScalarRelationFilter = {
    is?: DadosBancariosWhereInput | null
    isNot?: DadosBancariosWhereInput | null
  }

  export type ProdutoListRelationFilter = {
    every?: ProdutoWhereInput
    some?: ProdutoWhereInput
    none?: ProdutoWhereInput
  }

  export type ServicoListRelationFilter = {
    every?: ServicoWhereInput
    some?: ServicoWhereInput
    none?: ServicoWhereInput
  }

  export type AvaliacaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProdutoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServicoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FornecedorCountOrderByAggregateInput = {
    id?: SortOrder
    avaliacaoTotal?: SortOrder
  }

  export type FornecedorAvgOrderByAggregateInput = {
    id?: SortOrder
    avaliacaoTotal?: SortOrder
  }

  export type FornecedorMaxOrderByAggregateInput = {
    id?: SortOrder
    avaliacaoTotal?: SortOrder
  }

  export type FornecedorMinOrderByAggregateInput = {
    id?: SortOrder
    avaliacaoTotal?: SortOrder
  }

  export type FornecedorSumOrderByAggregateInput = {
    id?: SortOrder
    avaliacaoTotal?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FornecedorScalarRelationFilter = {
    is?: FornecedorWhereInput
    isNot?: FornecedorWhereInput
  }

  export type DadosBancariosCountOrderByAggregateInput = {
    id?: SortOrder
    idBanco?: SortOrder
    numAgencia?: SortOrder
    tipoConta?: SortOrder
    fornecedorId?: SortOrder
  }

  export type DadosBancariosAvgOrderByAggregateInput = {
    id?: SortOrder
    fornecedorId?: SortOrder
  }

  export type DadosBancariosMaxOrderByAggregateInput = {
    id?: SortOrder
    idBanco?: SortOrder
    numAgencia?: SortOrder
    tipoConta?: SortOrder
    fornecedorId?: SortOrder
  }

  export type DadosBancariosMinOrderByAggregateInput = {
    id?: SortOrder
    idBanco?: SortOrder
    numAgencia?: SortOrder
    tipoConta?: SortOrder
    fornecedorId?: SortOrder
  }

  export type DadosBancariosSumOrderByAggregateInput = {
    id?: SortOrder
    fornecedorId?: SortOrder
  }

  export type ClienteScalarRelationFilter = {
    is?: ClienteWhereInput
    isNot?: ClienteWhereInput
  }

  export type CupomCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    dataValidade?: SortOrder
    desconto?: SortOrder
    clienteId?: SortOrder
  }

  export type CupomAvgOrderByAggregateInput = {
    id?: SortOrder
    desconto?: SortOrder
    clienteId?: SortOrder
  }

  export type CupomMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    dataValidade?: SortOrder
    desconto?: SortOrder
    clienteId?: SortOrder
  }

  export type CupomMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    dataValidade?: SortOrder
    desconto?: SortOrder
    clienteId?: SortOrder
  }

  export type CupomSumOrderByAggregateInput = {
    id?: SortOrder
    desconto?: SortOrder
    clienteId?: SortOrder
  }

  export type ItemListRelationFilter = {
    every?: ItemWhereInput
    some?: ItemWhereInput
    none?: ItemWhereInput
  }

  export type ItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CarrinhoComprasCountOrderByAggregateInput = {
    id?: SortOrder
    clienteId?: SortOrder
  }

  export type CarrinhoComprasAvgOrderByAggregateInput = {
    id?: SortOrder
    clienteId?: SortOrder
  }

  export type CarrinhoComprasMaxOrderByAggregateInput = {
    id?: SortOrder
    clienteId?: SortOrder
  }

  export type CarrinhoComprasMinOrderByAggregateInput = {
    id?: SortOrder
    clienteId?: SortOrder
  }

  export type CarrinhoComprasSumOrderByAggregateInput = {
    id?: SortOrder
    clienteId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CarrinhoComprasScalarRelationFilter = {
    is?: CarrinhoComprasWhereInput
    isNot?: CarrinhoComprasWhereInput
  }

  export type ProdutoNullableScalarRelationFilter = {
    is?: ProdutoWhereInput | null
    isNot?: ProdutoWhereInput | null
  }

  export type ServicoNullableScalarRelationFilter = {
    is?: ServicoWhereInput | null
    isNot?: ServicoWhereInput | null
  }

  export type ItemCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    valor?: SortOrder
    carrinhoId?: SortOrder
    produtoId?: SortOrder
    servicoId?: SortOrder
  }

  export type ItemAvgOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    carrinhoId?: SortOrder
    produtoId?: SortOrder
    servicoId?: SortOrder
  }

  export type ItemMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    valor?: SortOrder
    carrinhoId?: SortOrder
    produtoId?: SortOrder
    servicoId?: SortOrder
  }

  export type ItemMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    valor?: SortOrder
    carrinhoId?: SortOrder
    produtoId?: SortOrder
    servicoId?: SortOrder
  }

  export type ItemSumOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    carrinhoId?: SortOrder
    produtoId?: SortOrder
    servicoId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ItemNullableScalarRelationFilter = {
    is?: ItemWhereInput | null
    isNot?: ItemWhereInput | null
  }

  export type ProdutoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    valor?: SortOrder
    quantidade?: SortOrder
    fornecedorId?: SortOrder
  }

  export type ProdutoAvgOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    quantidade?: SortOrder
    fornecedorId?: SortOrder
  }

  export type ProdutoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    valor?: SortOrder
    quantidade?: SortOrder
    fornecedorId?: SortOrder
  }

  export type ProdutoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    valor?: SortOrder
    quantidade?: SortOrder
    fornecedorId?: SortOrder
  }

  export type ProdutoSumOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    quantidade?: SortOrder
    fornecedorId?: SortOrder
  }

  export type ServicoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    valor?: SortOrder
    dataAgendada?: SortOrder
    fornecedorId?: SortOrder
  }

  export type ServicoAvgOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    fornecedorId?: SortOrder
  }

  export type ServicoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    valor?: SortOrder
    dataAgendada?: SortOrder
    fornecedorId?: SortOrder
  }

  export type ServicoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    valor?: SortOrder
    dataAgendada?: SortOrder
    fornecedorId?: SortOrder
  }

  export type ServicoSumOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    fornecedorId?: SortOrder
  }

  export type AvaliacaoCountOrderByAggregateInput = {
    id?: SortOrder
    nota?: SortOrder
    fornecedorId?: SortOrder
  }

  export type AvaliacaoAvgOrderByAggregateInput = {
    id?: SortOrder
    nota?: SortOrder
    fornecedorId?: SortOrder
  }

  export type AvaliacaoMaxOrderByAggregateInput = {
    id?: SortOrder
    nota?: SortOrder
    fornecedorId?: SortOrder
  }

  export type AvaliacaoMinOrderByAggregateInput = {
    id?: SortOrder
    nota?: SortOrder
    fornecedorId?: SortOrder
  }

  export type AvaliacaoSumOrderByAggregateInput = {
    id?: SortOrder
    nota?: SortOrder
    fornecedorId?: SortOrder
  }

  export type EnderecoCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<EnderecoCreateWithoutUsuarioInput, EnderecoUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: EnderecoCreateOrConnectWithoutUsuarioInput
    connect?: EnderecoWhereUniqueInput
  }

  export type CartaoCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<CartaoCreateWithoutUsuarioInput, CartaoUncheckedCreateWithoutUsuarioInput> | CartaoCreateWithoutUsuarioInput[] | CartaoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: CartaoCreateOrConnectWithoutUsuarioInput | CartaoCreateOrConnectWithoutUsuarioInput[]
    createMany?: CartaoCreateManyUsuarioInputEnvelope
    connect?: CartaoWhereUniqueInput | CartaoWhereUniqueInput[]
  }

  export type ClienteCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<ClienteCreateWithoutUsuarioInput, ClienteUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutUsuarioInput
    connect?: ClienteWhereUniqueInput
  }

  export type FornecedorCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<FornecedorCreateWithoutUsuarioInput, FornecedorUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: FornecedorCreateOrConnectWithoutUsuarioInput
    connect?: FornecedorWhereUniqueInput
  }

  export type EnderecoUncheckedCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<EnderecoCreateWithoutUsuarioInput, EnderecoUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: EnderecoCreateOrConnectWithoutUsuarioInput
    connect?: EnderecoWhereUniqueInput
  }

  export type CartaoUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<CartaoCreateWithoutUsuarioInput, CartaoUncheckedCreateWithoutUsuarioInput> | CartaoCreateWithoutUsuarioInput[] | CartaoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: CartaoCreateOrConnectWithoutUsuarioInput | CartaoCreateOrConnectWithoutUsuarioInput[]
    createMany?: CartaoCreateManyUsuarioInputEnvelope
    connect?: CartaoWhereUniqueInput | CartaoWhereUniqueInput[]
  }

  export type ClienteUncheckedCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<ClienteCreateWithoutUsuarioInput, ClienteUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutUsuarioInput
    connect?: ClienteWhereUniqueInput
  }

  export type FornecedorUncheckedCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<FornecedorCreateWithoutUsuarioInput, FornecedorUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: FornecedorCreateOrConnectWithoutUsuarioInput
    connect?: FornecedorWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnderecoUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<EnderecoCreateWithoutUsuarioInput, EnderecoUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: EnderecoCreateOrConnectWithoutUsuarioInput
    upsert?: EnderecoUpsertWithoutUsuarioInput
    disconnect?: EnderecoWhereInput | boolean
    delete?: EnderecoWhereInput | boolean
    connect?: EnderecoWhereUniqueInput
    update?: XOR<XOR<EnderecoUpdateToOneWithWhereWithoutUsuarioInput, EnderecoUpdateWithoutUsuarioInput>, EnderecoUncheckedUpdateWithoutUsuarioInput>
  }

  export type CartaoUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<CartaoCreateWithoutUsuarioInput, CartaoUncheckedCreateWithoutUsuarioInput> | CartaoCreateWithoutUsuarioInput[] | CartaoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: CartaoCreateOrConnectWithoutUsuarioInput | CartaoCreateOrConnectWithoutUsuarioInput[]
    upsert?: CartaoUpsertWithWhereUniqueWithoutUsuarioInput | CartaoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: CartaoCreateManyUsuarioInputEnvelope
    set?: CartaoWhereUniqueInput | CartaoWhereUniqueInput[]
    disconnect?: CartaoWhereUniqueInput | CartaoWhereUniqueInput[]
    delete?: CartaoWhereUniqueInput | CartaoWhereUniqueInput[]
    connect?: CartaoWhereUniqueInput | CartaoWhereUniqueInput[]
    update?: CartaoUpdateWithWhereUniqueWithoutUsuarioInput | CartaoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: CartaoUpdateManyWithWhereWithoutUsuarioInput | CartaoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: CartaoScalarWhereInput | CartaoScalarWhereInput[]
  }

  export type ClienteUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<ClienteCreateWithoutUsuarioInput, ClienteUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutUsuarioInput
    upsert?: ClienteUpsertWithoutUsuarioInput
    disconnect?: ClienteWhereInput | boolean
    delete?: ClienteWhereInput | boolean
    connect?: ClienteWhereUniqueInput
    update?: XOR<XOR<ClienteUpdateToOneWithWhereWithoutUsuarioInput, ClienteUpdateWithoutUsuarioInput>, ClienteUncheckedUpdateWithoutUsuarioInput>
  }

  export type FornecedorUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<FornecedorCreateWithoutUsuarioInput, FornecedorUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: FornecedorCreateOrConnectWithoutUsuarioInput
    upsert?: FornecedorUpsertWithoutUsuarioInput
    disconnect?: FornecedorWhereInput | boolean
    delete?: FornecedorWhereInput | boolean
    connect?: FornecedorWhereUniqueInput
    update?: XOR<XOR<FornecedorUpdateToOneWithWhereWithoutUsuarioInput, FornecedorUpdateWithoutUsuarioInput>, FornecedorUncheckedUpdateWithoutUsuarioInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnderecoUncheckedUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<EnderecoCreateWithoutUsuarioInput, EnderecoUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: EnderecoCreateOrConnectWithoutUsuarioInput
    upsert?: EnderecoUpsertWithoutUsuarioInput
    disconnect?: EnderecoWhereInput | boolean
    delete?: EnderecoWhereInput | boolean
    connect?: EnderecoWhereUniqueInput
    update?: XOR<XOR<EnderecoUpdateToOneWithWhereWithoutUsuarioInput, EnderecoUpdateWithoutUsuarioInput>, EnderecoUncheckedUpdateWithoutUsuarioInput>
  }

  export type CartaoUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<CartaoCreateWithoutUsuarioInput, CartaoUncheckedCreateWithoutUsuarioInput> | CartaoCreateWithoutUsuarioInput[] | CartaoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: CartaoCreateOrConnectWithoutUsuarioInput | CartaoCreateOrConnectWithoutUsuarioInput[]
    upsert?: CartaoUpsertWithWhereUniqueWithoutUsuarioInput | CartaoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: CartaoCreateManyUsuarioInputEnvelope
    set?: CartaoWhereUniqueInput | CartaoWhereUniqueInput[]
    disconnect?: CartaoWhereUniqueInput | CartaoWhereUniqueInput[]
    delete?: CartaoWhereUniqueInput | CartaoWhereUniqueInput[]
    connect?: CartaoWhereUniqueInput | CartaoWhereUniqueInput[]
    update?: CartaoUpdateWithWhereUniqueWithoutUsuarioInput | CartaoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: CartaoUpdateManyWithWhereWithoutUsuarioInput | CartaoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: CartaoScalarWhereInput | CartaoScalarWhereInput[]
  }

  export type ClienteUncheckedUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<ClienteCreateWithoutUsuarioInput, ClienteUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutUsuarioInput
    upsert?: ClienteUpsertWithoutUsuarioInput
    disconnect?: ClienteWhereInput | boolean
    delete?: ClienteWhereInput | boolean
    connect?: ClienteWhereUniqueInput
    update?: XOR<XOR<ClienteUpdateToOneWithWhereWithoutUsuarioInput, ClienteUpdateWithoutUsuarioInput>, ClienteUncheckedUpdateWithoutUsuarioInput>
  }

  export type FornecedorUncheckedUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<FornecedorCreateWithoutUsuarioInput, FornecedorUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: FornecedorCreateOrConnectWithoutUsuarioInput
    upsert?: FornecedorUpsertWithoutUsuarioInput
    disconnect?: FornecedorWhereInput | boolean
    delete?: FornecedorWhereInput | boolean
    connect?: FornecedorWhereUniqueInput
    update?: XOR<XOR<FornecedorUpdateToOneWithWhereWithoutUsuarioInput, FornecedorUpdateWithoutUsuarioInput>, FornecedorUncheckedUpdateWithoutUsuarioInput>
  }

  export type UsuarioCreateNestedOneWithoutEnderecoInput = {
    create?: XOR<UsuarioCreateWithoutEnderecoInput, UsuarioUncheckedCreateWithoutEnderecoInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutEnderecoInput
    connect?: UsuarioWhereUniqueInput
  }

  export type UsuarioUpdateOneRequiredWithoutEnderecoNestedInput = {
    create?: XOR<UsuarioCreateWithoutEnderecoInput, UsuarioUncheckedCreateWithoutEnderecoInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutEnderecoInput
    upsert?: UsuarioUpsertWithoutEnderecoInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutEnderecoInput, UsuarioUpdateWithoutEnderecoInput>, UsuarioUncheckedUpdateWithoutEnderecoInput>
  }

  export type UsuarioCreateNestedOneWithoutCartoesInput = {
    create?: XOR<UsuarioCreateWithoutCartoesInput, UsuarioUncheckedCreateWithoutCartoesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutCartoesInput
    connect?: UsuarioWhereUniqueInput
  }

  export type EnumTipoCartaoFieldUpdateOperationsInput = {
    set?: $Enums.TipoCartao
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UsuarioUpdateOneRequiredWithoutCartoesNestedInput = {
    create?: XOR<UsuarioCreateWithoutCartoesInput, UsuarioUncheckedCreateWithoutCartoesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutCartoesInput
    upsert?: UsuarioUpsertWithoutCartoesInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutCartoesInput, UsuarioUpdateWithoutCartoesInput>, UsuarioUncheckedUpdateWithoutCartoesInput>
  }

  export type UsuarioCreateNestedOneWithoutClienteInput = {
    create?: XOR<UsuarioCreateWithoutClienteInput, UsuarioUncheckedCreateWithoutClienteInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutClienteInput
    connect?: UsuarioWhereUniqueInput
  }

  export type CupomCreateNestedManyWithoutClienteInput = {
    create?: XOR<CupomCreateWithoutClienteInput, CupomUncheckedCreateWithoutClienteInput> | CupomCreateWithoutClienteInput[] | CupomUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: CupomCreateOrConnectWithoutClienteInput | CupomCreateOrConnectWithoutClienteInput[]
    createMany?: CupomCreateManyClienteInputEnvelope
    connect?: CupomWhereUniqueInput | CupomWhereUniqueInput[]
  }

  export type CarrinhoComprasCreateNestedOneWithoutClienteInput = {
    create?: XOR<CarrinhoComprasCreateWithoutClienteInput, CarrinhoComprasUncheckedCreateWithoutClienteInput>
    connectOrCreate?: CarrinhoComprasCreateOrConnectWithoutClienteInput
    connect?: CarrinhoComprasWhereUniqueInput
  }

  export type CupomUncheckedCreateNestedManyWithoutClienteInput = {
    create?: XOR<CupomCreateWithoutClienteInput, CupomUncheckedCreateWithoutClienteInput> | CupomCreateWithoutClienteInput[] | CupomUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: CupomCreateOrConnectWithoutClienteInput | CupomCreateOrConnectWithoutClienteInput[]
    createMany?: CupomCreateManyClienteInputEnvelope
    connect?: CupomWhereUniqueInput | CupomWhereUniqueInput[]
  }

  export type CarrinhoComprasUncheckedCreateNestedOneWithoutClienteInput = {
    create?: XOR<CarrinhoComprasCreateWithoutClienteInput, CarrinhoComprasUncheckedCreateWithoutClienteInput>
    connectOrCreate?: CarrinhoComprasCreateOrConnectWithoutClienteInput
    connect?: CarrinhoComprasWhereUniqueInput
  }

  export type UsuarioUpdateOneRequiredWithoutClienteNestedInput = {
    create?: XOR<UsuarioCreateWithoutClienteInput, UsuarioUncheckedCreateWithoutClienteInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutClienteInput
    upsert?: UsuarioUpsertWithoutClienteInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutClienteInput, UsuarioUpdateWithoutClienteInput>, UsuarioUncheckedUpdateWithoutClienteInput>
  }

  export type CupomUpdateManyWithoutClienteNestedInput = {
    create?: XOR<CupomCreateWithoutClienteInput, CupomUncheckedCreateWithoutClienteInput> | CupomCreateWithoutClienteInput[] | CupomUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: CupomCreateOrConnectWithoutClienteInput | CupomCreateOrConnectWithoutClienteInput[]
    upsert?: CupomUpsertWithWhereUniqueWithoutClienteInput | CupomUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: CupomCreateManyClienteInputEnvelope
    set?: CupomWhereUniqueInput | CupomWhereUniqueInput[]
    disconnect?: CupomWhereUniqueInput | CupomWhereUniqueInput[]
    delete?: CupomWhereUniqueInput | CupomWhereUniqueInput[]
    connect?: CupomWhereUniqueInput | CupomWhereUniqueInput[]
    update?: CupomUpdateWithWhereUniqueWithoutClienteInput | CupomUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: CupomUpdateManyWithWhereWithoutClienteInput | CupomUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: CupomScalarWhereInput | CupomScalarWhereInput[]
  }

  export type CarrinhoComprasUpdateOneWithoutClienteNestedInput = {
    create?: XOR<CarrinhoComprasCreateWithoutClienteInput, CarrinhoComprasUncheckedCreateWithoutClienteInput>
    connectOrCreate?: CarrinhoComprasCreateOrConnectWithoutClienteInput
    upsert?: CarrinhoComprasUpsertWithoutClienteInput
    disconnect?: CarrinhoComprasWhereInput | boolean
    delete?: CarrinhoComprasWhereInput | boolean
    connect?: CarrinhoComprasWhereUniqueInput
    update?: XOR<XOR<CarrinhoComprasUpdateToOneWithWhereWithoutClienteInput, CarrinhoComprasUpdateWithoutClienteInput>, CarrinhoComprasUncheckedUpdateWithoutClienteInput>
  }

  export type CupomUncheckedUpdateManyWithoutClienteNestedInput = {
    create?: XOR<CupomCreateWithoutClienteInput, CupomUncheckedCreateWithoutClienteInput> | CupomCreateWithoutClienteInput[] | CupomUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: CupomCreateOrConnectWithoutClienteInput | CupomCreateOrConnectWithoutClienteInput[]
    upsert?: CupomUpsertWithWhereUniqueWithoutClienteInput | CupomUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: CupomCreateManyClienteInputEnvelope
    set?: CupomWhereUniqueInput | CupomWhereUniqueInput[]
    disconnect?: CupomWhereUniqueInput | CupomWhereUniqueInput[]
    delete?: CupomWhereUniqueInput | CupomWhereUniqueInput[]
    connect?: CupomWhereUniqueInput | CupomWhereUniqueInput[]
    update?: CupomUpdateWithWhereUniqueWithoutClienteInput | CupomUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: CupomUpdateManyWithWhereWithoutClienteInput | CupomUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: CupomScalarWhereInput | CupomScalarWhereInput[]
  }

  export type CarrinhoComprasUncheckedUpdateOneWithoutClienteNestedInput = {
    create?: XOR<CarrinhoComprasCreateWithoutClienteInput, CarrinhoComprasUncheckedCreateWithoutClienteInput>
    connectOrCreate?: CarrinhoComprasCreateOrConnectWithoutClienteInput
    upsert?: CarrinhoComprasUpsertWithoutClienteInput
    disconnect?: CarrinhoComprasWhereInput | boolean
    delete?: CarrinhoComprasWhereInput | boolean
    connect?: CarrinhoComprasWhereUniqueInput
    update?: XOR<XOR<CarrinhoComprasUpdateToOneWithWhereWithoutClienteInput, CarrinhoComprasUpdateWithoutClienteInput>, CarrinhoComprasUncheckedUpdateWithoutClienteInput>
  }

  export type UsuarioCreateNestedOneWithoutFornecedorInput = {
    create?: XOR<UsuarioCreateWithoutFornecedorInput, UsuarioUncheckedCreateWithoutFornecedorInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutFornecedorInput
    connect?: UsuarioWhereUniqueInput
  }

  export type AvaliacaoCreateNestedManyWithoutFornecedorInput = {
    create?: XOR<AvaliacaoCreateWithoutFornecedorInput, AvaliacaoUncheckedCreateWithoutFornecedorInput> | AvaliacaoCreateWithoutFornecedorInput[] | AvaliacaoUncheckedCreateWithoutFornecedorInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutFornecedorInput | AvaliacaoCreateOrConnectWithoutFornecedorInput[]
    createMany?: AvaliacaoCreateManyFornecedorInputEnvelope
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
  }

  export type DadosBancariosCreateNestedOneWithoutFornecedorInput = {
    create?: XOR<DadosBancariosCreateWithoutFornecedorInput, DadosBancariosUncheckedCreateWithoutFornecedorInput>
    connectOrCreate?: DadosBancariosCreateOrConnectWithoutFornecedorInput
    connect?: DadosBancariosWhereUniqueInput
  }

  export type ProdutoCreateNestedManyWithoutFornecedorInput = {
    create?: XOR<ProdutoCreateWithoutFornecedorInput, ProdutoUncheckedCreateWithoutFornecedorInput> | ProdutoCreateWithoutFornecedorInput[] | ProdutoUncheckedCreateWithoutFornecedorInput[]
    connectOrCreate?: ProdutoCreateOrConnectWithoutFornecedorInput | ProdutoCreateOrConnectWithoutFornecedorInput[]
    createMany?: ProdutoCreateManyFornecedorInputEnvelope
    connect?: ProdutoWhereUniqueInput | ProdutoWhereUniqueInput[]
  }

  export type ServicoCreateNestedManyWithoutFornecedorInput = {
    create?: XOR<ServicoCreateWithoutFornecedorInput, ServicoUncheckedCreateWithoutFornecedorInput> | ServicoCreateWithoutFornecedorInput[] | ServicoUncheckedCreateWithoutFornecedorInput[]
    connectOrCreate?: ServicoCreateOrConnectWithoutFornecedorInput | ServicoCreateOrConnectWithoutFornecedorInput[]
    createMany?: ServicoCreateManyFornecedorInputEnvelope
    connect?: ServicoWhereUniqueInput | ServicoWhereUniqueInput[]
  }

  export type AvaliacaoUncheckedCreateNestedManyWithoutFornecedorInput = {
    create?: XOR<AvaliacaoCreateWithoutFornecedorInput, AvaliacaoUncheckedCreateWithoutFornecedorInput> | AvaliacaoCreateWithoutFornecedorInput[] | AvaliacaoUncheckedCreateWithoutFornecedorInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutFornecedorInput | AvaliacaoCreateOrConnectWithoutFornecedorInput[]
    createMany?: AvaliacaoCreateManyFornecedorInputEnvelope
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
  }

  export type DadosBancariosUncheckedCreateNestedOneWithoutFornecedorInput = {
    create?: XOR<DadosBancariosCreateWithoutFornecedorInput, DadosBancariosUncheckedCreateWithoutFornecedorInput>
    connectOrCreate?: DadosBancariosCreateOrConnectWithoutFornecedorInput
    connect?: DadosBancariosWhereUniqueInput
  }

  export type ProdutoUncheckedCreateNestedManyWithoutFornecedorInput = {
    create?: XOR<ProdutoCreateWithoutFornecedorInput, ProdutoUncheckedCreateWithoutFornecedorInput> | ProdutoCreateWithoutFornecedorInput[] | ProdutoUncheckedCreateWithoutFornecedorInput[]
    connectOrCreate?: ProdutoCreateOrConnectWithoutFornecedorInput | ProdutoCreateOrConnectWithoutFornecedorInput[]
    createMany?: ProdutoCreateManyFornecedorInputEnvelope
    connect?: ProdutoWhereUniqueInput | ProdutoWhereUniqueInput[]
  }

  export type ServicoUncheckedCreateNestedManyWithoutFornecedorInput = {
    create?: XOR<ServicoCreateWithoutFornecedorInput, ServicoUncheckedCreateWithoutFornecedorInput> | ServicoCreateWithoutFornecedorInput[] | ServicoUncheckedCreateWithoutFornecedorInput[]
    connectOrCreate?: ServicoCreateOrConnectWithoutFornecedorInput | ServicoCreateOrConnectWithoutFornecedorInput[]
    createMany?: ServicoCreateManyFornecedorInputEnvelope
    connect?: ServicoWhereUniqueInput | ServicoWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UsuarioUpdateOneRequiredWithoutFornecedorNestedInput = {
    create?: XOR<UsuarioCreateWithoutFornecedorInput, UsuarioUncheckedCreateWithoutFornecedorInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutFornecedorInput
    upsert?: UsuarioUpsertWithoutFornecedorInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutFornecedorInput, UsuarioUpdateWithoutFornecedorInput>, UsuarioUncheckedUpdateWithoutFornecedorInput>
  }

  export type AvaliacaoUpdateManyWithoutFornecedorNestedInput = {
    create?: XOR<AvaliacaoCreateWithoutFornecedorInput, AvaliacaoUncheckedCreateWithoutFornecedorInput> | AvaliacaoCreateWithoutFornecedorInput[] | AvaliacaoUncheckedCreateWithoutFornecedorInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutFornecedorInput | AvaliacaoCreateOrConnectWithoutFornecedorInput[]
    upsert?: AvaliacaoUpsertWithWhereUniqueWithoutFornecedorInput | AvaliacaoUpsertWithWhereUniqueWithoutFornecedorInput[]
    createMany?: AvaliacaoCreateManyFornecedorInputEnvelope
    set?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    disconnect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    delete?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    update?: AvaliacaoUpdateWithWhereUniqueWithoutFornecedorInput | AvaliacaoUpdateWithWhereUniqueWithoutFornecedorInput[]
    updateMany?: AvaliacaoUpdateManyWithWhereWithoutFornecedorInput | AvaliacaoUpdateManyWithWhereWithoutFornecedorInput[]
    deleteMany?: AvaliacaoScalarWhereInput | AvaliacaoScalarWhereInput[]
  }

  export type DadosBancariosUpdateOneWithoutFornecedorNestedInput = {
    create?: XOR<DadosBancariosCreateWithoutFornecedorInput, DadosBancariosUncheckedCreateWithoutFornecedorInput>
    connectOrCreate?: DadosBancariosCreateOrConnectWithoutFornecedorInput
    upsert?: DadosBancariosUpsertWithoutFornecedorInput
    disconnect?: DadosBancariosWhereInput | boolean
    delete?: DadosBancariosWhereInput | boolean
    connect?: DadosBancariosWhereUniqueInput
    update?: XOR<XOR<DadosBancariosUpdateToOneWithWhereWithoutFornecedorInput, DadosBancariosUpdateWithoutFornecedorInput>, DadosBancariosUncheckedUpdateWithoutFornecedorInput>
  }

  export type ProdutoUpdateManyWithoutFornecedorNestedInput = {
    create?: XOR<ProdutoCreateWithoutFornecedorInput, ProdutoUncheckedCreateWithoutFornecedorInput> | ProdutoCreateWithoutFornecedorInput[] | ProdutoUncheckedCreateWithoutFornecedorInput[]
    connectOrCreate?: ProdutoCreateOrConnectWithoutFornecedorInput | ProdutoCreateOrConnectWithoutFornecedorInput[]
    upsert?: ProdutoUpsertWithWhereUniqueWithoutFornecedorInput | ProdutoUpsertWithWhereUniqueWithoutFornecedorInput[]
    createMany?: ProdutoCreateManyFornecedorInputEnvelope
    set?: ProdutoWhereUniqueInput | ProdutoWhereUniqueInput[]
    disconnect?: ProdutoWhereUniqueInput | ProdutoWhereUniqueInput[]
    delete?: ProdutoWhereUniqueInput | ProdutoWhereUniqueInput[]
    connect?: ProdutoWhereUniqueInput | ProdutoWhereUniqueInput[]
    update?: ProdutoUpdateWithWhereUniqueWithoutFornecedorInput | ProdutoUpdateWithWhereUniqueWithoutFornecedorInput[]
    updateMany?: ProdutoUpdateManyWithWhereWithoutFornecedorInput | ProdutoUpdateManyWithWhereWithoutFornecedorInput[]
    deleteMany?: ProdutoScalarWhereInput | ProdutoScalarWhereInput[]
  }

  export type ServicoUpdateManyWithoutFornecedorNestedInput = {
    create?: XOR<ServicoCreateWithoutFornecedorInput, ServicoUncheckedCreateWithoutFornecedorInput> | ServicoCreateWithoutFornecedorInput[] | ServicoUncheckedCreateWithoutFornecedorInput[]
    connectOrCreate?: ServicoCreateOrConnectWithoutFornecedorInput | ServicoCreateOrConnectWithoutFornecedorInput[]
    upsert?: ServicoUpsertWithWhereUniqueWithoutFornecedorInput | ServicoUpsertWithWhereUniqueWithoutFornecedorInput[]
    createMany?: ServicoCreateManyFornecedorInputEnvelope
    set?: ServicoWhereUniqueInput | ServicoWhereUniqueInput[]
    disconnect?: ServicoWhereUniqueInput | ServicoWhereUniqueInput[]
    delete?: ServicoWhereUniqueInput | ServicoWhereUniqueInput[]
    connect?: ServicoWhereUniqueInput | ServicoWhereUniqueInput[]
    update?: ServicoUpdateWithWhereUniqueWithoutFornecedorInput | ServicoUpdateWithWhereUniqueWithoutFornecedorInput[]
    updateMany?: ServicoUpdateManyWithWhereWithoutFornecedorInput | ServicoUpdateManyWithWhereWithoutFornecedorInput[]
    deleteMany?: ServicoScalarWhereInput | ServicoScalarWhereInput[]
  }

  export type AvaliacaoUncheckedUpdateManyWithoutFornecedorNestedInput = {
    create?: XOR<AvaliacaoCreateWithoutFornecedorInput, AvaliacaoUncheckedCreateWithoutFornecedorInput> | AvaliacaoCreateWithoutFornecedorInput[] | AvaliacaoUncheckedCreateWithoutFornecedorInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutFornecedorInput | AvaliacaoCreateOrConnectWithoutFornecedorInput[]
    upsert?: AvaliacaoUpsertWithWhereUniqueWithoutFornecedorInput | AvaliacaoUpsertWithWhereUniqueWithoutFornecedorInput[]
    createMany?: AvaliacaoCreateManyFornecedorInputEnvelope
    set?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    disconnect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    delete?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    update?: AvaliacaoUpdateWithWhereUniqueWithoutFornecedorInput | AvaliacaoUpdateWithWhereUniqueWithoutFornecedorInput[]
    updateMany?: AvaliacaoUpdateManyWithWhereWithoutFornecedorInput | AvaliacaoUpdateManyWithWhereWithoutFornecedorInput[]
    deleteMany?: AvaliacaoScalarWhereInput | AvaliacaoScalarWhereInput[]
  }

  export type DadosBancariosUncheckedUpdateOneWithoutFornecedorNestedInput = {
    create?: XOR<DadosBancariosCreateWithoutFornecedorInput, DadosBancariosUncheckedCreateWithoutFornecedorInput>
    connectOrCreate?: DadosBancariosCreateOrConnectWithoutFornecedorInput
    upsert?: DadosBancariosUpsertWithoutFornecedorInput
    disconnect?: DadosBancariosWhereInput | boolean
    delete?: DadosBancariosWhereInput | boolean
    connect?: DadosBancariosWhereUniqueInput
    update?: XOR<XOR<DadosBancariosUpdateToOneWithWhereWithoutFornecedorInput, DadosBancariosUpdateWithoutFornecedorInput>, DadosBancariosUncheckedUpdateWithoutFornecedorInput>
  }

  export type ProdutoUncheckedUpdateManyWithoutFornecedorNestedInput = {
    create?: XOR<ProdutoCreateWithoutFornecedorInput, ProdutoUncheckedCreateWithoutFornecedorInput> | ProdutoCreateWithoutFornecedorInput[] | ProdutoUncheckedCreateWithoutFornecedorInput[]
    connectOrCreate?: ProdutoCreateOrConnectWithoutFornecedorInput | ProdutoCreateOrConnectWithoutFornecedorInput[]
    upsert?: ProdutoUpsertWithWhereUniqueWithoutFornecedorInput | ProdutoUpsertWithWhereUniqueWithoutFornecedorInput[]
    createMany?: ProdutoCreateManyFornecedorInputEnvelope
    set?: ProdutoWhereUniqueInput | ProdutoWhereUniqueInput[]
    disconnect?: ProdutoWhereUniqueInput | ProdutoWhereUniqueInput[]
    delete?: ProdutoWhereUniqueInput | ProdutoWhereUniqueInput[]
    connect?: ProdutoWhereUniqueInput | ProdutoWhereUniqueInput[]
    update?: ProdutoUpdateWithWhereUniqueWithoutFornecedorInput | ProdutoUpdateWithWhereUniqueWithoutFornecedorInput[]
    updateMany?: ProdutoUpdateManyWithWhereWithoutFornecedorInput | ProdutoUpdateManyWithWhereWithoutFornecedorInput[]
    deleteMany?: ProdutoScalarWhereInput | ProdutoScalarWhereInput[]
  }

  export type ServicoUncheckedUpdateManyWithoutFornecedorNestedInput = {
    create?: XOR<ServicoCreateWithoutFornecedorInput, ServicoUncheckedCreateWithoutFornecedorInput> | ServicoCreateWithoutFornecedorInput[] | ServicoUncheckedCreateWithoutFornecedorInput[]
    connectOrCreate?: ServicoCreateOrConnectWithoutFornecedorInput | ServicoCreateOrConnectWithoutFornecedorInput[]
    upsert?: ServicoUpsertWithWhereUniqueWithoutFornecedorInput | ServicoUpsertWithWhereUniqueWithoutFornecedorInput[]
    createMany?: ServicoCreateManyFornecedorInputEnvelope
    set?: ServicoWhereUniqueInput | ServicoWhereUniqueInput[]
    disconnect?: ServicoWhereUniqueInput | ServicoWhereUniqueInput[]
    delete?: ServicoWhereUniqueInput | ServicoWhereUniqueInput[]
    connect?: ServicoWhereUniqueInput | ServicoWhereUniqueInput[]
    update?: ServicoUpdateWithWhereUniqueWithoutFornecedorInput | ServicoUpdateWithWhereUniqueWithoutFornecedorInput[]
    updateMany?: ServicoUpdateManyWithWhereWithoutFornecedorInput | ServicoUpdateManyWithWhereWithoutFornecedorInput[]
    deleteMany?: ServicoScalarWhereInput | ServicoScalarWhereInput[]
  }

  export type FornecedorCreateNestedOneWithoutDadosBancariosInput = {
    create?: XOR<FornecedorCreateWithoutDadosBancariosInput, FornecedorUncheckedCreateWithoutDadosBancariosInput>
    connectOrCreate?: FornecedorCreateOrConnectWithoutDadosBancariosInput
    connect?: FornecedorWhereUniqueInput
  }

  export type FornecedorUpdateOneRequiredWithoutDadosBancariosNestedInput = {
    create?: XOR<FornecedorCreateWithoutDadosBancariosInput, FornecedorUncheckedCreateWithoutDadosBancariosInput>
    connectOrCreate?: FornecedorCreateOrConnectWithoutDadosBancariosInput
    upsert?: FornecedorUpsertWithoutDadosBancariosInput
    connect?: FornecedorWhereUniqueInput
    update?: XOR<XOR<FornecedorUpdateToOneWithWhereWithoutDadosBancariosInput, FornecedorUpdateWithoutDadosBancariosInput>, FornecedorUncheckedUpdateWithoutDadosBancariosInput>
  }

  export type ClienteCreateNestedOneWithoutCuponsInput = {
    create?: XOR<ClienteCreateWithoutCuponsInput, ClienteUncheckedCreateWithoutCuponsInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutCuponsInput
    connect?: ClienteWhereUniqueInput
  }

  export type ClienteUpdateOneRequiredWithoutCuponsNestedInput = {
    create?: XOR<ClienteCreateWithoutCuponsInput, ClienteUncheckedCreateWithoutCuponsInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutCuponsInput
    upsert?: ClienteUpsertWithoutCuponsInput
    connect?: ClienteWhereUniqueInput
    update?: XOR<XOR<ClienteUpdateToOneWithWhereWithoutCuponsInput, ClienteUpdateWithoutCuponsInput>, ClienteUncheckedUpdateWithoutCuponsInput>
  }

  export type ClienteCreateNestedOneWithoutCarrinhoInput = {
    create?: XOR<ClienteCreateWithoutCarrinhoInput, ClienteUncheckedCreateWithoutCarrinhoInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutCarrinhoInput
    connect?: ClienteWhereUniqueInput
  }

  export type ItemCreateNestedManyWithoutCarrinhoInput = {
    create?: XOR<ItemCreateWithoutCarrinhoInput, ItemUncheckedCreateWithoutCarrinhoInput> | ItemCreateWithoutCarrinhoInput[] | ItemUncheckedCreateWithoutCarrinhoInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutCarrinhoInput | ItemCreateOrConnectWithoutCarrinhoInput[]
    createMany?: ItemCreateManyCarrinhoInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type ItemUncheckedCreateNestedManyWithoutCarrinhoInput = {
    create?: XOR<ItemCreateWithoutCarrinhoInput, ItemUncheckedCreateWithoutCarrinhoInput> | ItemCreateWithoutCarrinhoInput[] | ItemUncheckedCreateWithoutCarrinhoInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutCarrinhoInput | ItemCreateOrConnectWithoutCarrinhoInput[]
    createMany?: ItemCreateManyCarrinhoInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type ClienteUpdateOneRequiredWithoutCarrinhoNestedInput = {
    create?: XOR<ClienteCreateWithoutCarrinhoInput, ClienteUncheckedCreateWithoutCarrinhoInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutCarrinhoInput
    upsert?: ClienteUpsertWithoutCarrinhoInput
    connect?: ClienteWhereUniqueInput
    update?: XOR<XOR<ClienteUpdateToOneWithWhereWithoutCarrinhoInput, ClienteUpdateWithoutCarrinhoInput>, ClienteUncheckedUpdateWithoutCarrinhoInput>
  }

  export type ItemUpdateManyWithoutCarrinhoNestedInput = {
    create?: XOR<ItemCreateWithoutCarrinhoInput, ItemUncheckedCreateWithoutCarrinhoInput> | ItemCreateWithoutCarrinhoInput[] | ItemUncheckedCreateWithoutCarrinhoInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutCarrinhoInput | ItemCreateOrConnectWithoutCarrinhoInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutCarrinhoInput | ItemUpsertWithWhereUniqueWithoutCarrinhoInput[]
    createMany?: ItemCreateManyCarrinhoInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutCarrinhoInput | ItemUpdateWithWhereUniqueWithoutCarrinhoInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutCarrinhoInput | ItemUpdateManyWithWhereWithoutCarrinhoInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type ItemUncheckedUpdateManyWithoutCarrinhoNestedInput = {
    create?: XOR<ItemCreateWithoutCarrinhoInput, ItemUncheckedCreateWithoutCarrinhoInput> | ItemCreateWithoutCarrinhoInput[] | ItemUncheckedCreateWithoutCarrinhoInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutCarrinhoInput | ItemCreateOrConnectWithoutCarrinhoInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutCarrinhoInput | ItemUpsertWithWhereUniqueWithoutCarrinhoInput[]
    createMany?: ItemCreateManyCarrinhoInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutCarrinhoInput | ItemUpdateWithWhereUniqueWithoutCarrinhoInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutCarrinhoInput | ItemUpdateManyWithWhereWithoutCarrinhoInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type CarrinhoComprasCreateNestedOneWithoutItemsInput = {
    create?: XOR<CarrinhoComprasCreateWithoutItemsInput, CarrinhoComprasUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CarrinhoComprasCreateOrConnectWithoutItemsInput
    connect?: CarrinhoComprasWhereUniqueInput
  }

  export type ProdutoCreateNestedOneWithoutItemInput = {
    create?: XOR<ProdutoCreateWithoutItemInput, ProdutoUncheckedCreateWithoutItemInput>
    connectOrCreate?: ProdutoCreateOrConnectWithoutItemInput
    connect?: ProdutoWhereUniqueInput
  }

  export type ServicoCreateNestedOneWithoutItemInput = {
    create?: XOR<ServicoCreateWithoutItemInput, ServicoUncheckedCreateWithoutItemInput>
    connectOrCreate?: ServicoCreateOrConnectWithoutItemInput
    connect?: ServicoWhereUniqueInput
  }

  export type CarrinhoComprasUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<CarrinhoComprasCreateWithoutItemsInput, CarrinhoComprasUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CarrinhoComprasCreateOrConnectWithoutItemsInput
    upsert?: CarrinhoComprasUpsertWithoutItemsInput
    connect?: CarrinhoComprasWhereUniqueInput
    update?: XOR<XOR<CarrinhoComprasUpdateToOneWithWhereWithoutItemsInput, CarrinhoComprasUpdateWithoutItemsInput>, CarrinhoComprasUncheckedUpdateWithoutItemsInput>
  }

  export type ProdutoUpdateOneWithoutItemNestedInput = {
    create?: XOR<ProdutoCreateWithoutItemInput, ProdutoUncheckedCreateWithoutItemInput>
    connectOrCreate?: ProdutoCreateOrConnectWithoutItemInput
    upsert?: ProdutoUpsertWithoutItemInput
    disconnect?: ProdutoWhereInput | boolean
    delete?: ProdutoWhereInput | boolean
    connect?: ProdutoWhereUniqueInput
    update?: XOR<XOR<ProdutoUpdateToOneWithWhereWithoutItemInput, ProdutoUpdateWithoutItemInput>, ProdutoUncheckedUpdateWithoutItemInput>
  }

  export type ServicoUpdateOneWithoutItemNestedInput = {
    create?: XOR<ServicoCreateWithoutItemInput, ServicoUncheckedCreateWithoutItemInput>
    connectOrCreate?: ServicoCreateOrConnectWithoutItemInput
    upsert?: ServicoUpsertWithoutItemInput
    disconnect?: ServicoWhereInput | boolean
    delete?: ServicoWhereInput | boolean
    connect?: ServicoWhereUniqueInput
    update?: XOR<XOR<ServicoUpdateToOneWithWhereWithoutItemInput, ServicoUpdateWithoutItemInput>, ServicoUncheckedUpdateWithoutItemInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FornecedorCreateNestedOneWithoutProdutosInput = {
    create?: XOR<FornecedorCreateWithoutProdutosInput, FornecedorUncheckedCreateWithoutProdutosInput>
    connectOrCreate?: FornecedorCreateOrConnectWithoutProdutosInput
    connect?: FornecedorWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutProdutoInput = {
    create?: XOR<ItemCreateWithoutProdutoInput, ItemUncheckedCreateWithoutProdutoInput>
    connectOrCreate?: ItemCreateOrConnectWithoutProdutoInput
    connect?: ItemWhereUniqueInput
  }

  export type ItemUncheckedCreateNestedOneWithoutProdutoInput = {
    create?: XOR<ItemCreateWithoutProdutoInput, ItemUncheckedCreateWithoutProdutoInput>
    connectOrCreate?: ItemCreateOrConnectWithoutProdutoInput
    connect?: ItemWhereUniqueInput
  }

  export type FornecedorUpdateOneRequiredWithoutProdutosNestedInput = {
    create?: XOR<FornecedorCreateWithoutProdutosInput, FornecedorUncheckedCreateWithoutProdutosInput>
    connectOrCreate?: FornecedorCreateOrConnectWithoutProdutosInput
    upsert?: FornecedorUpsertWithoutProdutosInput
    connect?: FornecedorWhereUniqueInput
    update?: XOR<XOR<FornecedorUpdateToOneWithWhereWithoutProdutosInput, FornecedorUpdateWithoutProdutosInput>, FornecedorUncheckedUpdateWithoutProdutosInput>
  }

  export type ItemUpdateOneWithoutProdutoNestedInput = {
    create?: XOR<ItemCreateWithoutProdutoInput, ItemUncheckedCreateWithoutProdutoInput>
    connectOrCreate?: ItemCreateOrConnectWithoutProdutoInput
    upsert?: ItemUpsertWithoutProdutoInput
    disconnect?: ItemWhereInput | boolean
    delete?: ItemWhereInput | boolean
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutProdutoInput, ItemUpdateWithoutProdutoInput>, ItemUncheckedUpdateWithoutProdutoInput>
  }

  export type ItemUncheckedUpdateOneWithoutProdutoNestedInput = {
    create?: XOR<ItemCreateWithoutProdutoInput, ItemUncheckedCreateWithoutProdutoInput>
    connectOrCreate?: ItemCreateOrConnectWithoutProdutoInput
    upsert?: ItemUpsertWithoutProdutoInput
    disconnect?: ItemWhereInput | boolean
    delete?: ItemWhereInput | boolean
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutProdutoInput, ItemUpdateWithoutProdutoInput>, ItemUncheckedUpdateWithoutProdutoInput>
  }

  export type FornecedorCreateNestedOneWithoutServicosInput = {
    create?: XOR<FornecedorCreateWithoutServicosInput, FornecedorUncheckedCreateWithoutServicosInput>
    connectOrCreate?: FornecedorCreateOrConnectWithoutServicosInput
    connect?: FornecedorWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutServicoInput = {
    create?: XOR<ItemCreateWithoutServicoInput, ItemUncheckedCreateWithoutServicoInput>
    connectOrCreate?: ItemCreateOrConnectWithoutServicoInput
    connect?: ItemWhereUniqueInput
  }

  export type ItemUncheckedCreateNestedOneWithoutServicoInput = {
    create?: XOR<ItemCreateWithoutServicoInput, ItemUncheckedCreateWithoutServicoInput>
    connectOrCreate?: ItemCreateOrConnectWithoutServicoInput
    connect?: ItemWhereUniqueInput
  }

  export type FornecedorUpdateOneRequiredWithoutServicosNestedInput = {
    create?: XOR<FornecedorCreateWithoutServicosInput, FornecedorUncheckedCreateWithoutServicosInput>
    connectOrCreate?: FornecedorCreateOrConnectWithoutServicosInput
    upsert?: FornecedorUpsertWithoutServicosInput
    connect?: FornecedorWhereUniqueInput
    update?: XOR<XOR<FornecedorUpdateToOneWithWhereWithoutServicosInput, FornecedorUpdateWithoutServicosInput>, FornecedorUncheckedUpdateWithoutServicosInput>
  }

  export type ItemUpdateOneWithoutServicoNestedInput = {
    create?: XOR<ItemCreateWithoutServicoInput, ItemUncheckedCreateWithoutServicoInput>
    connectOrCreate?: ItemCreateOrConnectWithoutServicoInput
    upsert?: ItemUpsertWithoutServicoInput
    disconnect?: ItemWhereInput | boolean
    delete?: ItemWhereInput | boolean
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutServicoInput, ItemUpdateWithoutServicoInput>, ItemUncheckedUpdateWithoutServicoInput>
  }

  export type ItemUncheckedUpdateOneWithoutServicoNestedInput = {
    create?: XOR<ItemCreateWithoutServicoInput, ItemUncheckedCreateWithoutServicoInput>
    connectOrCreate?: ItemCreateOrConnectWithoutServicoInput
    upsert?: ItemUpsertWithoutServicoInput
    disconnect?: ItemWhereInput | boolean
    delete?: ItemWhereInput | boolean
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutServicoInput, ItemUpdateWithoutServicoInput>, ItemUncheckedUpdateWithoutServicoInput>
  }

  export type FornecedorCreateNestedOneWithoutAvaliacoesInput = {
    create?: XOR<FornecedorCreateWithoutAvaliacoesInput, FornecedorUncheckedCreateWithoutAvaliacoesInput>
    connectOrCreate?: FornecedorCreateOrConnectWithoutAvaliacoesInput
    connect?: FornecedorWhereUniqueInput
  }

  export type FornecedorUpdateOneRequiredWithoutAvaliacoesNestedInput = {
    create?: XOR<FornecedorCreateWithoutAvaliacoesInput, FornecedorUncheckedCreateWithoutAvaliacoesInput>
    connectOrCreate?: FornecedorCreateOrConnectWithoutAvaliacoesInput
    upsert?: FornecedorUpsertWithoutAvaliacoesInput
    connect?: FornecedorWhereUniqueInput
    update?: XOR<XOR<FornecedorUpdateToOneWithWhereWithoutAvaliacoesInput, FornecedorUpdateWithoutAvaliacoesInput>, FornecedorUncheckedUpdateWithoutAvaliacoesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumTipoCartaoFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoCartao | EnumTipoCartaoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoCartao[] | ListEnumTipoCartaoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoCartao[] | ListEnumTipoCartaoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoCartaoFilter<$PrismaModel> | $Enums.TipoCartao
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumTipoCartaoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoCartao | EnumTipoCartaoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoCartao[] | ListEnumTipoCartaoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoCartao[] | ListEnumTipoCartaoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoCartaoWithAggregatesFilter<$PrismaModel> | $Enums.TipoCartao
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoCartaoFilter<$PrismaModel>
    _max?: NestedEnumTipoCartaoFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnderecoCreateWithoutUsuarioInput = {
    rua: string
    bairro: string
    cep: string
    numero: string
    complemento: string
  }

  export type EnderecoUncheckedCreateWithoutUsuarioInput = {
    id?: number
    rua: string
    bairro: string
    cep: string
    numero: string
    complemento: string
  }

  export type EnderecoCreateOrConnectWithoutUsuarioInput = {
    where: EnderecoWhereUniqueInput
    create: XOR<EnderecoCreateWithoutUsuarioInput, EnderecoUncheckedCreateWithoutUsuarioInput>
  }

  export type CartaoCreateWithoutUsuarioInput = {
    tipoCartao: $Enums.TipoCartao
    numeroCartao: string
    cvc: number
    nomeCartao: string
    dataValidade: Date | string
  }

  export type CartaoUncheckedCreateWithoutUsuarioInput = {
    id?: number
    tipoCartao: $Enums.TipoCartao
    numeroCartao: string
    cvc: number
    nomeCartao: string
    dataValidade: Date | string
  }

  export type CartaoCreateOrConnectWithoutUsuarioInput = {
    where: CartaoWhereUniqueInput
    create: XOR<CartaoCreateWithoutUsuarioInput, CartaoUncheckedCreateWithoutUsuarioInput>
  }

  export type CartaoCreateManyUsuarioInputEnvelope = {
    data: CartaoCreateManyUsuarioInput | CartaoCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type ClienteCreateWithoutUsuarioInput = {
    cupons?: CupomCreateNestedManyWithoutClienteInput
    carrinho?: CarrinhoComprasCreateNestedOneWithoutClienteInput
  }

  export type ClienteUncheckedCreateWithoutUsuarioInput = {
    cupons?: CupomUncheckedCreateNestedManyWithoutClienteInput
    carrinho?: CarrinhoComprasUncheckedCreateNestedOneWithoutClienteInput
  }

  export type ClienteCreateOrConnectWithoutUsuarioInput = {
    where: ClienteWhereUniqueInput
    create: XOR<ClienteCreateWithoutUsuarioInput, ClienteUncheckedCreateWithoutUsuarioInput>
  }

  export type FornecedorCreateWithoutUsuarioInput = {
    avaliacaoTotal: number
    avaliacoes?: AvaliacaoCreateNestedManyWithoutFornecedorInput
    dadosBancarios?: DadosBancariosCreateNestedOneWithoutFornecedorInput
    produtos?: ProdutoCreateNestedManyWithoutFornecedorInput
    servicos?: ServicoCreateNestedManyWithoutFornecedorInput
  }

  export type FornecedorUncheckedCreateWithoutUsuarioInput = {
    avaliacaoTotal: number
    avaliacoes?: AvaliacaoUncheckedCreateNestedManyWithoutFornecedorInput
    dadosBancarios?: DadosBancariosUncheckedCreateNestedOneWithoutFornecedorInput
    produtos?: ProdutoUncheckedCreateNestedManyWithoutFornecedorInput
    servicos?: ServicoUncheckedCreateNestedManyWithoutFornecedorInput
  }

  export type FornecedorCreateOrConnectWithoutUsuarioInput = {
    where: FornecedorWhereUniqueInput
    create: XOR<FornecedorCreateWithoutUsuarioInput, FornecedorUncheckedCreateWithoutUsuarioInput>
  }

  export type EnderecoUpsertWithoutUsuarioInput = {
    update: XOR<EnderecoUpdateWithoutUsuarioInput, EnderecoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<EnderecoCreateWithoutUsuarioInput, EnderecoUncheckedCreateWithoutUsuarioInput>
    where?: EnderecoWhereInput
  }

  export type EnderecoUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: EnderecoWhereInput
    data: XOR<EnderecoUpdateWithoutUsuarioInput, EnderecoUncheckedUpdateWithoutUsuarioInput>
  }

  export type EnderecoUpdateWithoutUsuarioInput = {
    rua?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    cep?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    complemento?: StringFieldUpdateOperationsInput | string
  }

  export type EnderecoUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    rua?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    cep?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    complemento?: StringFieldUpdateOperationsInput | string
  }

  export type CartaoUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: CartaoWhereUniqueInput
    update: XOR<CartaoUpdateWithoutUsuarioInput, CartaoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<CartaoCreateWithoutUsuarioInput, CartaoUncheckedCreateWithoutUsuarioInput>
  }

  export type CartaoUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: CartaoWhereUniqueInput
    data: XOR<CartaoUpdateWithoutUsuarioInput, CartaoUncheckedUpdateWithoutUsuarioInput>
  }

  export type CartaoUpdateManyWithWhereWithoutUsuarioInput = {
    where: CartaoScalarWhereInput
    data: XOR<CartaoUpdateManyMutationInput, CartaoUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type CartaoScalarWhereInput = {
    AND?: CartaoScalarWhereInput | CartaoScalarWhereInput[]
    OR?: CartaoScalarWhereInput[]
    NOT?: CartaoScalarWhereInput | CartaoScalarWhereInput[]
    id?: IntFilter<"Cartao"> | number
    tipoCartao?: EnumTipoCartaoFilter<"Cartao"> | $Enums.TipoCartao
    numeroCartao?: StringFilter<"Cartao"> | string
    cvc?: IntFilter<"Cartao"> | number
    nomeCartao?: StringFilter<"Cartao"> | string
    dataValidade?: DateTimeFilter<"Cartao"> | Date | string
    usuarioId?: IntFilter<"Cartao"> | number
  }

  export type ClienteUpsertWithoutUsuarioInput = {
    update: XOR<ClienteUpdateWithoutUsuarioInput, ClienteUncheckedUpdateWithoutUsuarioInput>
    create: XOR<ClienteCreateWithoutUsuarioInput, ClienteUncheckedCreateWithoutUsuarioInput>
    where?: ClienteWhereInput
  }

  export type ClienteUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: ClienteWhereInput
    data: XOR<ClienteUpdateWithoutUsuarioInput, ClienteUncheckedUpdateWithoutUsuarioInput>
  }

  export type ClienteUpdateWithoutUsuarioInput = {
    cupons?: CupomUpdateManyWithoutClienteNestedInput
    carrinho?: CarrinhoComprasUpdateOneWithoutClienteNestedInput
  }

  export type ClienteUncheckedUpdateWithoutUsuarioInput = {
    cupons?: CupomUncheckedUpdateManyWithoutClienteNestedInput
    carrinho?: CarrinhoComprasUncheckedUpdateOneWithoutClienteNestedInput
  }

  export type FornecedorUpsertWithoutUsuarioInput = {
    update: XOR<FornecedorUpdateWithoutUsuarioInput, FornecedorUncheckedUpdateWithoutUsuarioInput>
    create: XOR<FornecedorCreateWithoutUsuarioInput, FornecedorUncheckedCreateWithoutUsuarioInput>
    where?: FornecedorWhereInput
  }

  export type FornecedorUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: FornecedorWhereInput
    data: XOR<FornecedorUpdateWithoutUsuarioInput, FornecedorUncheckedUpdateWithoutUsuarioInput>
  }

  export type FornecedorUpdateWithoutUsuarioInput = {
    avaliacaoTotal?: FloatFieldUpdateOperationsInput | number
    avaliacoes?: AvaliacaoUpdateManyWithoutFornecedorNestedInput
    dadosBancarios?: DadosBancariosUpdateOneWithoutFornecedorNestedInput
    produtos?: ProdutoUpdateManyWithoutFornecedorNestedInput
    servicos?: ServicoUpdateManyWithoutFornecedorNestedInput
  }

  export type FornecedorUncheckedUpdateWithoutUsuarioInput = {
    avaliacaoTotal?: FloatFieldUpdateOperationsInput | number
    avaliacoes?: AvaliacaoUncheckedUpdateManyWithoutFornecedorNestedInput
    dadosBancarios?: DadosBancariosUncheckedUpdateOneWithoutFornecedorNestedInput
    produtos?: ProdutoUncheckedUpdateManyWithoutFornecedorNestedInput
    servicos?: ServicoUncheckedUpdateManyWithoutFornecedorNestedInput
  }

  export type UsuarioCreateWithoutEnderecoInput = {
    nome: string
    email: string
    senha: string
    imagemPerfil?: string | null
    tipo: string
    cartoes?: CartaoCreateNestedManyWithoutUsuarioInput
    cliente?: ClienteCreateNestedOneWithoutUsuarioInput
    fornecedor?: FornecedorCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutEnderecoInput = {
    id?: number
    nome: string
    email: string
    senha: string
    imagemPerfil?: string | null
    tipo: string
    cartoes?: CartaoUncheckedCreateNestedManyWithoutUsuarioInput
    cliente?: ClienteUncheckedCreateNestedOneWithoutUsuarioInput
    fornecedor?: FornecedorUncheckedCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutEnderecoInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutEnderecoInput, UsuarioUncheckedCreateWithoutEnderecoInput>
  }

  export type UsuarioUpsertWithoutEnderecoInput = {
    update: XOR<UsuarioUpdateWithoutEnderecoInput, UsuarioUncheckedUpdateWithoutEnderecoInput>
    create: XOR<UsuarioCreateWithoutEnderecoInput, UsuarioUncheckedCreateWithoutEnderecoInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutEnderecoInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutEnderecoInput, UsuarioUncheckedUpdateWithoutEnderecoInput>
  }

  export type UsuarioUpdateWithoutEnderecoInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    imagemPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    cartoes?: CartaoUpdateManyWithoutUsuarioNestedInput
    cliente?: ClienteUpdateOneWithoutUsuarioNestedInput
    fornecedor?: FornecedorUpdateOneWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutEnderecoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    imagemPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    cartoes?: CartaoUncheckedUpdateManyWithoutUsuarioNestedInput
    cliente?: ClienteUncheckedUpdateOneWithoutUsuarioNestedInput
    fornecedor?: FornecedorUncheckedUpdateOneWithoutUsuarioNestedInput
  }

  export type UsuarioCreateWithoutCartoesInput = {
    nome: string
    email: string
    senha: string
    imagemPerfil?: string | null
    tipo: string
    endereco?: EnderecoCreateNestedOneWithoutUsuarioInput
    cliente?: ClienteCreateNestedOneWithoutUsuarioInput
    fornecedor?: FornecedorCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutCartoesInput = {
    id?: number
    nome: string
    email: string
    senha: string
    imagemPerfil?: string | null
    tipo: string
    endereco?: EnderecoUncheckedCreateNestedOneWithoutUsuarioInput
    cliente?: ClienteUncheckedCreateNestedOneWithoutUsuarioInput
    fornecedor?: FornecedorUncheckedCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutCartoesInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutCartoesInput, UsuarioUncheckedCreateWithoutCartoesInput>
  }

  export type UsuarioUpsertWithoutCartoesInput = {
    update: XOR<UsuarioUpdateWithoutCartoesInput, UsuarioUncheckedUpdateWithoutCartoesInput>
    create: XOR<UsuarioCreateWithoutCartoesInput, UsuarioUncheckedCreateWithoutCartoesInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutCartoesInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutCartoesInput, UsuarioUncheckedUpdateWithoutCartoesInput>
  }

  export type UsuarioUpdateWithoutCartoesInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    imagemPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    endereco?: EnderecoUpdateOneWithoutUsuarioNestedInput
    cliente?: ClienteUpdateOneWithoutUsuarioNestedInput
    fornecedor?: FornecedorUpdateOneWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutCartoesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    imagemPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    endereco?: EnderecoUncheckedUpdateOneWithoutUsuarioNestedInput
    cliente?: ClienteUncheckedUpdateOneWithoutUsuarioNestedInput
    fornecedor?: FornecedorUncheckedUpdateOneWithoutUsuarioNestedInput
  }

  export type UsuarioCreateWithoutClienteInput = {
    nome: string
    email: string
    senha: string
    imagemPerfil?: string | null
    tipo: string
    endereco?: EnderecoCreateNestedOneWithoutUsuarioInput
    cartoes?: CartaoCreateNestedManyWithoutUsuarioInput
    fornecedor?: FornecedorCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutClienteInput = {
    id?: number
    nome: string
    email: string
    senha: string
    imagemPerfil?: string | null
    tipo: string
    endereco?: EnderecoUncheckedCreateNestedOneWithoutUsuarioInput
    cartoes?: CartaoUncheckedCreateNestedManyWithoutUsuarioInput
    fornecedor?: FornecedorUncheckedCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutClienteInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutClienteInput, UsuarioUncheckedCreateWithoutClienteInput>
  }

  export type CupomCreateWithoutClienteInput = {
    nome: string
    dataValidade: Date | string
    desconto: number
  }

  export type CupomUncheckedCreateWithoutClienteInput = {
    id?: number
    nome: string
    dataValidade: Date | string
    desconto: number
  }

  export type CupomCreateOrConnectWithoutClienteInput = {
    where: CupomWhereUniqueInput
    create: XOR<CupomCreateWithoutClienteInput, CupomUncheckedCreateWithoutClienteInput>
  }

  export type CupomCreateManyClienteInputEnvelope = {
    data: CupomCreateManyClienteInput | CupomCreateManyClienteInput[]
    skipDuplicates?: boolean
  }

  export type CarrinhoComprasCreateWithoutClienteInput = {
    items?: ItemCreateNestedManyWithoutCarrinhoInput
  }

  export type CarrinhoComprasUncheckedCreateWithoutClienteInput = {
    id?: number
    items?: ItemUncheckedCreateNestedManyWithoutCarrinhoInput
  }

  export type CarrinhoComprasCreateOrConnectWithoutClienteInput = {
    where: CarrinhoComprasWhereUniqueInput
    create: XOR<CarrinhoComprasCreateWithoutClienteInput, CarrinhoComprasUncheckedCreateWithoutClienteInput>
  }

  export type UsuarioUpsertWithoutClienteInput = {
    update: XOR<UsuarioUpdateWithoutClienteInput, UsuarioUncheckedUpdateWithoutClienteInput>
    create: XOR<UsuarioCreateWithoutClienteInput, UsuarioUncheckedCreateWithoutClienteInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutClienteInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutClienteInput, UsuarioUncheckedUpdateWithoutClienteInput>
  }

  export type UsuarioUpdateWithoutClienteInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    imagemPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    endereco?: EnderecoUpdateOneWithoutUsuarioNestedInput
    cartoes?: CartaoUpdateManyWithoutUsuarioNestedInput
    fornecedor?: FornecedorUpdateOneWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutClienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    imagemPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    endereco?: EnderecoUncheckedUpdateOneWithoutUsuarioNestedInput
    cartoes?: CartaoUncheckedUpdateManyWithoutUsuarioNestedInput
    fornecedor?: FornecedorUncheckedUpdateOneWithoutUsuarioNestedInput
  }

  export type CupomUpsertWithWhereUniqueWithoutClienteInput = {
    where: CupomWhereUniqueInput
    update: XOR<CupomUpdateWithoutClienteInput, CupomUncheckedUpdateWithoutClienteInput>
    create: XOR<CupomCreateWithoutClienteInput, CupomUncheckedCreateWithoutClienteInput>
  }

  export type CupomUpdateWithWhereUniqueWithoutClienteInput = {
    where: CupomWhereUniqueInput
    data: XOR<CupomUpdateWithoutClienteInput, CupomUncheckedUpdateWithoutClienteInput>
  }

  export type CupomUpdateManyWithWhereWithoutClienteInput = {
    where: CupomScalarWhereInput
    data: XOR<CupomUpdateManyMutationInput, CupomUncheckedUpdateManyWithoutClienteInput>
  }

  export type CupomScalarWhereInput = {
    AND?: CupomScalarWhereInput | CupomScalarWhereInput[]
    OR?: CupomScalarWhereInput[]
    NOT?: CupomScalarWhereInput | CupomScalarWhereInput[]
    id?: IntFilter<"Cupom"> | number
    nome?: StringFilter<"Cupom"> | string
    dataValidade?: DateTimeFilter<"Cupom"> | Date | string
    desconto?: FloatFilter<"Cupom"> | number
    clienteId?: IntFilter<"Cupom"> | number
  }

  export type CarrinhoComprasUpsertWithoutClienteInput = {
    update: XOR<CarrinhoComprasUpdateWithoutClienteInput, CarrinhoComprasUncheckedUpdateWithoutClienteInput>
    create: XOR<CarrinhoComprasCreateWithoutClienteInput, CarrinhoComprasUncheckedCreateWithoutClienteInput>
    where?: CarrinhoComprasWhereInput
  }

  export type CarrinhoComprasUpdateToOneWithWhereWithoutClienteInput = {
    where?: CarrinhoComprasWhereInput
    data: XOR<CarrinhoComprasUpdateWithoutClienteInput, CarrinhoComprasUncheckedUpdateWithoutClienteInput>
  }

  export type CarrinhoComprasUpdateWithoutClienteInput = {
    items?: ItemUpdateManyWithoutCarrinhoNestedInput
  }

  export type CarrinhoComprasUncheckedUpdateWithoutClienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    items?: ItemUncheckedUpdateManyWithoutCarrinhoNestedInput
  }

  export type UsuarioCreateWithoutFornecedorInput = {
    nome: string
    email: string
    senha: string
    imagemPerfil?: string | null
    tipo: string
    endereco?: EnderecoCreateNestedOneWithoutUsuarioInput
    cartoes?: CartaoCreateNestedManyWithoutUsuarioInput
    cliente?: ClienteCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutFornecedorInput = {
    id?: number
    nome: string
    email: string
    senha: string
    imagemPerfil?: string | null
    tipo: string
    endereco?: EnderecoUncheckedCreateNestedOneWithoutUsuarioInput
    cartoes?: CartaoUncheckedCreateNestedManyWithoutUsuarioInput
    cliente?: ClienteUncheckedCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutFornecedorInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutFornecedorInput, UsuarioUncheckedCreateWithoutFornecedorInput>
  }

  export type AvaliacaoCreateWithoutFornecedorInput = {
    nota: number
  }

  export type AvaliacaoUncheckedCreateWithoutFornecedorInput = {
    id?: number
    nota: number
  }

  export type AvaliacaoCreateOrConnectWithoutFornecedorInput = {
    where: AvaliacaoWhereUniqueInput
    create: XOR<AvaliacaoCreateWithoutFornecedorInput, AvaliacaoUncheckedCreateWithoutFornecedorInput>
  }

  export type AvaliacaoCreateManyFornecedorInputEnvelope = {
    data: AvaliacaoCreateManyFornecedorInput | AvaliacaoCreateManyFornecedorInput[]
    skipDuplicates?: boolean
  }

  export type DadosBancariosCreateWithoutFornecedorInput = {
    idBanco: string
    numAgencia: string
    tipoConta: string
  }

  export type DadosBancariosUncheckedCreateWithoutFornecedorInput = {
    id?: number
    idBanco: string
    numAgencia: string
    tipoConta: string
  }

  export type DadosBancariosCreateOrConnectWithoutFornecedorInput = {
    where: DadosBancariosWhereUniqueInput
    create: XOR<DadosBancariosCreateWithoutFornecedorInput, DadosBancariosUncheckedCreateWithoutFornecedorInput>
  }

  export type ProdutoCreateWithoutFornecedorInput = {
    nome: string
    valor: number
    quantidade: number
    item?: ItemCreateNestedOneWithoutProdutoInput
  }

  export type ProdutoUncheckedCreateWithoutFornecedorInput = {
    id?: number
    nome: string
    valor: number
    quantidade: number
    item?: ItemUncheckedCreateNestedOneWithoutProdutoInput
  }

  export type ProdutoCreateOrConnectWithoutFornecedorInput = {
    where: ProdutoWhereUniqueInput
    create: XOR<ProdutoCreateWithoutFornecedorInput, ProdutoUncheckedCreateWithoutFornecedorInput>
  }

  export type ProdutoCreateManyFornecedorInputEnvelope = {
    data: ProdutoCreateManyFornecedorInput | ProdutoCreateManyFornecedorInput[]
    skipDuplicates?: boolean
  }

  export type ServicoCreateWithoutFornecedorInput = {
    nome: string
    valor: number
    dataAgendada: Date | string
    item?: ItemCreateNestedOneWithoutServicoInput
  }

  export type ServicoUncheckedCreateWithoutFornecedorInput = {
    id?: number
    nome: string
    valor: number
    dataAgendada: Date | string
    item?: ItemUncheckedCreateNestedOneWithoutServicoInput
  }

  export type ServicoCreateOrConnectWithoutFornecedorInput = {
    where: ServicoWhereUniqueInput
    create: XOR<ServicoCreateWithoutFornecedorInput, ServicoUncheckedCreateWithoutFornecedorInput>
  }

  export type ServicoCreateManyFornecedorInputEnvelope = {
    data: ServicoCreateManyFornecedorInput | ServicoCreateManyFornecedorInput[]
    skipDuplicates?: boolean
  }

  export type UsuarioUpsertWithoutFornecedorInput = {
    update: XOR<UsuarioUpdateWithoutFornecedorInput, UsuarioUncheckedUpdateWithoutFornecedorInput>
    create: XOR<UsuarioCreateWithoutFornecedorInput, UsuarioUncheckedCreateWithoutFornecedorInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutFornecedorInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutFornecedorInput, UsuarioUncheckedUpdateWithoutFornecedorInput>
  }

  export type UsuarioUpdateWithoutFornecedorInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    imagemPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    endereco?: EnderecoUpdateOneWithoutUsuarioNestedInput
    cartoes?: CartaoUpdateManyWithoutUsuarioNestedInput
    cliente?: ClienteUpdateOneWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutFornecedorInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    imagemPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    endereco?: EnderecoUncheckedUpdateOneWithoutUsuarioNestedInput
    cartoes?: CartaoUncheckedUpdateManyWithoutUsuarioNestedInput
    cliente?: ClienteUncheckedUpdateOneWithoutUsuarioNestedInput
  }

  export type AvaliacaoUpsertWithWhereUniqueWithoutFornecedorInput = {
    where: AvaliacaoWhereUniqueInput
    update: XOR<AvaliacaoUpdateWithoutFornecedorInput, AvaliacaoUncheckedUpdateWithoutFornecedorInput>
    create: XOR<AvaliacaoCreateWithoutFornecedorInput, AvaliacaoUncheckedCreateWithoutFornecedorInput>
  }

  export type AvaliacaoUpdateWithWhereUniqueWithoutFornecedorInput = {
    where: AvaliacaoWhereUniqueInput
    data: XOR<AvaliacaoUpdateWithoutFornecedorInput, AvaliacaoUncheckedUpdateWithoutFornecedorInput>
  }

  export type AvaliacaoUpdateManyWithWhereWithoutFornecedorInput = {
    where: AvaliacaoScalarWhereInput
    data: XOR<AvaliacaoUpdateManyMutationInput, AvaliacaoUncheckedUpdateManyWithoutFornecedorInput>
  }

  export type AvaliacaoScalarWhereInput = {
    AND?: AvaliacaoScalarWhereInput | AvaliacaoScalarWhereInput[]
    OR?: AvaliacaoScalarWhereInput[]
    NOT?: AvaliacaoScalarWhereInput | AvaliacaoScalarWhereInput[]
    id?: IntFilter<"Avaliacao"> | number
    nota?: FloatFilter<"Avaliacao"> | number
    fornecedorId?: IntFilter<"Avaliacao"> | number
  }

  export type DadosBancariosUpsertWithoutFornecedorInput = {
    update: XOR<DadosBancariosUpdateWithoutFornecedorInput, DadosBancariosUncheckedUpdateWithoutFornecedorInput>
    create: XOR<DadosBancariosCreateWithoutFornecedorInput, DadosBancariosUncheckedCreateWithoutFornecedorInput>
    where?: DadosBancariosWhereInput
  }

  export type DadosBancariosUpdateToOneWithWhereWithoutFornecedorInput = {
    where?: DadosBancariosWhereInput
    data: XOR<DadosBancariosUpdateWithoutFornecedorInput, DadosBancariosUncheckedUpdateWithoutFornecedorInput>
  }

  export type DadosBancariosUpdateWithoutFornecedorInput = {
    idBanco?: StringFieldUpdateOperationsInput | string
    numAgencia?: StringFieldUpdateOperationsInput | string
    tipoConta?: StringFieldUpdateOperationsInput | string
  }

  export type DadosBancariosUncheckedUpdateWithoutFornecedorInput = {
    id?: IntFieldUpdateOperationsInput | number
    idBanco?: StringFieldUpdateOperationsInput | string
    numAgencia?: StringFieldUpdateOperationsInput | string
    tipoConta?: StringFieldUpdateOperationsInput | string
  }

  export type ProdutoUpsertWithWhereUniqueWithoutFornecedorInput = {
    where: ProdutoWhereUniqueInput
    update: XOR<ProdutoUpdateWithoutFornecedorInput, ProdutoUncheckedUpdateWithoutFornecedorInput>
    create: XOR<ProdutoCreateWithoutFornecedorInput, ProdutoUncheckedCreateWithoutFornecedorInput>
  }

  export type ProdutoUpdateWithWhereUniqueWithoutFornecedorInput = {
    where: ProdutoWhereUniqueInput
    data: XOR<ProdutoUpdateWithoutFornecedorInput, ProdutoUncheckedUpdateWithoutFornecedorInput>
  }

  export type ProdutoUpdateManyWithWhereWithoutFornecedorInput = {
    where: ProdutoScalarWhereInput
    data: XOR<ProdutoUpdateManyMutationInput, ProdutoUncheckedUpdateManyWithoutFornecedorInput>
  }

  export type ProdutoScalarWhereInput = {
    AND?: ProdutoScalarWhereInput | ProdutoScalarWhereInput[]
    OR?: ProdutoScalarWhereInput[]
    NOT?: ProdutoScalarWhereInput | ProdutoScalarWhereInput[]
    id?: IntFilter<"Produto"> | number
    nome?: StringFilter<"Produto"> | string
    valor?: FloatFilter<"Produto"> | number
    quantidade?: FloatFilter<"Produto"> | number
    fornecedorId?: IntFilter<"Produto"> | number
  }

  export type ServicoUpsertWithWhereUniqueWithoutFornecedorInput = {
    where: ServicoWhereUniqueInput
    update: XOR<ServicoUpdateWithoutFornecedorInput, ServicoUncheckedUpdateWithoutFornecedorInput>
    create: XOR<ServicoCreateWithoutFornecedorInput, ServicoUncheckedCreateWithoutFornecedorInput>
  }

  export type ServicoUpdateWithWhereUniqueWithoutFornecedorInput = {
    where: ServicoWhereUniqueInput
    data: XOR<ServicoUpdateWithoutFornecedorInput, ServicoUncheckedUpdateWithoutFornecedorInput>
  }

  export type ServicoUpdateManyWithWhereWithoutFornecedorInput = {
    where: ServicoScalarWhereInput
    data: XOR<ServicoUpdateManyMutationInput, ServicoUncheckedUpdateManyWithoutFornecedorInput>
  }

  export type ServicoScalarWhereInput = {
    AND?: ServicoScalarWhereInput | ServicoScalarWhereInput[]
    OR?: ServicoScalarWhereInput[]
    NOT?: ServicoScalarWhereInput | ServicoScalarWhereInput[]
    id?: IntFilter<"Servico"> | number
    nome?: StringFilter<"Servico"> | string
    valor?: FloatFilter<"Servico"> | number
    dataAgendada?: DateTimeFilter<"Servico"> | Date | string
    fornecedorId?: IntFilter<"Servico"> | number
  }

  export type FornecedorCreateWithoutDadosBancariosInput = {
    avaliacaoTotal: number
    usuario: UsuarioCreateNestedOneWithoutFornecedorInput
    avaliacoes?: AvaliacaoCreateNestedManyWithoutFornecedorInput
    produtos?: ProdutoCreateNestedManyWithoutFornecedorInput
    servicos?: ServicoCreateNestedManyWithoutFornecedorInput
  }

  export type FornecedorUncheckedCreateWithoutDadosBancariosInput = {
    id: number
    avaliacaoTotal: number
    avaliacoes?: AvaliacaoUncheckedCreateNestedManyWithoutFornecedorInput
    produtos?: ProdutoUncheckedCreateNestedManyWithoutFornecedorInput
    servicos?: ServicoUncheckedCreateNestedManyWithoutFornecedorInput
  }

  export type FornecedorCreateOrConnectWithoutDadosBancariosInput = {
    where: FornecedorWhereUniqueInput
    create: XOR<FornecedorCreateWithoutDadosBancariosInput, FornecedorUncheckedCreateWithoutDadosBancariosInput>
  }

  export type FornecedorUpsertWithoutDadosBancariosInput = {
    update: XOR<FornecedorUpdateWithoutDadosBancariosInput, FornecedorUncheckedUpdateWithoutDadosBancariosInput>
    create: XOR<FornecedorCreateWithoutDadosBancariosInput, FornecedorUncheckedCreateWithoutDadosBancariosInput>
    where?: FornecedorWhereInput
  }

  export type FornecedorUpdateToOneWithWhereWithoutDadosBancariosInput = {
    where?: FornecedorWhereInput
    data: XOR<FornecedorUpdateWithoutDadosBancariosInput, FornecedorUncheckedUpdateWithoutDadosBancariosInput>
  }

  export type FornecedorUpdateWithoutDadosBancariosInput = {
    avaliacaoTotal?: FloatFieldUpdateOperationsInput | number
    usuario?: UsuarioUpdateOneRequiredWithoutFornecedorNestedInput
    avaliacoes?: AvaliacaoUpdateManyWithoutFornecedorNestedInput
    produtos?: ProdutoUpdateManyWithoutFornecedorNestedInput
    servicos?: ServicoUpdateManyWithoutFornecedorNestedInput
  }

  export type FornecedorUncheckedUpdateWithoutDadosBancariosInput = {
    id?: IntFieldUpdateOperationsInput | number
    avaliacaoTotal?: FloatFieldUpdateOperationsInput | number
    avaliacoes?: AvaliacaoUncheckedUpdateManyWithoutFornecedorNestedInput
    produtos?: ProdutoUncheckedUpdateManyWithoutFornecedorNestedInput
    servicos?: ServicoUncheckedUpdateManyWithoutFornecedorNestedInput
  }

  export type ClienteCreateWithoutCuponsInput = {
    usuario: UsuarioCreateNestedOneWithoutClienteInput
    carrinho?: CarrinhoComprasCreateNestedOneWithoutClienteInput
  }

  export type ClienteUncheckedCreateWithoutCuponsInput = {
    id: number
    carrinho?: CarrinhoComprasUncheckedCreateNestedOneWithoutClienteInput
  }

  export type ClienteCreateOrConnectWithoutCuponsInput = {
    where: ClienteWhereUniqueInput
    create: XOR<ClienteCreateWithoutCuponsInput, ClienteUncheckedCreateWithoutCuponsInput>
  }

  export type ClienteUpsertWithoutCuponsInput = {
    update: XOR<ClienteUpdateWithoutCuponsInput, ClienteUncheckedUpdateWithoutCuponsInput>
    create: XOR<ClienteCreateWithoutCuponsInput, ClienteUncheckedCreateWithoutCuponsInput>
    where?: ClienteWhereInput
  }

  export type ClienteUpdateToOneWithWhereWithoutCuponsInput = {
    where?: ClienteWhereInput
    data: XOR<ClienteUpdateWithoutCuponsInput, ClienteUncheckedUpdateWithoutCuponsInput>
  }

  export type ClienteUpdateWithoutCuponsInput = {
    usuario?: UsuarioUpdateOneRequiredWithoutClienteNestedInput
    carrinho?: CarrinhoComprasUpdateOneWithoutClienteNestedInput
  }

  export type ClienteUncheckedUpdateWithoutCuponsInput = {
    id?: IntFieldUpdateOperationsInput | number
    carrinho?: CarrinhoComprasUncheckedUpdateOneWithoutClienteNestedInput
  }

  export type ClienteCreateWithoutCarrinhoInput = {
    usuario: UsuarioCreateNestedOneWithoutClienteInput
    cupons?: CupomCreateNestedManyWithoutClienteInput
  }

  export type ClienteUncheckedCreateWithoutCarrinhoInput = {
    id: number
    cupons?: CupomUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClienteCreateOrConnectWithoutCarrinhoInput = {
    where: ClienteWhereUniqueInput
    create: XOR<ClienteCreateWithoutCarrinhoInput, ClienteUncheckedCreateWithoutCarrinhoInput>
  }

  export type ItemCreateWithoutCarrinhoInput = {
    nome: string
    valor: number
    produto?: ProdutoCreateNestedOneWithoutItemInput
    servico?: ServicoCreateNestedOneWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutCarrinhoInput = {
    id?: number
    nome: string
    valor: number
    produtoId?: number | null
    servicoId?: number | null
  }

  export type ItemCreateOrConnectWithoutCarrinhoInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutCarrinhoInput, ItemUncheckedCreateWithoutCarrinhoInput>
  }

  export type ItemCreateManyCarrinhoInputEnvelope = {
    data: ItemCreateManyCarrinhoInput | ItemCreateManyCarrinhoInput[]
    skipDuplicates?: boolean
  }

  export type ClienteUpsertWithoutCarrinhoInput = {
    update: XOR<ClienteUpdateWithoutCarrinhoInput, ClienteUncheckedUpdateWithoutCarrinhoInput>
    create: XOR<ClienteCreateWithoutCarrinhoInput, ClienteUncheckedCreateWithoutCarrinhoInput>
    where?: ClienteWhereInput
  }

  export type ClienteUpdateToOneWithWhereWithoutCarrinhoInput = {
    where?: ClienteWhereInput
    data: XOR<ClienteUpdateWithoutCarrinhoInput, ClienteUncheckedUpdateWithoutCarrinhoInput>
  }

  export type ClienteUpdateWithoutCarrinhoInput = {
    usuario?: UsuarioUpdateOneRequiredWithoutClienteNestedInput
    cupons?: CupomUpdateManyWithoutClienteNestedInput
  }

  export type ClienteUncheckedUpdateWithoutCarrinhoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cupons?: CupomUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type ItemUpsertWithWhereUniqueWithoutCarrinhoInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutCarrinhoInput, ItemUncheckedUpdateWithoutCarrinhoInput>
    create: XOR<ItemCreateWithoutCarrinhoInput, ItemUncheckedCreateWithoutCarrinhoInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutCarrinhoInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutCarrinhoInput, ItemUncheckedUpdateWithoutCarrinhoInput>
  }

  export type ItemUpdateManyWithWhereWithoutCarrinhoInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutCarrinhoInput>
  }

  export type ItemScalarWhereInput = {
    AND?: ItemScalarWhereInput | ItemScalarWhereInput[]
    OR?: ItemScalarWhereInput[]
    NOT?: ItemScalarWhereInput | ItemScalarWhereInput[]
    id?: IntFilter<"Item"> | number
    nome?: StringFilter<"Item"> | string
    valor?: FloatFilter<"Item"> | number
    carrinhoId?: IntFilter<"Item"> | number
    produtoId?: IntNullableFilter<"Item"> | number | null
    servicoId?: IntNullableFilter<"Item"> | number | null
  }

  export type CarrinhoComprasCreateWithoutItemsInput = {
    cliente: ClienteCreateNestedOneWithoutCarrinhoInput
  }

  export type CarrinhoComprasUncheckedCreateWithoutItemsInput = {
    id?: number
    clienteId: number
  }

  export type CarrinhoComprasCreateOrConnectWithoutItemsInput = {
    where: CarrinhoComprasWhereUniqueInput
    create: XOR<CarrinhoComprasCreateWithoutItemsInput, CarrinhoComprasUncheckedCreateWithoutItemsInput>
  }

  export type ProdutoCreateWithoutItemInput = {
    nome: string
    valor: number
    quantidade: number
    fornecedor: FornecedorCreateNestedOneWithoutProdutosInput
  }

  export type ProdutoUncheckedCreateWithoutItemInput = {
    id?: number
    nome: string
    valor: number
    quantidade: number
    fornecedorId: number
  }

  export type ProdutoCreateOrConnectWithoutItemInput = {
    where: ProdutoWhereUniqueInput
    create: XOR<ProdutoCreateWithoutItemInput, ProdutoUncheckedCreateWithoutItemInput>
  }

  export type ServicoCreateWithoutItemInput = {
    nome: string
    valor: number
    dataAgendada: Date | string
    fornecedor: FornecedorCreateNestedOneWithoutServicosInput
  }

  export type ServicoUncheckedCreateWithoutItemInput = {
    id?: number
    nome: string
    valor: number
    dataAgendada: Date | string
    fornecedorId: number
  }

  export type ServicoCreateOrConnectWithoutItemInput = {
    where: ServicoWhereUniqueInput
    create: XOR<ServicoCreateWithoutItemInput, ServicoUncheckedCreateWithoutItemInput>
  }

  export type CarrinhoComprasUpsertWithoutItemsInput = {
    update: XOR<CarrinhoComprasUpdateWithoutItemsInput, CarrinhoComprasUncheckedUpdateWithoutItemsInput>
    create: XOR<CarrinhoComprasCreateWithoutItemsInput, CarrinhoComprasUncheckedCreateWithoutItemsInput>
    where?: CarrinhoComprasWhereInput
  }

  export type CarrinhoComprasUpdateToOneWithWhereWithoutItemsInput = {
    where?: CarrinhoComprasWhereInput
    data: XOR<CarrinhoComprasUpdateWithoutItemsInput, CarrinhoComprasUncheckedUpdateWithoutItemsInput>
  }

  export type CarrinhoComprasUpdateWithoutItemsInput = {
    cliente?: ClienteUpdateOneRequiredWithoutCarrinhoNestedInput
  }

  export type CarrinhoComprasUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    clienteId?: IntFieldUpdateOperationsInput | number
  }

  export type ProdutoUpsertWithoutItemInput = {
    update: XOR<ProdutoUpdateWithoutItemInput, ProdutoUncheckedUpdateWithoutItemInput>
    create: XOR<ProdutoCreateWithoutItemInput, ProdutoUncheckedCreateWithoutItemInput>
    where?: ProdutoWhereInput
  }

  export type ProdutoUpdateToOneWithWhereWithoutItemInput = {
    where?: ProdutoWhereInput
    data: XOR<ProdutoUpdateWithoutItemInput, ProdutoUncheckedUpdateWithoutItemInput>
  }

  export type ProdutoUpdateWithoutItemInput = {
    nome?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    quantidade?: FloatFieldUpdateOperationsInput | number
    fornecedor?: FornecedorUpdateOneRequiredWithoutProdutosNestedInput
  }

  export type ProdutoUncheckedUpdateWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    quantidade?: FloatFieldUpdateOperationsInput | number
    fornecedorId?: IntFieldUpdateOperationsInput | number
  }

  export type ServicoUpsertWithoutItemInput = {
    update: XOR<ServicoUpdateWithoutItemInput, ServicoUncheckedUpdateWithoutItemInput>
    create: XOR<ServicoCreateWithoutItemInput, ServicoUncheckedCreateWithoutItemInput>
    where?: ServicoWhereInput
  }

  export type ServicoUpdateToOneWithWhereWithoutItemInput = {
    where?: ServicoWhereInput
    data: XOR<ServicoUpdateWithoutItemInput, ServicoUncheckedUpdateWithoutItemInput>
  }

  export type ServicoUpdateWithoutItemInput = {
    nome?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    dataAgendada?: DateTimeFieldUpdateOperationsInput | Date | string
    fornecedor?: FornecedorUpdateOneRequiredWithoutServicosNestedInput
  }

  export type ServicoUncheckedUpdateWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    dataAgendada?: DateTimeFieldUpdateOperationsInput | Date | string
    fornecedorId?: IntFieldUpdateOperationsInput | number
  }

  export type FornecedorCreateWithoutProdutosInput = {
    avaliacaoTotal: number
    usuario: UsuarioCreateNestedOneWithoutFornecedorInput
    avaliacoes?: AvaliacaoCreateNestedManyWithoutFornecedorInput
    dadosBancarios?: DadosBancariosCreateNestedOneWithoutFornecedorInput
    servicos?: ServicoCreateNestedManyWithoutFornecedorInput
  }

  export type FornecedorUncheckedCreateWithoutProdutosInput = {
    id: number
    avaliacaoTotal: number
    avaliacoes?: AvaliacaoUncheckedCreateNestedManyWithoutFornecedorInput
    dadosBancarios?: DadosBancariosUncheckedCreateNestedOneWithoutFornecedorInput
    servicos?: ServicoUncheckedCreateNestedManyWithoutFornecedorInput
  }

  export type FornecedorCreateOrConnectWithoutProdutosInput = {
    where: FornecedorWhereUniqueInput
    create: XOR<FornecedorCreateWithoutProdutosInput, FornecedorUncheckedCreateWithoutProdutosInput>
  }

  export type ItemCreateWithoutProdutoInput = {
    nome: string
    valor: number
    carrinho: CarrinhoComprasCreateNestedOneWithoutItemsInput
    servico?: ServicoCreateNestedOneWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutProdutoInput = {
    id?: number
    nome: string
    valor: number
    carrinhoId: number
    servicoId?: number | null
  }

  export type ItemCreateOrConnectWithoutProdutoInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutProdutoInput, ItemUncheckedCreateWithoutProdutoInput>
  }

  export type FornecedorUpsertWithoutProdutosInput = {
    update: XOR<FornecedorUpdateWithoutProdutosInput, FornecedorUncheckedUpdateWithoutProdutosInput>
    create: XOR<FornecedorCreateWithoutProdutosInput, FornecedorUncheckedCreateWithoutProdutosInput>
    where?: FornecedorWhereInput
  }

  export type FornecedorUpdateToOneWithWhereWithoutProdutosInput = {
    where?: FornecedorWhereInput
    data: XOR<FornecedorUpdateWithoutProdutosInput, FornecedorUncheckedUpdateWithoutProdutosInput>
  }

  export type FornecedorUpdateWithoutProdutosInput = {
    avaliacaoTotal?: FloatFieldUpdateOperationsInput | number
    usuario?: UsuarioUpdateOneRequiredWithoutFornecedorNestedInput
    avaliacoes?: AvaliacaoUpdateManyWithoutFornecedorNestedInput
    dadosBancarios?: DadosBancariosUpdateOneWithoutFornecedorNestedInput
    servicos?: ServicoUpdateManyWithoutFornecedorNestedInput
  }

  export type FornecedorUncheckedUpdateWithoutProdutosInput = {
    id?: IntFieldUpdateOperationsInput | number
    avaliacaoTotal?: FloatFieldUpdateOperationsInput | number
    avaliacoes?: AvaliacaoUncheckedUpdateManyWithoutFornecedorNestedInput
    dadosBancarios?: DadosBancariosUncheckedUpdateOneWithoutFornecedorNestedInput
    servicos?: ServicoUncheckedUpdateManyWithoutFornecedorNestedInput
  }

  export type ItemUpsertWithoutProdutoInput = {
    update: XOR<ItemUpdateWithoutProdutoInput, ItemUncheckedUpdateWithoutProdutoInput>
    create: XOR<ItemCreateWithoutProdutoInput, ItemUncheckedCreateWithoutProdutoInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutProdutoInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutProdutoInput, ItemUncheckedUpdateWithoutProdutoInput>
  }

  export type ItemUpdateWithoutProdutoInput = {
    nome?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    carrinho?: CarrinhoComprasUpdateOneRequiredWithoutItemsNestedInput
    servico?: ServicoUpdateOneWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutProdutoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    carrinhoId?: IntFieldUpdateOperationsInput | number
    servicoId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FornecedorCreateWithoutServicosInput = {
    avaliacaoTotal: number
    usuario: UsuarioCreateNestedOneWithoutFornecedorInput
    avaliacoes?: AvaliacaoCreateNestedManyWithoutFornecedorInput
    dadosBancarios?: DadosBancariosCreateNestedOneWithoutFornecedorInput
    produtos?: ProdutoCreateNestedManyWithoutFornecedorInput
  }

  export type FornecedorUncheckedCreateWithoutServicosInput = {
    id: number
    avaliacaoTotal: number
    avaliacoes?: AvaliacaoUncheckedCreateNestedManyWithoutFornecedorInput
    dadosBancarios?: DadosBancariosUncheckedCreateNestedOneWithoutFornecedorInput
    produtos?: ProdutoUncheckedCreateNestedManyWithoutFornecedorInput
  }

  export type FornecedorCreateOrConnectWithoutServicosInput = {
    where: FornecedorWhereUniqueInput
    create: XOR<FornecedorCreateWithoutServicosInput, FornecedorUncheckedCreateWithoutServicosInput>
  }

  export type ItemCreateWithoutServicoInput = {
    nome: string
    valor: number
    carrinho: CarrinhoComprasCreateNestedOneWithoutItemsInput
    produto?: ProdutoCreateNestedOneWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutServicoInput = {
    id?: number
    nome: string
    valor: number
    carrinhoId: number
    produtoId?: number | null
  }

  export type ItemCreateOrConnectWithoutServicoInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutServicoInput, ItemUncheckedCreateWithoutServicoInput>
  }

  export type FornecedorUpsertWithoutServicosInput = {
    update: XOR<FornecedorUpdateWithoutServicosInput, FornecedorUncheckedUpdateWithoutServicosInput>
    create: XOR<FornecedorCreateWithoutServicosInput, FornecedorUncheckedCreateWithoutServicosInput>
    where?: FornecedorWhereInput
  }

  export type FornecedorUpdateToOneWithWhereWithoutServicosInput = {
    where?: FornecedorWhereInput
    data: XOR<FornecedorUpdateWithoutServicosInput, FornecedorUncheckedUpdateWithoutServicosInput>
  }

  export type FornecedorUpdateWithoutServicosInput = {
    avaliacaoTotal?: FloatFieldUpdateOperationsInput | number
    usuario?: UsuarioUpdateOneRequiredWithoutFornecedorNestedInput
    avaliacoes?: AvaliacaoUpdateManyWithoutFornecedorNestedInput
    dadosBancarios?: DadosBancariosUpdateOneWithoutFornecedorNestedInput
    produtos?: ProdutoUpdateManyWithoutFornecedorNestedInput
  }

  export type FornecedorUncheckedUpdateWithoutServicosInput = {
    id?: IntFieldUpdateOperationsInput | number
    avaliacaoTotal?: FloatFieldUpdateOperationsInput | number
    avaliacoes?: AvaliacaoUncheckedUpdateManyWithoutFornecedorNestedInput
    dadosBancarios?: DadosBancariosUncheckedUpdateOneWithoutFornecedorNestedInput
    produtos?: ProdutoUncheckedUpdateManyWithoutFornecedorNestedInput
  }

  export type ItemUpsertWithoutServicoInput = {
    update: XOR<ItemUpdateWithoutServicoInput, ItemUncheckedUpdateWithoutServicoInput>
    create: XOR<ItemCreateWithoutServicoInput, ItemUncheckedCreateWithoutServicoInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutServicoInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutServicoInput, ItemUncheckedUpdateWithoutServicoInput>
  }

  export type ItemUpdateWithoutServicoInput = {
    nome?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    carrinho?: CarrinhoComprasUpdateOneRequiredWithoutItemsNestedInput
    produto?: ProdutoUpdateOneWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutServicoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    carrinhoId?: IntFieldUpdateOperationsInput | number
    produtoId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FornecedorCreateWithoutAvaliacoesInput = {
    avaliacaoTotal: number
    usuario: UsuarioCreateNestedOneWithoutFornecedorInput
    dadosBancarios?: DadosBancariosCreateNestedOneWithoutFornecedorInput
    produtos?: ProdutoCreateNestedManyWithoutFornecedorInput
    servicos?: ServicoCreateNestedManyWithoutFornecedorInput
  }

  export type FornecedorUncheckedCreateWithoutAvaliacoesInput = {
    id: number
    avaliacaoTotal: number
    dadosBancarios?: DadosBancariosUncheckedCreateNestedOneWithoutFornecedorInput
    produtos?: ProdutoUncheckedCreateNestedManyWithoutFornecedorInput
    servicos?: ServicoUncheckedCreateNestedManyWithoutFornecedorInput
  }

  export type FornecedorCreateOrConnectWithoutAvaliacoesInput = {
    where: FornecedorWhereUniqueInput
    create: XOR<FornecedorCreateWithoutAvaliacoesInput, FornecedorUncheckedCreateWithoutAvaliacoesInput>
  }

  export type FornecedorUpsertWithoutAvaliacoesInput = {
    update: XOR<FornecedorUpdateWithoutAvaliacoesInput, FornecedorUncheckedUpdateWithoutAvaliacoesInput>
    create: XOR<FornecedorCreateWithoutAvaliacoesInput, FornecedorUncheckedCreateWithoutAvaliacoesInput>
    where?: FornecedorWhereInput
  }

  export type FornecedorUpdateToOneWithWhereWithoutAvaliacoesInput = {
    where?: FornecedorWhereInput
    data: XOR<FornecedorUpdateWithoutAvaliacoesInput, FornecedorUncheckedUpdateWithoutAvaliacoesInput>
  }

  export type FornecedorUpdateWithoutAvaliacoesInput = {
    avaliacaoTotal?: FloatFieldUpdateOperationsInput | number
    usuario?: UsuarioUpdateOneRequiredWithoutFornecedorNestedInput
    dadosBancarios?: DadosBancariosUpdateOneWithoutFornecedorNestedInput
    produtos?: ProdutoUpdateManyWithoutFornecedorNestedInput
    servicos?: ServicoUpdateManyWithoutFornecedorNestedInput
  }

  export type FornecedorUncheckedUpdateWithoutAvaliacoesInput = {
    id?: IntFieldUpdateOperationsInput | number
    avaliacaoTotal?: FloatFieldUpdateOperationsInput | number
    dadosBancarios?: DadosBancariosUncheckedUpdateOneWithoutFornecedorNestedInput
    produtos?: ProdutoUncheckedUpdateManyWithoutFornecedorNestedInput
    servicos?: ServicoUncheckedUpdateManyWithoutFornecedorNestedInput
  }

  export type CartaoCreateManyUsuarioInput = {
    id?: number
    tipoCartao: $Enums.TipoCartao
    numeroCartao: string
    cvc: number
    nomeCartao: string
    dataValidade: Date | string
  }

  export type CartaoUpdateWithoutUsuarioInput = {
    tipoCartao?: EnumTipoCartaoFieldUpdateOperationsInput | $Enums.TipoCartao
    numeroCartao?: StringFieldUpdateOperationsInput | string
    cvc?: IntFieldUpdateOperationsInput | number
    nomeCartao?: StringFieldUpdateOperationsInput | string
    dataValidade?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartaoUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoCartao?: EnumTipoCartaoFieldUpdateOperationsInput | $Enums.TipoCartao
    numeroCartao?: StringFieldUpdateOperationsInput | string
    cvc?: IntFieldUpdateOperationsInput | number
    nomeCartao?: StringFieldUpdateOperationsInput | string
    dataValidade?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartaoUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoCartao?: EnumTipoCartaoFieldUpdateOperationsInput | $Enums.TipoCartao
    numeroCartao?: StringFieldUpdateOperationsInput | string
    cvc?: IntFieldUpdateOperationsInput | number
    nomeCartao?: StringFieldUpdateOperationsInput | string
    dataValidade?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CupomCreateManyClienteInput = {
    id?: number
    nome: string
    dataValidade: Date | string
    desconto: number
  }

  export type CupomUpdateWithoutClienteInput = {
    nome?: StringFieldUpdateOperationsInput | string
    dataValidade?: DateTimeFieldUpdateOperationsInput | Date | string
    desconto?: FloatFieldUpdateOperationsInput | number
  }

  export type CupomUncheckedUpdateWithoutClienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    dataValidade?: DateTimeFieldUpdateOperationsInput | Date | string
    desconto?: FloatFieldUpdateOperationsInput | number
  }

  export type CupomUncheckedUpdateManyWithoutClienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    dataValidade?: DateTimeFieldUpdateOperationsInput | Date | string
    desconto?: FloatFieldUpdateOperationsInput | number
  }

  export type AvaliacaoCreateManyFornecedorInput = {
    id?: number
    nota: number
  }

  export type ProdutoCreateManyFornecedorInput = {
    id?: number
    nome: string
    valor: number
    quantidade: number
  }

  export type ServicoCreateManyFornecedorInput = {
    id?: number
    nome: string
    valor: number
    dataAgendada: Date | string
  }

  export type AvaliacaoUpdateWithoutFornecedorInput = {
    nota?: FloatFieldUpdateOperationsInput | number
  }

  export type AvaliacaoUncheckedUpdateWithoutFornecedorInput = {
    id?: IntFieldUpdateOperationsInput | number
    nota?: FloatFieldUpdateOperationsInput | number
  }

  export type AvaliacaoUncheckedUpdateManyWithoutFornecedorInput = {
    id?: IntFieldUpdateOperationsInput | number
    nota?: FloatFieldUpdateOperationsInput | number
  }

  export type ProdutoUpdateWithoutFornecedorInput = {
    nome?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    quantidade?: FloatFieldUpdateOperationsInput | number
    item?: ItemUpdateOneWithoutProdutoNestedInput
  }

  export type ProdutoUncheckedUpdateWithoutFornecedorInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    quantidade?: FloatFieldUpdateOperationsInput | number
    item?: ItemUncheckedUpdateOneWithoutProdutoNestedInput
  }

  export type ProdutoUncheckedUpdateManyWithoutFornecedorInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    quantidade?: FloatFieldUpdateOperationsInput | number
  }

  export type ServicoUpdateWithoutFornecedorInput = {
    nome?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    dataAgendada?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneWithoutServicoNestedInput
  }

  export type ServicoUncheckedUpdateWithoutFornecedorInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    dataAgendada?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUncheckedUpdateOneWithoutServicoNestedInput
  }

  export type ServicoUncheckedUpdateManyWithoutFornecedorInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    dataAgendada?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCreateManyCarrinhoInput = {
    id?: number
    nome: string
    valor: number
    produtoId?: number | null
    servicoId?: number | null
  }

  export type ItemUpdateWithoutCarrinhoInput = {
    nome?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    produto?: ProdutoUpdateOneWithoutItemNestedInput
    servico?: ServicoUpdateOneWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutCarrinhoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    produtoId?: NullableIntFieldUpdateOperationsInput | number | null
    servicoId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ItemUncheckedUpdateManyWithoutCarrinhoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    produtoId?: NullableIntFieldUpdateOperationsInput | number | null
    servicoId?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}